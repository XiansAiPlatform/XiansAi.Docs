{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AI Agent Control Center","text":"<p>  Build agents with the framework of your choice - Azure AI, Bedrock, Semantic Kernel, LangGraph, or your own custom runtime. Xians doesn't dictate how your agents think - it handles the plumbing that becomes painful once agents graduate beyond the demos. Multi-tenancy, human-in-the-loop workflows, long-running processes, scheduling, external triggers, agent-to-agent collaboration, scalability, fault tolerance, and observability. The complete control plane you need but would never want to build yourself.   </p> Get Started Introduction"},{"location":"#useful-resources","title":"Useful Resources","text":"<ul> <li>GitHub Organization</li> <li>Official Website</li> </ul>"},{"location":"concepts/A2A/","title":"Agent-to-Agent (A2A) Communication","text":"<p>A2A enables workflows to communicate with each other\u2014whether sending chat messages, data payloads, or invoking Temporal operations like signals, queries, and updates.</p>"},{"location":"concepts/A2A/#overview","title":"Overview","text":"Source Target Communication Method Any workflow Built-in workflow <code>SendChatAsync</code>, <code>SendDataAsync</code> Any workflow Custom workflow <code>SendSignalAsync</code>, <code>QueryAsync</code>, <code>UpdateAsync</code> <p>All A2A operations are accessed via <code>XiansContext.A2A</code> within workflow or activity contexts.</p>"},{"location":"concepts/A2A/#communicating-with-built-in-workflows","title":"Communicating with Built-in Workflows","text":"<p>Built-in workflows handle A2A messages through message listener methods (<code>OnUserChatMessage</code>, <code>OnUserDataMessage</code>).</p>"},{"location":"concepts/A2A/#sending-chat-messages","title":"Sending Chat Messages","text":"C#<pre><code>// Send to a specific workflow instance\nvar response = await XiansContext.A2A.SendChatAsync(targetWorkflow, new A2AMessage \n{ \n    Text = \"Hello\" \n});\n\n// Send to a built-in workflow by name\nvar response = await XiansContext.A2A.SendChatToBuiltInAsync(\"WebWorkflow\", new A2AMessage \n{ \n    Text = \"Process this request\" \n});\n\n// Shorthand for text-only messages\nvar response = await XiansContext.A2A.SendTextAsync(\"WebWorkflow\", \"Hello\");\n</code></pre>"},{"location":"concepts/A2A/#sending-data-messages","title":"Sending Data Messages","text":"C#<pre><code>var message = new A2AMessage\n{\n    Text = \"Process order\",\n    Data = new { orderId = \"12345\", items = new[] { \"item1\", \"item2\" } }\n};\n\nvar response = await XiansContext.A2A.SendDataToBuiltInAsync(\"OrderProcessor\", message);\n</code></pre>"},{"location":"concepts/A2A/#receiving-messages-target-workflow","title":"Receiving Messages (Target Workflow)","text":"C#<pre><code>var workflow = agent.Workflows.DefineBuiltIn(name: \"OrderProcessor\");\n\n// Handle chat messages\nworkflow.OnUserChatMessage(async context =&gt;\n{\n    var incomingText = context.Message.Text;\n    await context.ReplyAsync($\"Processed: {incomingText}\");\n});\n\n// Handle data messages\nworkflow.OnUserDataMessage(async context =&gt;\n{\n    var orderData = context.Message.Data;\n    await context.ReplyAsync(\"Order received\", new { status = \"confirmed\" });\n});\n</code></pre>"},{"location":"concepts/A2A/#communicating-with-custom-workflows","title":"Communicating with Custom Workflows","text":"<p>Custom workflows use Temporal's native signal, query, and update mechanisms. These are ideal for structured, typed communication.</p>"},{"location":"concepts/A2A/#sending-signals-fire-and-forget","title":"Sending Signals (Fire-and-Forget)","text":"C#<pre><code>await XiansContext.A2A.SendSignalAsync(\n    workflowId: \"order-workflow-123\",\n    signalName: \"ProcessOrder\",\n    new { orderId = \"12345\", priority = \"high\" }\n);\n</code></pre>"},{"location":"concepts/A2A/#querying-state-read-only","title":"Querying State (Read-Only)","text":"C#<pre><code>var state = await XiansContext.A2A.QueryAsync&lt;OrderState&gt;(\n    workflowId: \"order-workflow-123\",\n    queryName: \"GetOrderStatus\",\n    \"12345\"  // query arguments\n);\n</code></pre>"},{"location":"concepts/A2A/#sending-updates-request-response","title":"Sending Updates (Request-Response)","text":"<p>Updates are synchronous operations that modify state and return a result. Requires Temporal Server 1.20+.</p> C#<pre><code>var result = await XiansContext.A2A.UpdateAsync&lt;ProcessResult&gt;(\n    workflowId: \"order-workflow-123\",\n    updateName: \"UpdateOrderStatus\",\n    new { orderId = \"12345\", status = \"shipped\" }\n);\n</code></pre>"},{"location":"concepts/A2A/#receiving-in-custom-workflows","title":"Receiving in Custom Workflows","text":"C#<pre><code>[Workflow(\"MyAgent:OrderWorkflow\")]\npublic class OrderWorkflow\n{\n    private readonly Queue&lt;object&gt; _requests = new();\n    private int _processedCount = 0;\n\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        while (true)\n        {\n            await Workflow.WaitConditionAsync(() =&gt; _requests.Count &gt; 0);\n            var request = _requests.Dequeue();\n            // Process request...\n        }\n    }\n\n    [WorkflowSignal(\"ProcessOrder\")]\n    public Task ProcessOrder(object request)\n    {\n        _requests.Enqueue(request);\n        return Task.CompletedTask;\n    }\n\n    [WorkflowQuery(\"GetOrderStatus\")]\n    public OrderState GetOrderStatus(string orderId)\n    {\n        return new OrderState { OrderId = orderId, Count = _processedCount };\n    }\n\n    [WorkflowUpdate(\"UpdateOrderStatus\")]\n    public Task&lt;ProcessResult&gt; UpdateOrderStatus(object request)\n    {\n        _processedCount++;\n        return Task.FromResult(new ProcessResult { Status = \"Updated\" });\n    }\n}\n</code></pre>"},{"location":"concepts/A2A/#a2amessage-properties","title":"A2AMessage Properties","text":"Property Description <code>Text</code> Primary text content <code>Data</code> Structured data payload (any serializable object) <code>Metadata</code> Key-value pairs for custom metadata <code>Authorization</code> Auth token passed to target context <code>ThreadId</code> Conversation/correlation tracking <code>ParticipantId</code> Original user/caller identifier <code>Scope</code> Defaults to <code>\"A2A\"</code> <code>Hint</code> Processing hint for the target"},{"location":"concepts/A2A/#preserving-context","title":"Preserving Context","text":"<p>Use <code>A2AMessage.FromContext()</code> to forward context fields when chaining A2A calls:</p> C#<pre><code>workflow.OnUserChatMessage(async context =&gt;\n{\n    // Preserve original context when forwarding\n    var message = A2AMessage.FromContext(context, text: \"Forward this\");\n    message.Metadata = new Dictionary&lt;string, string&gt; { [\"source\"] = \"forwarder\" };\n\n    var response = await XiansContext.A2A.SendChatToBuiltInAsync(\"TargetWorkflow\", message);\n});\n</code></pre>"},{"location":"concepts/A2A/#error-handling","title":"Error Handling","text":"<p>Use <code>Try*</code> variants for non-throwing error handling:</p> C#<pre><code>var (success, response, error) = await XiansContext.A2A.TrySendChatToBuiltInAsync(\n    \"WebWorkflow\", \n    new A2AMessage { Text = \"Hello\" }\n);\n\nif (!success)\n{\n    logger.LogWarning(\"A2A failed: {Error}\", error);\n}\n</code></pre>"},{"location":"concepts/A2A/#quick-reference","title":"Quick Reference","text":"C#<pre><code>// To Built-in workflows\nawait XiansContext.A2A.SendTextAsync(\"WorkflowName\", \"message\");\nawait XiansContext.A2A.SendChatToBuiltInAsync(\"WorkflowName\", message);\nawait XiansContext.A2A.SendDataToBuiltInAsync(\"WorkflowName\", message);\n\n// To Custom workflows  \nawait XiansContext.A2A.SendSignalAsync(workflowId, \"SignalName\", args);\nvar result = await XiansContext.A2A.QueryAsync&lt;T&gt;(workflowId, \"QueryName\", args);\nvar result = await XiansContext.A2A.UpdateAsync&lt;T&gt;(workflowId, \"UpdateName\", args);\n</code></pre>"},{"location":"concepts/agents/","title":"Agents &amp; Workflows","text":""},{"location":"concepts/agents/#overview","title":"Overview","text":"<p>Agents in Xians are database entities that provide identity and management capabilities for your AI applications. They serve as containers for workflows, knowledge, documents, and other resources, with built-in multi-tenancy and isolation.</p>"},{"location":"concepts/agents/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/agents/#agents","title":"Agents","text":"<p>An Agent is a registered entity that:</p> <ul> <li>Provides an identity for management and isolation purposes</li> <li>Can be system-scoped (templates deployable across tenants) or tenant-scoped (deployed to a specific tenant)</li> <li>Owns and manages collections of workflows, knowledge, and documents</li> <li>Automatically handles tenant isolation and resource scoping</li> </ul> <pre><code>graph TB\n    A[XiansAgent] --&gt; B[Workflows]\n    A --&gt; C[Knowledge]\n    A --&gt; D[Documents]\n    B --&gt; E[Built-In Workflow 1]\n    B --&gt; F[Built-In Workflow 2]\n    B --&gt; G[Custom Workflow 1]\n    B --&gt; H[Custom Workflow 2]</code></pre>"},{"location":"concepts/agents/#workflows","title":"Workflows","text":"<p>Workflows are Temporal-based execution units attached to agents. There are two types:</p>"},{"location":"concepts/agents/#built-in-workflows","title":"Built-In Workflows","text":"<p>Pre-built workflows with plumbing for common patterns:</p> <ul> <li>Listen to user messages (chat and data)</li> <li>Handle webhook invocations</li> <li>No workflow class definition required</li> </ul>"},{"location":"concepts/agents/#custom-workflows","title":"Custom Workflows","text":"<p>Plain Temporal workflows you define:</p> <ul> <li>Full control over workflow logic</li> <li>Access to all Temporal features (signals, queries, updates, child workflows)</li> <li>Automatic tenant isolation</li> <li>Scheduled execution support</li> </ul> <pre><code>sequenceDiagram\n    participant U as User\n    participant BW as Built-In Workflow\n    participant CW as Custom Workflow\n    participant A as Activities\n\n    U-&gt;&gt;BW: Send Message\n    BW-&gt;&gt;BW: Execute Handler\n    BW-&gt;&gt;U: Reply\n\n    U-&gt;&gt;CW: Webhook/Signal\n    CW-&gt;&gt;A: Execute Activities\n    A--&gt;&gt;CW: Results\n    CW-&gt;&gt;U: Response</code></pre>"},{"location":"concepts/agents/#agent-registration","title":"Agent Registration","text":""},{"location":"concepts/agents/#creating-an-agent","title":"Creating an Agent","text":"C#<pre><code>var xiansPlatform = await XiansPlatform.InitializeAsync(new XiansOptions\n{\n    ServerUrl = \"https://your-server.com\",\n    ApiKey = \"agent-certificate\"\n});\n\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"MyAgent\",\n    Version = \"1.0.0\",\n    Description = \"My intelligent agent\",\n    SystemScoped = true  // or false for tenant-specific\n});\n</code></pre>"},{"location":"concepts/agents/#system-scoped-vs-tenant-scoped","title":"System-Scoped vs Tenant-Scoped","text":"Type Scope Use Case Deployment System-Scoped Multi-tenant template Reusable agents across tenants Registered once, deployed to multiple tenants Tenant-Scoped Single tenant Tenant-specific customizations Deployed to developer's tenant only"},{"location":"concepts/agents/#agent-api-reference","title":"Agent API Reference","text":""},{"location":"concepts/agents/#properties","title":"Properties","text":"Property Type Description <code>Name</code> <code>string</code> Unique identifier for the agent <code>Version</code> <code>string?</code> Optional version identifier <code>Description</code> <code>string?</code> Human-readable description <code>SystemScoped</code> <code>bool</code> Whether agent is multi-tenant template <code>Workflows</code> <code>WorkflowCollection</code> Collection of workflows <code>Knowledge</code> <code>KnowledgeCollection</code> Knowledge base management <code>Documents</code> <code>DocumentCollection</code> Document storage and retrieval"},{"location":"concepts/agents/#methods","title":"Methods","text":"Method Description <code>GetBuiltInWorkflow(string? name)</code> Get a built-in workflow by name (null for unnamed) <code>GetCustomWorkflow&lt;T&gt;()</code> Get a custom workflow by type <code>GetAllWorkflows()</code> Get all workflows for this agent <code>UploadWorkflowDefinitionsAsync()</code> Upload workflow definitions to server <code>RunAllAsync(CancellationToken)</code> Run all registered workflows"},{"location":"concepts/agents/#defining-workflows","title":"Defining Workflows","text":""},{"location":"concepts/agents/#built-in","title":"Built-In","text":"<p>Built-in workflows are ideal for message-driven patterns:</p> C#<pre><code>// Define an unnamed built-in workflow\nvar workflow = agent.Workflows.DefineBuiltIn();\n\n// Define a named built-in workflow\nvar chatWorkflow = agent.Workflows.DefineBuiltIn(name: \"ChatHandler\");\n\n// Register message handler\nchatWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var userMessage = context.Message.Text;\n    var response = await ProcessMessage(userMessage);\n    await context.ReplyAsync(response);\n});\n\n// Register data message handler\nchatWorkflow.OnUserDataMessage(async (context) =&gt;\n{\n    var data = context.Message.Data;\n    await ProcessData(data);\n});\n</code></pre>"},{"location":"concepts/agents/#custom","title":"Custom","text":"<p>Custom workflows give you full Temporal capabilities:</p> C#<pre><code>// Define custom workflow\nvar customWorkflow = agent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;();\n\n// Add activities\ncustomWorkflow.AddActivity&lt;MyActivity&gt;();\ncustomWorkflow.AddActivity(new MyActivityInstance());\n\n// Add multiple activities\ncustomWorkflow.AddActivities(\n    new Activity1(),\n    new Activity2(),\n    new Activity3()\n);\n</code></pre>"},{"location":"concepts/agents/#example-custom-workflow-class","title":"Example Custom Workflow Class","text":"C#<pre><code>using Temporalio.Workflows;\n\n[Workflow]\npublic class MyCustomWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(WorkflowInput input)\n    {\n        // Execute activities\n        var result = await Workflow.ExecuteActivityAsync(\n            (MyActivity act) =&gt; act.ProcessAsync(input),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) }\n        );\n\n        // Wait for signals\n        await Workflow.WaitConditionAsync(() =&gt; signalReceived);\n\n        return result;\n    }\n\n    [WorkflowSignal]\n    public async Task HandleSignalAsync(SignalData data)\n    {\n        // Handle signal\n    }\n\n    [WorkflowQuery]\n    public string GetStatus() =&gt; currentStatus;\n}\n</code></pre>"},{"location":"concepts/agents/#workflow-api-reference","title":"Workflow API Reference","text":""},{"location":"concepts/agents/#properties_1","title":"Properties","text":"Property Type Description <code>WorkflowType</code> <code>string</code> Unique workflow type identifier (prefixed with agent name) <code>Name</code> <code>string?</code> Optional workflow name <code>Workers</code> <code>int</code> Number of worker instances, Default is 100 <code>Schedules</code> <code>ScheduleCollection?</code> Scheduled execution management"},{"location":"concepts/agents/#methods_1","title":"Methods","text":"Method Description <code>AddActivity(object)</code> Register activity instance (shared across workers) <code>AddActivity&lt;T&gt;()</code> Register activity type (new instance per worker) <code>AddActivities(params object[])</code> Register multiple activity instances <code>OnUserChatMessage(Func&lt;UserMessageContext, Task&gt;)</code> Register chat message handler (built-in only) <code>OnUserDataMessage(Func&lt;UserMessageContext, Task&gt;)</code> Register data message handler (built-in only) <code>RunAsync(CancellationToken)</code> Start workflow workers"},{"location":"concepts/agents/#message-context","title":"Message Context","text":"<p>When handling messages in built-in workflows, you receive a <code>UserMessageContext</code>:</p>"},{"location":"concepts/agents/#usermessagecontext-properties","title":"UserMessageContext Properties","text":"Property Type Description <code>Message</code> <code>CurrentMessage</code> The current message with text, data, and context information <code>Metadata</code> <code>Dictionary&lt;string, string&gt;?</code> Optional metadata for the message <code>SkipResponse</code> <code>bool</code> Set to true to prevent messages from being sent to the user"},{"location":"concepts/agents/#usermessagecontext-methods","title":"UserMessageContext Methods","text":"Method Description <code>ReplyAsync(string text)</code> Send a simple text reply <code>ReplyAsync(string text, object? data)</code> Send a reply with text and data <code>SendDataAsync(object data, string? content)</code> Send a data message with optional text <code>GetChatHistoryAsync(int page, int pageSize)</code> Retrieve paginated chat history <code>GetLastHintAsync()</code> Retrieve the last hint for this conversation <code>SendHandoffAsync(string targetWorkflowId, ...)</code> Hand off conversation to another workflow"},{"location":"concepts/agents/#currentmessage-properties","title":"CurrentMessage Properties","text":"<p>All message properties are accessed via <code>context.Message</code>:</p> Property Type Description <code>Text</code> <code>string</code> The text content of the message <code>ParticipantId</code> <code>string</code> The participant (user) ID <code>RequestId</code> <code>string</code> Unique request identifier <code>TenantId</code> <code>string</code> The tenant ID for multi-tenancy <code>Scope</code> <code>string?</code> Optional scope for the message <code>Hint</code> <code>string?</code> Optional hint for context <code>ThreadId</code> <code>string?</code> Thread ID for conversation tracking <code>Data</code> <code>object?</code> Associated data payload <code>Authorization</code> <code>string?</code> Authorization token if provided"},{"location":"concepts/agents/#accessing-agent-resources","title":"Accessing Agent Resources","text":"<p>Agent resources (Knowledge, Documents, Workflows) are accessed via <code>XiansContext</code>:</p> C#<pre><code>// In workflow or activity context\nvar agent = XiansContext.CurrentAgent;\nvar workflow = XiansContext.CurrentWorkflow;\nvar tenantId = XiansContext.TenantId;  // For system-scoped agents\n</code></pre>"},{"location":"concepts/agents/#example-usage","title":"Example Usage","text":"C#<pre><code>chatWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Access message data\n    var message = context.Message.Text;\n    var participantId = context.Message.ParticipantId;\n    var requestId = context.Message.RequestId;\n    var tenantId = context.Message.TenantId;\n    var threadId = context.Message.ThreadId;\n    var data = context.Message.Data;\n\n    // Reply to user\n    await context.ReplyAsync(\"Hello!\");\n\n    // Reply with text and data\n    await context.ReplyAsync(\"Response text\", new { key = \"value\" });\n\n    // Send data message\n    await context.SendDataAsync(new { key = \"value\" }, \"Optional text\");\n\n    // Access agent's knowledge via XiansContext\n    var agent = XiansContext.CurrentAgent;\n    var knowledgeItem = await agent.Knowledge.GetAsync(\"knowledge-name\");\n    var allKnowledge = await agent.Knowledge.ListAsync();\n\n    // Update knowledge\n    await agent.Knowledge.UpdateAsync(\"knowledge-name\", \"content\", type: \"instruction\");\n\n    // Access documents\n    var doc = await agent.Documents.GetAsync(\"doc-id\");\n\n    // Get chat history\n    var history = await context.GetChatHistoryAsync(page: 1, pageSize: 10);\n});\n</code></pre>"},{"location":"concepts/agents/#workflow-scheduling-self-scheduling-pattern","title":"Workflow Scheduling (Self-Scheduling Pattern)","text":"<p>Workflows can schedule themselves to run at specific times or intervals. This is done inside the workflow using <code>XiansContext.CurrentWorkflow.Schedules</code>:</p>"},{"location":"concepts/agents/#self-scheduling-example","title":"Self-Scheduling Example","text":"C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents.Core;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"MyAgent:RecurringTask\")]\npublic class RecurringTaskWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string taskId, int intervalHours)\n    {\n        // At the start of the workflow, ensure a recurring schedule exists\n        await EnsureScheduleExists(taskId, intervalHours);\n\n        // Perform the actual work\n        await DoWorkAsync(taskId);\n    }\n\n    private async Task EnsureScheduleExists(string taskId, int intervalHours)\n    {\n        try\n        {\n            // Self-schedule using XiansContext.CurrentWorkflow\n            // Automatically uses activities when in workflow context!\n            var schedule = await XiansContext.CurrentWorkflow.Schedules!\n                .Create($\"recurring-{taskId}\")\n                .WithIntervalSchedule(TimeSpan.FromHours(intervalHours))\n                .WithInput(new object[] { taskId, intervalHours })\n                .StartAsync();\n\n            Workflow.Logger.LogInformation(\n                \"Schedule created - will run every {Hours} hours\",\n                intervalHours);\n        }\n        catch (ScheduleAlreadyExistsException ex)\n        {\n            Workflow.Logger.LogInformation(\n                \"Schedule already exists: {ScheduleId}\",\n                ex.ScheduleId);\n        }\n    }\n\n    private async Task DoWorkAsync(string taskId)\n    {\n        // Your workflow logic here\n        Workflow.Logger.LogInformation(\"Processing task: {TaskId}\", taskId);\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#child-workflows","title":"Child Workflows","text":"<p>Workflows can start and execute other workflows as child workflows using <code>XiansContext.Workflows</code>:</p>"},{"location":"concepts/agents/#starting-child-workflows-fire-and-forget","title":"Starting Child Workflows (Fire and Forget)","text":"<p>Use <code>StartAsync</code> to start a child workflow without waiting for its completion:</p> C#<pre><code>[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string taskId)\n    {\n        // Start child workflow by type - fire and forget\n        await XiansContext.Workflows.StartAsync&lt;ChildWorkflow&gt;(\n            idPostfix: taskId,\n            args: new object[] { \"param1\", \"param2\" }\n        );\n\n        // Continue without waiting for child to complete\n        Workflow.Logger.LogInformation(\"Child workflow started\");\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#executing-child-workflows-wait-for-result","title":"Executing Child Workflows (Wait for Result)","text":"<p>Use <code>ExecuteAsync</code> to execute a child workflow and wait for its result:</p> C#<pre><code>[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(string data)\n    {\n        // Execute child workflow and wait for result\n        var result = await XiansContext.Workflows.ExecuteAsync&lt;ChildWorkflow, string&gt;(\n            idPostfix: \"process\",\n            args: new object[] { data }\n        );\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#xianscontextworkflows-api-reference","title":"XiansContext.Workflows API Reference","text":"Method Description <code>StartAsync&lt;TWorkflow&gt;(string? idPostfix, params object[] args)</code> Start child workflow by type without waiting <code>StartAsync(string workflowType, string? idPostfix, params object[] args)</code> Start child workflow by type string without waiting <code>ExecuteAsync&lt;TWorkflow, TResult&gt;(string? idPostfix, params object[] args)</code> Execute child workflow and wait for result <code>ExecuteAsync&lt;TResult&gt;(string workflowType, string? idPostfix, params object[] args)</code> Execute child workflow by type string and wait for result <p>Notes:</p> <ul> <li><code>idPostfix</code> is used to create unique workflow IDs (format: <code>{workflowType}-{idPostfix}</code>)</li> <li>If <code>idPostfix</code> is null, a GUID is generated automatically</li> <li>Throws <code>WorkflowAlreadyStartedException</code> if a workflow with the same ID is already running</li> <li>Works both inside workflows (as child workflows) and outside workflows (as new workflows)</li> </ul>"},{"location":"concepts/document-db/","title":"Document DB","text":""},{"location":"concepts/document-db/#flexible-data-storage-for-ai","title":"Flexible Data Storage for AI","text":"<p>Your agents need to remember things. Customer profiles, order history, session data, analytics - structured information that doesn't fit neatly into prompts. Document DB gives your agents a schema-less, queryable memory that scales.</p>"},{"location":"concepts/document-db/#the-data-storage-problem","title":"The Data Storage Problem","text":"<p>Traditional Databases:</p> <ul> <li>Define rigid schema \u2192 Hope you got it right</li> <li>Need a new field? \u2192 Migration script, downtime, anxiety</li> </ul> <p>Document DB:</p> <ul> <li>Store JSON documents \u2192 No schema needed</li> <li>New field? \u2192 Just add it</li> <li>Query flexibly \u2192 Find exactly what you need</li> </ul>"},{"location":"concepts/document-db/#understanding-type-and-key","title":"Understanding Type and Key","text":"<p>The foundation of Document DB is built on two critical fields:</p>"},{"location":"concepts/document-db/#type-your-document-categories","title":"Type: Your Document Categories","text":"<p><code>Type</code> is how you organize documents into logical groups. Think of it as your document's category:</p> C#<pre><code>Type = \"user-profile\"     // Customer data\nType = \"session\"          // Active sessions\nType = \"order\"            // Purchase history\nType = \"preferences\"      // User settings\nType = \"analytics-event\"  // Event logs\n</code></pre> <p>Why it matters: - Query all documents of a specific type - Organize your data semantically - Create natural data partitions per use case</p>"},{"location":"concepts/document-db/#key-your-semantic-identifier","title":"Key: Your Semantic Identifier","text":"<p><code>Key</code> is a human-readable, business-meaningful identifier. Instead of random UUIDs, use keys that make sense:</p> C#<pre><code>Key = \"user-12345\"           // User ID from your system\nKey = \"session-abc-def\"      // Session identifier\nKey = \"order-2024-001\"       // Order number\nKey = \"config-email-smtp\"    // Configuration name\n</code></pre> <p>Why it matters: - Instantly know what the document is - Debug easily in logs and dashboards - Retrieve without remembering random IDs</p>"},{"location":"concepts/document-db/#type--key-powerful-lookup","title":"Type + Key: Powerful Lookup","text":"<p>The real magic happens when you combine them:</p> C#<pre><code>// Save with Type + Key as unique identifier\nvar doc = new Document\n{\n    Type = \"user-preferences\",\n    Key = \"user-12345\",\n    Content = JsonSerializer.SerializeToElement(prefs)\n};\n\nawait agent.Documents.SaveAsync(doc, new DocumentOptions\n{\n    UseKeyAsIdentifier = true,  // Type+Key becomes the unique identifier\n    Overwrite = true            // Update if already exists\n});\n\n// Retrieve directly with Type + Key\nvar userPrefs = await agent.Documents.GetByKeyAsync(\"user-preferences\", \"user-12345\");\n</code></pre> <p>The Pattern: Text Only<pre><code>Type = \"What kind of data?\"\nKey = \"Which specific instance?\"\nType + Key = \"Exactly this document\"\n</code></pre></p> <p>Each agent can have multiple document types, and each type can have many documents with unique keys. This creates a powerful, self-documenting data organization system.</p>"},{"location":"concepts/document-db/#core-operations","title":"Core Operations","text":"<p>Every agent gets its own document collection. Documents are automatically scoped to your agent - no manual filtering required.</p>"},{"location":"concepts/document-db/#save--retrieve","title":"Save &amp; Retrieve","text":"C#<pre><code>// Save any JSON-serializable data\nvar profile = new Document\n{\n    Type = \"user-profile\",\n    Content = JsonSerializer.SerializeToElement(new\n    {\n        Name = \"Alice\",\n        Plan = \"premium\",\n        Credits = 1000\n    })\n};\n\nvar saved = await agent.Documents.SaveAsync(profile);\n\n// Get it back\nvar retrieved = await agent.Documents.GetAsync(saved.Id);\n</code></pre>"},{"location":"concepts/document-db/#working-with-type--key","title":"Working with Type + Key","text":"<p>Practical examples of the Type+Key pattern:</p> C#<pre><code>// User preferences: One document per user\nawait agent.Documents.SaveAsync(new Document\n{\n    Type = \"user-preferences\",\n    Key = $\"user-{userId}\",\n    Content = JsonSerializer.SerializeToElement(preferences)\n}, new DocumentOptions { UseKeyAsIdentifier = true, Overwrite = true });\n\n// Configuration: Named settings\nawait agent.Documents.SaveAsync(new Document\n{\n    Type = \"config\",\n    Key = \"email-templates\",\n    Content = JsonSerializer.SerializeToElement(templates)\n}, new DocumentOptions { UseKeyAsIdentifier = true, Overwrite = true });\n\n// Retrieve by Type + Key - no GUID needed!\nvar userPrefs = await agent.Documents.GetByKeyAsync(\"user-preferences\", $\"user-{userId}\");\nvar emailConfig = await agent.Documents.GetByKeyAsync(\"config\", \"email-templates\");\n</code></pre>"},{"location":"concepts/document-db/#query--filter","title":"Query &amp; Filter","text":"<p>Find exactly what you need:</p> C#<pre><code>// Query by type\nvar activeUsers = await agent.Documents.QueryAsync(new DocumentQuery\n{\n    Type = \"user-profile\",\n    MetadataFilters = new Dictionary&lt;string, object&gt;\n    {\n        [\"status\"] = \"active\",\n        [\"plan\"] = \"premium\"\n    },\n    Limit = 50\n});\n</code></pre>"},{"location":"concepts/document-db/#update--delete","title":"Update &amp; Delete","text":"C#<pre><code>// Update\nprofile.Content = JsonSerializer.SerializeToElement(new { Credits = 500 });\nawait agent.Documents.UpdateAsync(profile);\n\n// Delete one\nawait agent.Documents.DeleteAsync(profileId);\n\n// Delete many\nawait agent.Documents.DeleteManyAsync(new[] { id1, id2, id3 });\n\n// Check existence\nbool exists = await agent.Documents.ExistsAsync(profileId);\n</code></pre>"},{"location":"concepts/document-db/#advanced-features","title":"Advanced Features","text":""},{"location":"concepts/document-db/#time-to-live-ttl","title":"Time-to-Live (TTL)","text":"<p>Auto-expire temporary data:</p> C#<pre><code>var session = new Document\n{\n    Type = \"session\",\n    Content = JsonSerializer.SerializeToElement(new { Token = \"abc123\" })\n};\n\nawait agent.Documents.SaveAsync(session, new DocumentOptions\n{\n    TtlMinutes = 60  // Expires in 1 hour\n});\n</code></pre>"},{"location":"concepts/document-db/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Every document automatically includes: - <code>AgentId</code> - Scoped to your agent - <code>WorkflowId</code> - Linked to the workflow that created it (when applicable) - <code>CreatedAt</code>, <code>UpdatedAt</code> - Automatic timestamps - <code>ExpiresAt</code> - When TTL is set</p>"},{"location":"concepts/document-db/#agent-isolation","title":"Agent Isolation","text":"<p>Documents are private to each agent. Agent A cannot access Agent B's documents - it's automatic:</p> C#<pre><code>// Agent 1 saves a document\nvar doc = await agent1.Documents.SaveAsync(myDoc);\n\n// Agent 2 tries to get it\nvar result = await agent2.Documents.GetAsync(doc.Id);\n// Returns null - different agent, can't access\n</code></pre>"},{"location":"concepts/document-db/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/document-db/#document-organization-by-type","title":"Document Organization by Type","text":"<p>Here's how an e-commerce agent might organize its documents:</p> Text Only<pre><code>Agent: \"OrderProcessingAgent\"\n\u251c\u2500\u2500 Type: \"user-profile\"\n\u2502   \u251c\u2500\u2500 Key: \"user-001\" \u2192 { name, email, plan }\n\u2502   \u251c\u2500\u2500 Key: \"user-002\" \u2192 { name, email, plan }\n\u2502   \u2514\u2500\u2500 Key: \"user-003\" \u2192 { name, email, plan }\n\u2502\n\u251c\u2500\u2500 Type: \"order\"\n\u2502   \u251c\u2500\u2500 Key: \"order-2024-001\" \u2192 { items, total, status }\n\u2502   \u251c\u2500\u2500 Key: \"order-2024-002\" \u2192 { items, total, status }\n\u2502   \u2514\u2500\u2500 Key: \"order-2024-003\" \u2192 { items, total, status }\n\u2502\n\u251c\u2500\u2500 Type: \"session\"\n\u2502   \u251c\u2500\u2500 Key: \"session-abc\" \u2192 { userId, cart, expires }\n\u2502   \u2514\u2500\u2500 Key: \"session-xyz\" \u2192 { userId, cart, expires }\n\u2502\n\u2514\u2500\u2500 Type: \"config\"\n    \u251c\u2500\u2500 Key: \"payment-gateway\" \u2192 { apiKey, endpoint }\n    \u2514\u2500\u2500 Key: \"shipping-rates\" \u2192 { zones, rates }\n</code></pre> <p>Query examples: C#<pre><code>// Get all orders\nvar orders = await agent.Documents.QueryAsync(new DocumentQuery { Type = \"order\" });\n\n// Get specific user profile\nvar profile = await agent.Documents.GetByKeyAsync(\"user-profile\", \"user-001\");\n\n// Get configuration\nvar paymentConfig = await agent.Documents.GetByKeyAsync(\"config\", \"payment-gateway\");\n</code></pre></p>"},{"location":"concepts/document-db/#user-preferences-store","title":"User Preferences Store","text":"C#<pre><code>public async Task SaveUserPreferences(string userId, object prefs)\n{\n    var doc = new Document\n    {\n        Type = \"user-preferences\",\n        Key = userId,\n        Content = JsonSerializer.SerializeToElement(prefs)\n    };\n\n    await agent.Documents.SaveAsync(doc, new DocumentOptions\n    {\n        UseKeyAsIdentifier = true,\n        Overwrite = true\n    });\n}\n</code></pre>"},{"location":"concepts/document-db/#session-cache","title":"Session Cache","text":"C#<pre><code>var session = new Document\n{\n    Type = \"session\",\n    Key = sessionId,\n    Content = JsonSerializer.SerializeToElement(sessionData)\n};\n\nawait agent.Documents.SaveAsync(session, new DocumentOptions\n{\n    UseKeyAsIdentifier = true,\n    TtlMinutes = 30,  // Auto-cleanup\n    Overwrite = true\n});\n</code></pre>"},{"location":"concepts/document-db/#event-log","title":"Event Log","text":"C#<pre><code>var event = new Document\n{\n    Type = \"analytics-event\",\n    Content = JsonSerializer.SerializeToElement(new\n    {\n        Event = \"purchase\",\n        UserId = userId,\n        Amount = 99.99,\n        Timestamp = DateTime.UtcNow\n    }),\n    Metadata = new Dictionary&lt;string, object&gt;\n    {\n        [\"category\"] = \"revenue\",\n        [\"priority\"] = \"high\"\n    }\n};\n\nawait agent.Documents.SaveAsync(event);\n</code></pre> <p>Golden Rule: If you can describe your data as \"I need the <code>{Type}</code> for <code>{Key}</code>\", you're doing it right.</p> <p>Examples:</p> <ul> <li>\"I need the user-profile for user-12345\"</li> <li>\"I need the session for session-abc-123\"  </li> <li>\"I need the config for email-smtp\"</li> </ul>"},{"location":"concepts/document-db/#what-you-get","title":"What You Get","text":"<ul> <li>Schema-less - Store any JSON structure  </li> <li>Auto-scoped - Documents isolated per agent  </li> <li>Type-based categorization - Organize by document type  </li> <li>Semantic keys - Human-readable identifiers  </li> <li>Type + Key lookup - Direct retrieval without GUIDs  </li> <li>Queryable - Filter by type, metadata, keys  </li> <li>TTL Support - Auto-expire temporary data  </li> <li>Scalable - Handles small configs to large datasets  </li> <li>Type-safe - Full C# typing with <code>JsonSerializer</code></li> </ul>"},{"location":"concepts/document-db/#what-its-not","title":"What It's NOT","text":"<ul> <li>Not a relational database (no joins)  </li> <li>Not for large binary files (use blob storage)  </li> <li>Not for high-frequency writes (use caching layers)</li> </ul> <p>Document DB is your agent's persistent memory. Use it for configuration, state, user data, and anything your agent needs to remember between executions.</p>"},{"location":"concepts/hitl-tasks/","title":"Human-in-the-Loop Tasks","text":"<p>Human-in-the-Loop (HITL) tasks are a special type of workflow that enable seamless collaboration between agents and humans. They allow workflows to pause and wait for human approval, rejection, or iterative refinement before proceeding.</p>"},{"location":"concepts/hitl-tasks/#overview","title":"Overview","text":"<p>HITL tasks are the foundation of human-agent collaboration in Xians. When a workflow needs human input - whether to approve content, provide feedback, or make a decision - it creates a task that waits for human interaction. The task can be:</p> <ul> <li>Approved - Human accepts the work and workflow continues</li> <li>Rejected - Human rejects with a reason, workflow handles accordingly  </li> <li>Refined - Human or agent iteratively updates the draft work before final decision</li> </ul>"},{"location":"concepts/hitl-tasks/#enabling-hitl-tasks","title":"Enabling HITL Tasks","text":"<p>HITL tasks are optional and must be explicitly enabled for each agent. This keeps your agent lightweight if tasks aren't needed:</p> C#<pre><code>// Register agent\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"MyAgent\",\n    SystemScoped = false\n});\n\n// Define your workflows\nagent.Workflows.DefineBuiltIn(\"Conversational\");\nagent.Workflows.DefineCustom&lt;ContentApprovalWorkflow&gt;();\n\n// Enable HITL tasks (optional)\nawait agent.Workflows.WithTasks();  // Uses default max concurrent (100)\n// await agent.Workflows.WithTasks(maxConcurrent: 200);  // Or customize if needed\n\n// Run all workflows\nawait agent.RunAllAsync();\n</code></pre> <p>Key Points:</p> <ul> <li>Tasks are not enabled by default - call <code>WithTasks()</code> to enable</li> <li>Each agent gets its own task workflow: <code>{AgentName}:Task Workflow</code></li> <li>Configurable maxConcurrent allow scaling based on expected task volume</li> <li>Omit <code>WithTasks()</code> if your agent doesn't need human interaction</li> </ul>"},{"location":"concepts/hitl-tasks/#creating-tasks-in-workflows","title":"Creating Tasks in Workflows","text":"<p>Tasks are created from within workflows using the <code>XiansContext.CurrentAgent.Tasks</code> API:</p> C#<pre><code>// Start a task and get a handle (non-blocking)\nvar taskHandle = await XiansContext.CurrentAgent.Tasks.StartTaskAsync(\n    new TaskWorkflowRequest\n    {\n        TaskId = $\"content-approval-{Workflow.NewGuid()}\",\n        Title = \"Approve Content\",\n        Description = \"Approve the content before it is published\",\n        ParticipantId = userId,\n        DraftWork = contentUrl\n    }\n);\n\n// Later, wait for the task to complete\nvar result = await XiansContext.CurrentAgent.Tasks.GetResultAsync(taskHandle);\n\nif (result.Success)\n{\n    // Task was approved - continue with finalWork\n    await PublishContentAsync(result.FinalWork);\n}\nelse\n{\n    // Task was rejected - handle rejection\n    _logger.LogWarning(\"Task rejected: {Reason}\", result.RejectionReason);\n}\n</code></pre> <p>Durable Execution with Temporal</p> <p>The waiting mechanism in <code>GetResultAsync()</code> is powered by Temporal's durable execution. This means: - Survives restarts: The workflow can wait even if your application restarts or crashes - Long-running: Can wait for days, weeks, months, or even years if needed - No polling: The wait is event-driven, not polling-based, so it's highly efficient - Guaranteed delivery: When the task completes, the workflow will resume exactly where it left off</p> <p>This is a fundamental advantage of building on Temporal - your workflows can reliably wait for human input without tying up resources or risking data loss.</p> <p>Key Methods:</p> <ul> <li><code>CreateAndWaitAsync()</code> - Creates task and blocks until completion</li> <li><code>StartTaskAsync()</code> - Creates task and returns handle immediately  </li> <li><code>GetResultAsync()</code> - Waits for task completion using handle</li> <li><code>CreateAsync()</code> - Fire-and-forget task creation (no result needed)</li> </ul>"},{"location":"concepts/hitl-tasks/#linking-tasks-to-conversations","title":"Linking Tasks to Conversations","text":"<p>The power of HITL tasks comes from linking them to conversational contexts using message hints:</p> C#<pre><code>// Send message with task workflow ID as a hint\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    conversationWorkflow,\n    userId,\n    \"This article is ready to be published. Please review.\",\n    scope: contentUrl,\n    hint: taskHandle.Id  // Task workflow ID becomes the hint\n);\n</code></pre> <p>The hint associates the task with the conversation scope, allowing agents to retrieve and interact with the task contextually.</p>"},{"location":"concepts/hitl-tasks/#interacting-with-tasks-via-agents","title":"Interacting with Tasks via Agents","text":"<p>Conversational agents can interact with tasks using the <code>HitlTask</code> class. The typical pattern retrieves the task from the conversation hint:</p> C#<pre><code>// In an agent tool function\nvar taskWorkflowId = await context.GetLastHintAsync();\nvar task = await HitlTask.FromWorkflowIdAsync(taskWorkflowId);\n\n// Get task information\nvar info = await task.GetInfoAsync();\nvar draft = await task.GetDraftAsync();\n\n// Update the draft\nawait task.UpdateDraftAsync(updatedContent);\n\n// Approve or reject\nawait task.ApproveAsync();\n// or\nawait task.RejectAsync(\"Content needs more detail\");\n</code></pre> <p>Common HitlTask Methods:</p> <ul> <li><code>GetInfoAsync()</code> - Get full task details (title, description, status, draft, metadata)</li> <li><code>GetDraftAsync()</code> - Get current draft work</li> <li><code>UpdateDraftAsync()</code> - Update draft work (collaborative editing)</li> <li><code>ApproveAsync()</code> / <code>CompleteAsync()</code> - Approve the task</li> <li><code>RejectAsync()</code> - Reject with a reason</li> <li><code>IsCompletedAsync()</code>, <code>IsPendingAsync()</code>, <code>IsRejectedAsync()</code> - Check task state</li> </ul>"},{"location":"concepts/hitl-tasks/#complete-example-content-approval-workflow","title":"Complete Example: Content Approval Workflow","text":"<p>Here's how all the pieces come together in a real workflow:</p> C#<pre><code>[WorkflowRun]\npublic async Task&lt;string?&gt; RunAsync(string contentUrl, string userId)\n{\n    // 1. Notify user about new content\n    await XiansContext.Messaging.SendChatAsWorkflowAsync(\n        ConversationWorkflow, \n        userId, \n        $\"New article found: {contentUrl}\", \n        scope: contentUrl);\n\n    // 2. Create approval task\n    var taskHandle = await XiansContext.CurrentAgent.Tasks.StartTaskAsync(\n        new TaskWorkflowRequest\n        {\n            TaskId = $\"content-approval-{Workflow.NewGuid()}\",\n            Title = \"Approve Content\",\n            Description = \"Approve the content before publishing\",\n            ParticipantId = userId,\n            DraftWork = contentUrl\n        }\n    );\n\n    // 3. Link task to conversation via hint\n    await XiansContext.Messaging.SendChatAsWorkflowAsync(\n        ConversationWorkflow,\n        userId,\n        \"Please review. Should I publish this article?\",\n        scope: contentUrl,\n        hint: taskHandle.Id);  // Critical: task ID as hint\n\n    // 4. Wait for human decision\n    var result = await XiansContext.CurrentAgent.Tasks.GetResultAsync(taskHandle);\n\n    // 5. Handle result\n    return result.Success \n        ? $\"Published: {result.FinalWork}\"\n        : $\"Rejected: {result.RejectionReason}\";\n}\n</code></pre>"},{"location":"concepts/hitl-tasks/#agent-tools-for-task-management","title":"Agent Tools for Task Management","text":"<p>Conversational agents expose tasks through AI function tools:</p> C#<pre><code>[Description(\"Get information about the current task\")]\npublic async Task&lt;string&gt; GetTaskInfo()\n{\n    var taskWorkflowId = await _context.GetLastHintAsync();\n    var task = await HitlTask.FromWorkflowIdAsync(taskWorkflowId);\n    var info = await task.GetInfoAsync();\n\n    return $\"Task: {info.Title}\\n\" +\n           $\"Status: {(info.IsCompleted ? \"Complete\" : \"Pending\")}\\n\" +\n           $\"Draft: {info.CurrentDraft}\";\n}\n\n[Description(\"Approve and complete the current task\")]\npublic async Task&lt;string&gt; ApproveTask()\n{\n    var taskWorkflowId = await _context.GetLastHintAsync();\n    var task = await HitlTask.FromWorkflowIdAsync(taskWorkflowId);\n    await task.ApproveAsync();\n    return \"Task approved successfully.\";\n}\n</code></pre> <p>These tools empower the AI agent to understand pending tasks and facilitate human decisions through natural conversation.</p>"},{"location":"concepts/hitl-tasks/#the-hint-pattern","title":"The Hint Pattern","text":"<p>The hint pattern is central to Xians HITL design:</p> <ol> <li>Workflow creates a task and sends a message with the task workflow ID as a hint</li> <li>Message hint scopes the task to that conversation context</li> <li>Agent tool retrieves the hint from conversation context (<code>GetLastHintAsync()</code>)</li> <li>HitlTask is reconstructed from the workflow ID to interact with the task</li> <li>Human approves/rejects through conversation, agent executes via tools</li> <li>Workflow resumes when task completes</li> </ol> <p>This pattern creates a seamless bridge between long-running workflows and conversational agents, enabling natural human-agent collaboration without exposing workflow complexity to the user.</p>"},{"location":"concepts/hitl-tasks/#direct-task-operations-outside-workflows","title":"Direct Task Operations (Outside Workflows)","text":"<p>You can also manage tasks directly from non-workflow code using the Temporal client:</p> C#<pre><code>// From outside a workflow\nvar task = new HitlTask(taskId, tenantId, temporalClient);\n\n// Or from workflow ID\nvar task = await HitlTask.FromWorkflowIdAsync(workflowId);\n\n// Query and control\nvar info = await task.GetInfoAsync();\nawait task.UpdateDraftAsync(updatedContent);\nawait task.ApproveAsync();\n</code></pre> <p>This is useful for external integrations, webhooks, or administrative tools that need to interact with tasks outside the workflow context.</p>"},{"location":"concepts/hitl-tasks/#best-practices","title":"Best Practices","text":"<ol> <li>Enable only when needed - Call <code>WithTasks()</code> only if your agent requires human interaction</li> <li>Use sensible defaults - Default max concurrent (100) handles most scenarios well</li> <li>Scale when necessary - Customize only for high-volume scenarios:</li> <li><code>WithTasks()</code> - Default (100 concurrent tasks) - suitable for most use cases</li> <li><code>WithTasks(maxConcurrent: 200)</code> - High volume scenarios with many simultaneous tasks</li> <li><code>WithTasks(maxConcurrent: 50)</code> - Limit concurrency to control resource usage</li> <li>Always use hints - Link tasks to conversations for contextual agent interaction</li> <li>Descriptive titles and descriptions - Help users understand what they're approving</li> <li>Meaningful draft work - Pre-populate drafts to give users a starting point</li> <li>Handle rejections gracefully - Use rejection reasons to improve or retry</li> <li>Proactive agents - Configure agents to check for pending tasks and prompt users</li> <li>Use metadata - Store additional context (URLs, references, etc.) for rich interactions</li> </ol>"},{"location":"concepts/hitl-tasks/#task-workflow-architecture","title":"Task Workflow Architecture","text":"<p>When you call <code>WithTasks()</code>, Xians dynamically creates a workflow class:</p> C#<pre><code>[Workflow(\"{AgentName}:Task Workflow\")]\npublic class DynamicTaskWorkflow : TaskWorkflow\n{\n    // Agent-specific task workflow implementation\n}\n</code></pre> <p>This ensures: - Agent isolation - Each agent has its own task queue - Independent scaling - Task workers scale independently per agent - Multi-tenancy - Tasks are automatically tenant-scoped - No conflicts - Multiple agents can use tasks simultaneously</p> <p>HITL tasks transform workflows from rigid automation into collaborative experiences where humans and agents work together naturally, each contributing their unique strengths.</p>"},{"location":"concepts/knowledge/","title":"Knowledge","text":""},{"location":"concepts/knowledge/#give-your-agents-domain-expertise","title":"Give Your Agents Domain Expertise","text":"<p>LLMs are smart, but they don't know your business. Your products, your policies, your documentation. Knowledge bases solve this through Retrieval-Augmented Generation (RAG)\u2014letting agents search your content and ground their answers in your truth.</p>"},{"location":"concepts/knowledge/#what-is-agent-knowledge","title":"What is Agent Knowledge?","text":"<p>Every agent has its own private knowledge base\u2014a key-value store for information your agent needs to remember and retrieve. Think of it as your agent's memory:</p> <ul> <li>System instructions that users create to customize agent behavior</li> <li>Product catalogs for a sales agent</li> <li>Company policies for a support agent  </li> <li>User preferences for a personalization agent</li> <li>Workflow instructions for complex processes</li> </ul> <p>Knowledge is automatically scoped to each agent. Agent A can't access Agent B's knowledge\u2014perfect for multi-tenant applications.</p>"},{"location":"concepts/knowledge/#managing-knowledge","title":"Managing Knowledge","text":""},{"location":"concepts/knowledge/#create-or-update-knowledge","title":"Create or Update Knowledge","text":"C#<pre><code>var agent = XiansContext.GetAgent(agentName); // or var agent = XiansContext.CurrentAgent;\n// Create or update knowledge\nawait agent.Knowledge.UpdateAsync(\n    knowledgeName: \"welcome-message\",\n    content: \"Welcome! How can I help you today?\",\n    type: \"text\"\n);\n</code></pre> <p>Supported knowledge types:</p> <ul> <li><code>\"text\"</code> - Plain text content</li> <li><code>\"markdown\"</code> - Formatted documentation with Markdown syntax</li> <li><code>\"json\"</code> - Structured data</li> </ul> <p>Any other type value is treated as <code>\"text\"</code>.</p>"},{"location":"concepts/knowledge/#retrieve-knowledge","title":"Retrieve Knowledge","text":"C#<pre><code>// Get specific knowledge\nvar knowledge = await agent.Knowledge.GetAsync(\"welcome-message\");\n\nif (knowledge != null)\n{\n    Console.WriteLine($\"Content: {knowledge.Content}\");\n    Console.WriteLine($\"Type: {knowledge.Type}\");\n}\n</code></pre>"},{"location":"concepts/knowledge/#list-all-knowledge","title":"List All Knowledge","text":"C#<pre><code>// See everything your agent knows\nvar allKnowledge = await agent.Knowledge.ListAsync();\n\nforeach (var item in allKnowledge)\n{\n    Console.WriteLine($\"{item.Name}: {item.Type}\");\n}\n</code></pre>"},{"location":"concepts/knowledge/#delete-knowledge","title":"Delete Knowledge","text":"C#<pre><code>// Remove outdated knowledge\nvar deleted = await agent.Knowledge.DeleteAsync(\"old-policy\");\n// Returns true if deleted, false if not found\n</code></pre>"},{"location":"concepts/knowledge/#knowledge-in-workflows","title":"Knowledge in Workflows","text":"<p>Knowledge operations work seamlessly inside workflows\u2014the SDK automatically handles context switching:</p> C#<pre><code>[Workflow(\"CustomerSupport:HandleTicket\")]\npublic class TicketWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(string customerId)\n    {\n        // Get agent from workflow context\n        var agent = XiansContext.GetAgent(\"SupportAgent\");\n\n        // Retrieve customer preferences mid-workflow\n        var prefs = await agent.Knowledge.GetAsync($\"customer-{customerId}\");\n\n        // Use knowledge to personalize response\n        return $\"Hello! I see you prefer {prefs?.Content}\";\n    }\n}\n</code></pre> <p>The SDK uses context-aware execution to route workflow calls through Temporal activities automatically.</p>"},{"location":"concepts/knowledge/#agent-isolation","title":"Agent Isolation","text":"<p>Each agent's knowledge is completely isolated:</p> C#<pre><code>// Agent 1 creates knowledge\nawait salesAgent.Knowledge.UpdateAsync(\"pricing\", \"Enterprise: $999/mo\");\n\n// Agent 2 cannot see Agent 1's knowledge\nvar leaked = await supportAgent.Knowledge.GetAsync(\"pricing\");\n// Returns null - agents are isolated by tenant and name\n</code></pre> <p>Even if two agents use the same knowledge name, they maintain separate copies. Perfect for multi-tenant SaaS applications.</p>"},{"location":"concepts/knowledge/#best-practices","title":"Best Practices","text":"<p>Use descriptive names with prefixes: C#<pre><code>// Good: Organized and searchable\nawait agent.Knowledge.UpdateAsync(\"config.api.timeout\", \"30000\");\nawait agent.Knowledge.UpdateAsync(\"user-123-preferences\", \"dark-mode\");\nawait agent.Knowledge.UpdateAsync(\"template_greeting_morning\", \"Good morning!\");\n</code></pre></p> <p>Choose appropriate types: C#<pre><code>// Plain text for instructions or simple content\nawait agent.Knowledge.UpdateAsync(\n    \"onboarding-flow\",\n    \"Step 1: Verify email\\nStep 2: Set password\\nStep 3: Complete profile\",\n    \"text\"\n);\n\n// Structured data for parsing\nawait agent.Knowledge.UpdateAsync(\n    \"api-config\",\n    \"{\\\"timeout\\\":30,\\\"retries\\\":3}\",\n    \"json\"\n);\n\n// Markdown for formatted documentation\nawait agent.Knowledge.UpdateAsync(\n    \"user-guide\",\n    \"# Getting Started\\n\\n## Step 1\\nConnect your account...\",\n    \"markdown\"\n);\n</code></pre></p> <p>Handle large content: C#<pre><code>// Knowledge supports large content (tested up to 10KB+)\nvar largeDoc = File.ReadAllText(\"product-catalog.md\");\nawait agent.Knowledge.UpdateAsync(\"product-catalog\", largeDoc, \"markdown\");\n</code></pre></p>"},{"location":"concepts/knowledge/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/knowledge/#system-instructions-user-created","title":"System Instructions (User-Created)","text":"<p>One of the most powerful uses of knowledge is storing system instructions that users create to customize how their agent behaves.</p> C#<pre><code>// User creates custom system instructions through your UI\nvar userInstructions = @\"You are a friendly customer support agent.\nAlways greet customers warmly and ask how their day is going.\nWhen dealing with complaints, empathize first before offering solutions.\nUse casual language and avoid corporate jargon.\";\n\n// Store as agent knowledge\nawait agent.Knowledge.UpdateAsync(\n    \"system-instructions\",\n    userInstructions,\n    \"text\"\n);\n\n// Later, in your message handler, retrieve and use them\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var agent = XiansContext.GetAgent(\"CustomerSupportAgent\");\n    var systemInstructions = await agent.Knowledge.GetAsync(\"system-instructions\");\n\n    // Build your LLM messages with user's custom instructions\n    var messages = new List&lt;ChatMessage&gt;\n    {\n        new SystemMessage(systemInstructions?.Content ?? \"Default instructions\"),\n        new UserMessage(context.Message.Text)\n    };\n\n    var response = await llm.GetCompletionAsync(messages);\n    await context.ReplyAsync(response);\n});\n</code></pre> <p>This lets users fully customize their agent's personality and behavior without code changes or redeployment.</p>"},{"location":"concepts/knowledge/#user-preferences","title":"User Preferences","text":"C#<pre><code>// Store per-user settings\nawait agent.Knowledge.UpdateAsync(\n    $\"user-{userId}-settings\",\n    JsonSerializer.Serialize(userPrefs),\n    \"json\"\n);\n</code></pre>"},{"location":"concepts/knowledge/#dynamic-instructions","title":"Dynamic Instructions","text":"C#<pre><code>// Update agent behavior without redeploying\nawait agent.Knowledge.UpdateAsync(\n    \"current-promotion\",\n    \"Offer 20% off for new customers this week\",\n    \"text\"\n);\n</code></pre>"},{"location":"concepts/knowledge/#configuration-management","title":"Configuration Management","text":"C#<pre><code>// Centralized config accessible to all agent workflows\nawait agent.Knowledge.UpdateAsync(\"feature-flags\", \"{'newUI': true}\", \"json\");\n</code></pre>"},{"location":"concepts/overview/","title":"Concepts","text":"<p>Deep dive into Xians' core concepts and patterns for building production-ready AI agents. This section covers the architectural patterns, workflows, and capabilities that power enterprise agent systems.</p> Page Description SDK Patterns Understand key SDK design patterns for working with agents and workflows Agents Learn about agent registration, workflows, and multi-tenancy architecture Temporal Workflows Start, execute, and communicate with Temporal-based workflows Messaging Master message handling, replies, threads, scopes, and conversational patterns Web SDK Build web-based conversational UIs with the official TypeScript client Knowledge Manage prompts, instructions, and configuration shared between code and UI Document DB Store and query structured JSON data with semantic keys and metadata Scheduling Create time-based workflow automation with cron expressions and intervals Agent-to-Agent (A2A) Enable workflow communication through messages, signals, queries, and updates Human-in-the-Loop Implement approval workflows where agents pause for human review Webhooks Integrate external systems using incoming and outgoing HTTP callbacks"},{"location":"concepts/overview/#a-typical-agent-flow","title":"A Typical Agent Flow","text":"<p>Here's how features combine in a real-world scenario\u2014an autonomous content agent:</p> <pre><code>sequenceDiagram\n    participant S as \u23f0 Schedule\n    participant W as \ud83d\udd04 Workflow\n    participant K as \ud83d\udca1 Knowledge\n    participant D as \ud83d\udce6 Document DB\n    participant A2A as \ud83d\udd17 A2A\n    participant H as \ud83d\udc64 Human\n    participant M as \ud83d\udcac Messaging\n\n    S-&gt;&gt;W: Trigger daily content check\n    W-&gt;&gt;K: Fetch system instructions\n    W-&gt;&gt;D: Get pending content items\n    W-&gt;&gt;A2A: Send to analyzer agent\n    A2A--&gt;&gt;W: Return analysis\n    W-&gt;&gt;H: Create HITL approval task\n    H--&gt;&gt;W: Approve with edits\n    W-&gt;&gt;M: Notify user of publication\n    W-&gt;&gt;D: Update content status\n    W-&gt;&gt;S: Schedule next run</code></pre> <p>example: \"What's happening here?\"</p> Text Only<pre><code>1. **Schedule** triggers the workflow every morning\n2. **Knowledge** provides the agent's instructions and policies\n3. **Document DB** stores the content items being processed\n4. **A2A** delegates analysis to a specialized agent\n5. **HITL** pauses for human approval before publishing\n6. **Messaging** notifies stakeholders of the outcome\n7. **Schedule** ensures the cycle continues autonomously\n</code></pre>"},{"location":"concepts/replying/","title":"Messaging with Users","text":"<p>Built-in workflows in Xians provide a powerful messaging system that allows your agents to listen for incoming messages and respond to users naturally. This guide covers everything you need to know about handling user messages and crafting responses.</p>"},{"location":"concepts/replying/#overview","title":"Overview","text":"<p>When you define a built-in workflow (like a Conversational workflow), you can register message listeners that are triggered when users send messages to your agent. These listeners receive a rich context object that contains the incoming message details and provides methods to respond.</p>"},{"location":"concepts/replying/#message-listeners","title":"Message Listeners","text":""},{"location":"concepts/replying/#listening-to-chat-messages","title":"Listening to Chat Messages","text":"<p>The most common type of message is a chat message. Register a listener using <code>OnUserChatMessage</code>:</p> C#<pre><code>var conversationalWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Conversational\");\n\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Access the user's message\n    var userMessage = context.Message.Text;\n\n    // Process and respond\n    await context.ReplyAsync($\"You said: {userMessage}\");\n});\n</code></pre>"},{"location":"concepts/replying/#listening-to-data-messages","title":"Listening to Data Messages","text":"<p>For structured data messages, use <code>OnUserDataMessage</code>:</p> C#<pre><code>conversationalWorkflow.OnUserDataMessage(async (context) =&gt;\n{\n    // Access structured data from the message\n    var data = context.Message.Data;\n\n    // Process the data and respond\n    await context.ReplyAsync(\"Data received and processed!\");\n});\n</code></pre>"},{"location":"concepts/replying/#accessing-message-properties","title":"Accessing Message Properties","text":"<p>The <code>context.Message</code> property gives you access to all incoming message details:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Message content\n    var text = context.Message.Text;\n    var data = context.Message.Data;\n\n    // User and conversation context\n    var participantId = context.Message.ParticipantId;\n    var threadId = context.Message.ThreadId;\n    var requestId = context.Message.RequestId;\n\n    // Additional context\n    var scope = context.Message.Scope;\n    var hint = context.Message.Hint;\n    var tenantId = context.Message.TenantId;\n\n    // Authorization (if applicable)\n    var authorization = context.Message.Authorization;\n});\n</code></pre>"},{"location":"concepts/replying/#message-properties-reference","title":"Message Properties Reference","text":"Property Type Description <code>Text</code> <code>string</code> The text content of the message <code>Data</code> <code>object?</code> Structured data associated with the message <code>ParticipantId</code> <code>string</code> Unique identifier for the conversation participant <code>RequestId</code> <code>string</code> Unique identifier for this specific message request <code>ThreadId</code> <code>string?</code> Thread identifier for conversation threading <code>Scope</code> <code>string?</code> Optional scope for organizing messages into topics (see Scope) <code>Hint</code> <code>string?</code> Optional hint for message handling <code>TenantId</code> <code>string</code> Tenant identifier (for multi-tenant applications) <code>Authorization</code> <code>string?</code> Authorization token if provided"},{"location":"concepts/replying/#message-types","title":"Message Types","text":"<p>When responding to users, there are three distinct message types:</p> Type Purpose Method Use Case Chat Standard agent-user conversations <code>ReplyAsync()</code> Text-based communication and typical conversational interactions Data Passing structured data between parties <code>SendDataAsync()</code> Sending structured data objects; data is the primary content Handoff Transfer user to a different workflow/sub-agent <code>SendHandoffAsync()</code> Routing to specialized agents; requests UI to switch to a different workflow ID"},{"location":"concepts/replying/#responding-to-users","title":"Responding to Users","text":"<p>Xians provides several methods for sending responses back to users, each optimized for different use cases.</p>"},{"location":"concepts/replying/#simple-text-replies","title":"Simple Text Replies","text":"<p>The most straightforward way to respond is with plain text:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    await context.ReplyAsync(\"Hello! How can I help you today?\");\n});\n</code></pre>"},{"location":"concepts/replying/#replies-with-data","title":"Replies with Data","text":"<p>Send both text and structured data together using the optional <code>data</code> parameter:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var result = new \n    {\n        Status = \"Success\",\n        Timestamp = DateTime.UtcNow,\n        ProcessedItems = 42\n    };\n\n    await context.ReplyAsync(\"Processing complete!\", result);\n});\n</code></pre>"},{"location":"concepts/replying/#data-focused-responses","title":"Data-Focused Responses","text":"<p>When the primary response is structured data, use <code>SendDataAsync</code>:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var analyticsData = new \n    {\n        Metrics = new[] { 100, 200, 300 },\n        Labels = new[] { \"Jan\", \"Feb\", \"Mar\" }\n    };\n\n    // Data is the primary content\n    await context.SendDataAsync(analyticsData, \"Here are your analytics\");\n});\n</code></pre>"},{"location":"concepts/replying/#message-scope","title":"Message Scope","text":"<p>Scope is a powerful feature for organizing messages into isolated topics within a conversation thread. When messages share the same scope value, they form a distinct topic, allowing you to manage multiple parallel conversations or subject areas with the same participant.</p>"},{"location":"concepts/replying/#how-scope-works","title":"How Scope Works","text":"<ul> <li>Messages with the same scope string are grouped together as a topic</li> <li>Each scope creates an isolated conversation context within the thread</li> <li>Users and agents can set scope when sending messages or responding</li> <li>Scope is optional - messages without a scope belong to the main conversation</li> </ul>"},{"location":"concepts/replying/#accessing-current-message-scope","title":"Accessing Current Message Scope","text":"C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var currentScope = context.Message.Scope;\n\n    if (currentScope != null)\n    {\n        await context.ReplyAsync($\"Discussing topic: {currentScope}\");\n    }\n    else\n    {\n        await context.ReplyAsync(\"General conversation\");\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#best-practices-for-scope","title":"Best Practices for Scope","text":"<p>Use Human-Readable Scope Values</p> <p>Always use descriptive, human-readable strings for scope values. These can be displayed to users when showing conversation threads:</p> C#<pre><code>// Good - Clear, human-readable scope\nvar scope = \"Order #12345 - Delivery Status\";\nvar scope = \"Project Alpha - Budget Discussion\";\nvar scope = \"Technical Support - Login Issues\";\n\n// Bad - Technical IDs or codes\nvar scope = \"ord_12345_dlv_sts\";\nvar scope = \"uuid-1234-5678-9abc\";\n</code></pre>"},{"location":"concepts/replying/#creating-scoped-conversations","title":"Creating Scoped Conversations","text":"<p>When you want to start a new topic or respond within a specific scope, you can set the scope in your context. Messages will automatically inherit the current scope:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var userMessage = context.Message.Text.ToLower();\n\n    if (userMessage.Contains(\"order status\"))\n    {\n        // The scope from the incoming message will be preserved in the reply\n        // All subsequent messages in this topic will share this scope\n        await context.ReplyAsync(\n            \"Let me check your order status. Which order would you like to know about?\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#scope-with-chat-history","title":"Scope with Chat History","text":"<p>When retrieving chat history, only messages with the same scope are returned, maintaining topic isolation:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var currentScope = context.Message.Scope;\n\n    // This returns only messages with the same scope\n    var scopedHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n    if (currentScope != null)\n    {\n        // All messages in scopedHistory will share the same scope\n        await context.ReplyAsync(\n            $\"I see we've discussed '{currentScope}' in {scopedHistory.Count} previous messages.\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#reply-scope","title":"Reply Scope","text":"<p>When you send a reply, it automatically inherits the scope from the incoming message, maintaining topic continuity:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // This reply automatically uses the same scope as context.Message.Scope\n    await context.ReplyAsync(\"Your message is within the current scope.\");\n\n    // The sent message will have the same scope as the incoming message\n});\n</code></pre>"},{"location":"concepts/replying/#null-scope","title":"Null Scope","text":"<p>Messages sent without a specified scope (scope is <code>null</code>) form their own isolated context - the general conversation area within the thread:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    if (context.Message.Scope == null)\n    {\n        // This is a general conversation message\n        // History will only include other messages with null scope\n        var generalHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n        await context.ReplyAsync(\"Discussing general topics.\");\n    }\n    else\n    {\n        // This is a scoped topic message\n        var topicHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n        await context.ReplyAsync($\"Discussing: {context.Message.Scope}\");\n    }\n});\n</code></pre> <p>Key Points:</p> <ul> <li>Messages with <code>scope = null</code> are NOT accessible when querying with a specific scope</li> <li>Messages with <code>scope = \"Topic A\"</code> are NOT accessible when querying with <code>scope = null</code> or <code>scope = \"Topic B\"</code></li> <li>Each scope (including <code>null</code>) forms a completely isolated conversation context</li> <li>Scope isolation happens automatically - you don't need to manually filter messages</li> </ul>"},{"location":"concepts/replying/#chat-history","title":"Chat History","text":"<p>Access the conversation history to provide context-aware responses:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Get the last 10 messages\n    var history = await context.GetChatHistoryAsync(page: 1, pageSize: 10);\n\n    // Use history to understand context\n    var messageCount = history.Count;\n    await context.ReplyAsync($\"I see we've exchanged {messageCount} messages so far.\");\n});\n</code></pre>"},{"location":"concepts/replying/#pagination","title":"Pagination","text":"<p>For longer conversations, use pagination:</p> C#<pre><code>// Get second page with 20 messages per page\nvar page2 = await context.GetChatHistoryAsync(page: 2, pageSize: 20);\n</code></pre>"},{"location":"concepts/replying/#working-with-hints","title":"Working with Hints","text":"<p>Retrieve the last hint to understand user intent or context:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var lastHint = await context.GetLastHintAsync();\n\n    if (lastHint != null)\n    {\n        await context.ReplyAsync($\"Based on your hint '{lastHint}', I'll help with that.\");\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#skipping-responses","title":"Skipping Responses","text":"<p>Sometimes you want to process a message without sending a response:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Set this flag to prevent automatic responses\n    context.SkipResponse = true;\n\n    // Process the message silently\n    await LogMessageToDatabase(context.Message.Text);\n\n    // No response will be sent to the user\n});\n</code></pre> <p>This is useful for:</p> <ul> <li>Analytics and logging</li> <li>Background processing</li> <li>Conditional response logic</li> </ul> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Conditionally skip responses\n    if (context.Message.Text.StartsWith(\"LOG:\"))\n    {\n        context.SkipResponse = true;\n        await LogSystemEvent(context.Message.Text);\n        return;\n    }\n\n    await context.ReplyAsync(\"Message received!\");\n});\n</code></pre>"},{"location":"concepts/replying/#handing-off-to-another-workflow","title":"Handing Off to Another Workflow","text":"<p>Transfer the conversation to a different workflow when needed:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    if (context.Message.Text.Contains(\"talk to sales\"))\n    {\n        await context.SendHandoffAsync(\n            targetWorkflowId: \"sales-workflow-id\",\n            message: \"Customer wants to discuss sales\",\n            data: new { Source = \"chat\", Priority = \"high\" },\n            userMessage: \"Connecting you with our sales team...\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#best-practices","title":"Best Practices","text":""},{"location":"concepts/replying/#1-always-handle-errors-gracefully","title":"1. Always Handle Errors Gracefully","text":"C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    try\n    {\n        var response = await ProcessMessageAsync(context.Message.Text);\n        await context.ReplyAsync(response);\n    }\n    catch (Exception ex)\n    {\n        // Log the error\n        logger.LogError(ex, \"Error processing message\");\n\n        // Send friendly error message to user\n        await context.ReplyAsync(\n            \"I encountered an error processing your request. Please try again.\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#2-provide-clear-actionable-responses","title":"2. Provide Clear, Actionable Responses","text":"C#<pre><code>//  Vague response\nawait context.ReplyAsync(\"Done\");\n\n//  Clear, informative response\nawait context.ReplyAsync(\"I've updated your preferences. You'll now receive daily summaries at 9 AM.\");\n</code></pre>"},{"location":"concepts/replying/#3-use-appropriate-response-methods","title":"3. Use Appropriate Response Methods","text":"C#<pre><code>// For text-only responses\nawait context.ReplyAsync(\"Simple message\");\n\n// For text with data\nawait context.ReplyAsync(\"Your order is ready!\", orderDetails);\n\n// When data is the primary response\nawait context.SendDataAsync(chartData, \"Here's your analytics dashboard\");\n</code></pre>"},{"location":"concepts/replying/#4-leverage-chat-history-wisely","title":"4. Leverage Chat History Wisely","text":"C#<pre><code>// Don't fetch too much history unnecessarily\nvar recentHistory = await context.GetChatHistoryAsync(pageSize: 5); // Good\n\n// Avoid excessive pagination in real-time handlers\nvar allHistory = await context.GetChatHistoryAsync(pageSize: 1000); // Potentially slow\n</code></pre>"},{"location":"concepts/replying/#5-use-descriptive-scopes-for-topic-organization","title":"5. Use Descriptive Scopes for Topic Organization","text":"C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var scope = context.Message.Scope;\n\n    // \u2705 Good - Users can understand the topic\n    if (scope == \"Order #12345 - Delivery Questions\")\n    {\n        await HandleOrderDeliveryQuestions(context);\n    }\n\n    // \u274c Bad - Cryptic scope values\n    if (scope == \"ord_dlv_12345\")\n    {\n        await HandleOrderDeliveryQuestions(context);\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#metadata-access","title":"Metadata Access","text":"<p>Access optional metadata passed with messages internally in the agent (For example in A2A message passing). Metada is not returned or obtained from the user.</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    if (context.Metadata != null)\n    {\n        if (context.Metadata.TryGetValue(\"priority\", out var priority))\n        {\n            // Handle high-priority messages differently\n            if (priority == \"high\")\n            {\n                await HandleUrgentMessage(context);\n            }\n        }\n    }\n\n    await context.ReplyAsync(\"Processing your request...\");\n});\n</code></pre>"},{"location":"concepts/replying/#message-threads","title":"Message Threads","text":"<p>Message threads are the fundamental organizational unit for conversations between users and agents in the Xians platform. Every message exchange is associated with a specific thread that groups related interactions together.</p>"},{"location":"concepts/replying/#thread-identity","title":"Thread Identity","text":"<p>Each message thread is uniquely identified by a composite primary key consisting of three components:</p> <ol> <li>Tenant ID: Identifies the organization or tenant</li> <li>Workflow ID: Identifies the specific workflow or agent instance  </li> <li>Participant ID: Identifies the user or participant in the conversation</li> </ol> <p>This three-part identifier ensures that conversations are properly isolated and organized across different tenants, workflows, and users.</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Thread identity components\n    var tenantId = context.Message.TenantId;           // Which organization\n    var workflowId = XiansContext.CurrentWorkflow.WorkflowType; // Which agent/workflow\n    var participantId = context.Message.ParticipantId; // Which user\n\n    // Together, these three values uniquely identify this conversation thread\n    // All messages between this user and this workflow in this tenant\n    // belong to the same thread\n});\n</code></pre>"},{"location":"concepts/replying/#thread-continuity","title":"Thread Continuity","text":"<p>All conversations between a specific user and agent workflow are grouped within a single thread, maintaining context and conversation history throughout the interaction lifecycle:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var threadId = context.Message.ThreadId;\n\n    if (threadId != null)\n    {\n        // This conversation has history\n        var allMessages = await context.GetChatHistoryAsync(pageSize: 100);\n\n        await context.ReplyAsync(\n            $\"We've exchanged {allMessages.Count} messages in this ongoing conversation.\"\n        );\n    }\n    else\n    {\n        // First message in this thread\n        await context.ReplyAsync(\"Welcome! This is the start of our conversation.\");\n    }\n});\n</code></pre> <p>Key Thread Characteristics:</p> <ul> <li>Persistent: Threads persist across multiple message exchanges and sessions</li> <li>Isolated: Messages in one thread are never visible to other threads</li> <li>Tenant-Scoped: Threads are isolated per tenant in multi-tenant applications</li> <li>Workflow-Specific: Each workflow maintains separate threads with the same user</li> <li>User-Specific: Each user has their own thread with each workflow</li> </ul>"},{"location":"concepts/replying/#thread-and-scope-management","title":"Thread and Scope Management","text":"<p>Threads and scopes work together in a hierarchical structure to organize conversations and manage context.</p>"},{"location":"concepts/replying/#hierarchical-organization","title":"Hierarchical Organization","text":"<p>The Xians messaging system uses a three-level hierarchy:</p> Text Only<pre><code>Thread (Top Level)\n\u251c\u2500\u2500 Scope: null (Default/General Conversation)\n\u2502   \u251c\u2500\u2500 Message 1\n\u2502   \u251c\u2500\u2500 Message 2\n\u2502   \u2514\u2500\u2500 Message 3\n\u251c\u2500\u2500 Scope: \"Order #12345\"\n\u2502   \u251c\u2500\u2500 Message 4\n\u2502   \u251c\u2500\u2500 Message 5\n\u2502   \u2514\u2500\u2500 Message 6\n\u2514\u2500\u2500 Scope: \"Technical Support\"\n    \u251c\u2500\u2500 Message 7\n    \u2514\u2500\u2500 Message 8\n</code></pre> <p>Hierarchy Breakdown:</p> <ol> <li>Thread: The top-level container (identified by Tenant + Workflow + Participant)</li> <li>Scope: Sub-organization within the thread (optional string identifier)</li> <li>Messages: Individual messages within a specific scope</li> </ol> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var threadId = context.Message.ThreadId;\n    var scope = context.Message.Scope;\n\n    if (threadId != null)\n    {\n        // This is part of a thread\n        var threadHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n        if (scope != null)\n        {\n            // Scoped topic within a thread\n            await context.ReplyAsync(\n                $\"Continuing our discussion about '{scope}' in this thread...\"\n            );\n        }\n        else\n        {\n            // General thread conversation (null scope)\n            await context.ReplyAsync(\"Continuing our conversation in this thread...\");\n        }\n    }\n    else\n    {\n        // New conversation\n        await context.ReplyAsync(\"Starting a new conversation!\");\n    }\n});\n</code></pre>"},{"location":"concepts/replying/#understanding-threads-vs-scope","title":"Understanding Threads vs Scope","text":"<ul> <li>Thread: A continuous conversation session between a user and agent workflow</li> <li>Purpose: Groups all interactions between a specific user and workflow</li> <li>Lifetime: Persists indefinitely across all message exchanges</li> <li> <p>Uniqueness: One thread per (Tenant, Workflow, Participant) combination</p> </li> <li> <p>Scope: Topics or subject areas within a thread for organizing messages</p> </li> <li>Purpose: Isolates related messages into distinct topics within a thread</li> <li>Lifetime: Exists as long as messages reference it</li> <li>Uniqueness: Multiple scopes can exist within a single thread</li> </ul> <p>Think of it as:</p> <ul> <li>Thread = The entire conversation book</li> <li>Scope = Individual chapters within that book</li> <li>Messages = Pages within each chapter</li> </ul>"},{"location":"concepts/replying/#practical-examples","title":"Practical Examples","text":"<p>Single Thread, Multiple Scopes:</p> C#<pre><code>// Example: Multiple topics within one thread\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var threadId = context.Message.ThreadId; // e.g., \"thread-123\"\n    var scope = context.Message.Scope;\n\n    // Same thread, different scopes = different topics in the same conversation\n    // - Thread \"thread-123\", Scope \"Order #5678\" (messages about this order)\n    // - Thread \"thread-123\", Scope \"Shipping Questions\" (shipping-related messages)\n    // - Thread \"thread-123\", Scope null (general chat messages)\n\n    // Each scope maintains its own isolated message history\n    var scopeHistory = await context.GetChatHistoryAsync(pageSize: 20);\n    // Only returns messages from the current scope\n});\n</code></pre> <p>Multi-User, Multi-Workflow Isolation:</p> C#<pre><code>// Different users with same workflow = different threads\n// User A + Workflow \"Sales\" + Tenant \"ACME\" = Thread 1\n// User B + Workflow \"Sales\" + Tenant \"ACME\" = Thread 2\n\n// Same user with different workflows = different threads  \n// User A + Workflow \"Sales\" + Tenant \"ACME\" = Thread 1\n// User A + Workflow \"Support\" + Tenant \"ACME\" = Thread 3\n\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // This user's history with THIS specific workflow\n    var workflowSpecificHistory = await context.GetChatHistoryAsync(pageSize: 50);\n\n    // Messages from other workflows are never visible here\n});\n</code></pre>"},{"location":"concepts/scaling/","title":"Scaling","text":"<p>The Xians platform provides flexible scaling options to handle varying workloads efficiently. You can scale both horizontally (multiple agent instances) and vertically (maxConcurrent per workflow), with the platform automatically handling distribution and fault tolerance through Temporal.</p>"},{"location":"concepts/scaling/#horizontal-scaling---multiple-agent-instances","title":"Horizontal Scaling - Multiple Agent Instances","text":"<p>You can spawn any number of agent console applications, and the platform automatically takes care of scaling and fault tolerance of agent runtimes. This is handled through Temporal maxConcurrent and activity distribution.</p>"},{"location":"concepts/scaling/#how-it-works","title":"How It Works","text":"<p>When you start multiple instances of the same agent application:</p> <ol> <li>Each instance registers as a Temporal worker for the same task queue</li> <li>Temporal automatically distributes workflow executions and activities across all available maxConcurrent</li> <li>If one instance fails, Temporal redistributs work to healthy instances</li> <li>No configuration changes needed - just start more instances</li> </ol>"},{"location":"concepts/scaling/#example","title":"Example","text":"Bash<pre><code># Terminal 1\ndotnet run --project MyAgent\n\n# Terminal 2\ndotnet run --project MyAgent\n\n# Terminal 3\ndotnet run --project MyAgent\n</code></pre> <p>All three instances will:</p> <ul> <li>Share the workload automatically</li> <li>Provide fault tolerance (if one crashes, others continue)</li> <li>Scale processing capacity linearly</li> </ul>"},{"location":"concepts/scaling/#benefits","title":"Benefits","text":"<ul> <li>Automatic Load Distribution: Temporal handles work distribution across all instances</li> <li>Fault Tolerance: Failed instances don't cause workflow failures</li> <li>Zero Configuration: No changes to code or configuration required</li> <li>Linear Scaling: More instances = more processing capacity</li> </ul>"},{"location":"concepts/scaling/#vertical-scaling---workers-per-workflow","title":"Vertical Scaling - Workers per Workflow","text":"<p>Within a single agent instance, you can configure the number of maxConcurrent per workflow to handle concurrent executions. This is specified when defining workflows.</p>"},{"location":"concepts/scaling/#built-in-workflows","title":"Built-In Workflows","text":"<p>Use the <code>maxConcurrent</code> parameter in <code>DefineBuiltIn()</code>:</p> C#<pre><code>// Single worker (default)\nagent.Workflows.DefineBuiltIn();\n\n// Multiple maxConcurrent for concurrent executions\nagent.Workflows.DefineBuiltIn(name: \"Data Processor Workflow\", maxConcurrent: 200);\n</code></pre>"},{"location":"concepts/scaling/#custom-workflows","title":"Custom Workflows","text":"<p>Use the <code>maxConcurrent</code> parameter in <code>DefineCustom&lt;T&gt;()</code>:</p> C#<pre><code>// Single worker (default)\nagent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;();\n\n// Multiple maxConcurrent for concurrent executions\nagent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;(maxConcurrent: 5);\n</code></pre>"},{"location":"concepts/scaling/#example-multi-workflow-agent","title":"Example: Multi-Workflow Agent","text":"C#<pre><code>var agent = platform.Agents.DefineAgent(\"DataPipeline\");\n\n// Low concurrency workflow\nagent.Workflows.DefineBuiltIn(name: \"Coordinator\", maxConcurrent: 2);\n\n// High concurrency workflow for data processing\nagent.Workflows.DefineBuiltIn(name: \"Processor\", maxConcurrent: 20);\n\n// Custom workflow with moderate concurrency\nagent.Workflows.DefineCustom&lt;ValidationWorkflow&gt;(maxConcurrent: 10);\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"concepts/scaling/#combining-horizontal-and-vertical-scaling","title":"Combining Horizontal and Vertical Scaling","text":"<p>You can combine both scaling strategies for maximum flexibility:</p> C#<pre><code>// Define agent with 10 maxConcurrent per workflow\nvar agent = platform.Agents.DefineAgent(\"HighThroughputAgent\");\nagent.Workflows.DefineBuiltIn(maxConcurrent: 10);\n\nawait agent.RunAsync();\n</code></pre> <p>Then spawn 5 instances:</p> <ul> <li>Total capacity: 5 instances \u00d7 10 maxConcurrent = 50 concurrent executions</li> <li>Fault tolerance: If 2 instances fail, 30 maxConcurrent still available</li> <li>Flexible scaling: Add/remove instances as needed</li> </ul>"},{"location":"concepts/scaling/#auto-scaling-based-on-queue-metrics","title":"Auto Scaling Based on Queue Metrics","text":"<p>For dynamic scaling scenarios, you can monitor the Temporal queue size to automatically adjust the number of maxConcurrent. This approach enables responsive scaling based on actual workload demand.</p>"},{"location":"concepts/scaling/#monitoring-queue-size-for-auto-scaling","title":"Monitoring Queue Size for Auto Scaling","text":"<p>Temporal provides metrics that allow you to monitor the backlog of pending workflow executions and activities. By tracking these metrics, you can implement auto-scaling logic to spawn or terminate agent instances based on demand.</p>"},{"location":"concepts/scaling/#implementation-approaches","title":"Implementation Approaches","text":""},{"location":"concepts/scaling/#1-external-monitoring-service","title":"1. External Monitoring Service","text":"<p>Set up a monitoring service that:</p> <ul> <li>Queries Temporal metrics API for queue depth</li> <li>Compares against threshold values</li> <li>Triggers scaling actions (e.g., Kubernetes HPA, AWS Auto Scaling)</li> </ul> Bash<pre><code># Example: Query Temporal metrics (pseudo-code)\ncurl http://temporal:9090/metrics | grep temporal_task_queue_depth\n</code></pre>"},{"location":"concepts/scaling/#2-kubernetes-horizontal-pod-autoscaler-hpa","title":"2. Kubernetes Horizontal Pod Autoscaler (HPA)","text":"<p>Use Kubernetes HPA with custom metrics:</p> YAML<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: xians-agent-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: xians-agent\n  minReplicas: 2\n  maxReplicas: 20\n  metrics:\n  - type: External\n    external:\n      metric:\n        name: temporal_task_queue_backlog\n        selector:\n          matchLabels:\n            queue: \"DataPipeline:BuiltIn Workflow\"\n      target:\n        type: AverageValue\n        averageValue: \"10\"  # Scale up if &gt;10 tasks per pod\n</code></pre>"},{"location":"concepts/scaling/#3-programmatic-monitoring","title":"3. Programmatic Monitoring","text":"<p>Implement custom auto-scaling logic:</p> C#<pre><code>// Pseudo-code example\npublic class AutoScaler\n{\n    public async Task MonitorAndScale(CancellationToken ct)\n    {\n        while (!ct.IsCancellationRequested)\n        {\n            var queueDepth = await GetTemporalQueueDepth();\n\n            if (queueDepth &gt; 100)\n            {\n                // High load - signal to spawn more instances\n                await ScaleUp();\n            }\n            else if (queueDepth &lt; 10)\n            {\n                // Low load - signal to reduce instances\n                await ScaleDown();\n            }\n\n            await Task.Delay(TimeSpan.FromSeconds(30), ct);\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/scaling/#auto-scaling-metrics-to-monitor","title":"Auto Scaling Metrics to Monitor","text":"<ul> <li>Task Queue Depth: Number of pending workflow/activity executions</li> <li>Worker Utilization: Percentage of busy maxConcurrent</li> <li>Execution Rate: Workflows started vs completed per minute</li> <li>Latency: Time from workflow start to first activity execution</li> </ul>"},{"location":"concepts/scaling/#best-practices-for-auto-scaling","title":"Best Practices for Auto Scaling","text":"<ol> <li>Set Appropriate Thresholds</li> <li>Scale up before queues become too large</li> <li>Scale down gradually to avoid thrashing</li> <li> <p>Consider time-of-day patterns</p> </li> <li> <p>Implement Cooldown Periods</p> </li> <li>Wait before scaling again (e.g., 5 minutes)</li> <li> <p>Prevents rapid scaling oscillations</p> </li> <li> <p>Monitor Both Queue and Resource Utilization</p> </li> <li>Don't just scale on queue depth</li> <li> <p>Consider CPU, memory, and network metrics</p> </li> <li> <p>Test Scaling Behavior</p> </li> <li>Simulate high load scenarios</li> <li>Verify graceful scale-down behavior</li> <li> <p>Ensure no workflow failures during scaling</p> </li> <li> <p>Set Min/Max Boundaries</p> </li> <li>Minimum instances for availability</li> <li>Maximum instances for cost control</li> </ol>"},{"location":"concepts/scaling/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"concepts/scaling/#resource-limits","title":"Resource Limits","text":"<ul> <li>Memory: Each worker consumes memory; ensure adequate RAM</li> <li>CPU: More maxConcurrent = more CPU usage</li> <li>Connections: Each worker maintains Temporal connections</li> </ul>"},{"location":"concepts/scaling/#temporal-configuration","title":"Temporal Configuration","text":"<p>Ensure your Temporal cluster can handle the load:</p> <ul> <li>Adequate history service capacity</li> <li>Sufficient matching service resources</li> <li>Properly sized persistence layer</li> </ul>"},{"location":"concepts/scaling/#network-latency","title":"Network Latency","text":"<ul> <li>Workers in different regions may have higher latency</li> <li>Consider deploying Temporal maxConcurrent close to Temporal server</li> </ul>"},{"location":"concepts/scaling/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Start with fewer maxConcurrent and scale up as needed</li> <li>Monitor actual utilization vs provisioned capacity</li> <li>Use auto-scaling to optimize costs during low-traffic periods</li> </ul>"},{"location":"concepts/scaling/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>Track these metrics to optimize scaling:</p> <ul> <li>Workflow Execution Rate: Throughput per worker/instance</li> <li>Queue Latency: Time tasks wait before execution</li> <li>Worker Utilization: Percentage of maxConcurrent actively processing</li> <li>Failure Rate: Failed executions (may indicate overload)</li> </ul> <p>Use Temporal's built-in metrics and integrate with your monitoring stack (Prometheus, Grafana, etc.) for comprehensive observability.</p>"},{"location":"concepts/scaling/#summary","title":"Summary","text":"Scaling Type Method Use Case Configuration Horizontal Multiple instances High availability, fault tolerance Just spawn more processes Vertical Workers per workflow Concurrent executions within instance <code>maxConcurrent</code> parameter Auto Scaling Queue-based scaling Dynamic workload adaptation External monitoring + orchestration <p>The Xians platform's integration with Temporal provides powerful, flexible scaling capabilities with minimal configuration. Start simple and scale as your workload demands.</p>"},{"location":"concepts/scheduling/","title":"Scheduling Concepts","text":""},{"location":"concepts/scheduling/#what-are-schedules","title":"What Are Schedules?","text":"<p>Schedules are cron jobs for AI agents. They let your workflows execute on time-based triggers - daily reports at 9 AM, hourly health checks, weekly analytics, or any recurring task your agents need to handle.</p> <p>Unlike traditional cron jobs, Xians schedules are:</p> <ul> <li>Durable - Survive restarts and failures</li> <li>Multi-tenant aware - Automatic isolation per tenant</li> <li>Workflow-native - Fully deterministic when used inside workflows</li> <li>Production-ready - Built-in retries, timeouts, and overlap policies</li> </ul> <p>Powered by Temporal Schedules, wrapped in a fluent API that feels natural to use.</p>"},{"location":"concepts/scheduling/#why-scheduling","title":"Why Scheduling?","text":"<p>AI agents need to be proactive, not just reactive. Schedules let your agents:</p> <ul> <li>Run daily data syncs without manual triggers</li> <li>Generate morning briefings automatically</li> <li>Perform background research on a schedule</li> <li>Monitor systems at regular intervals</li> <li>Orchestrate recurring business processes</li> </ul> <p>The key insight: Workflows that schedule themselves are autonomous. They control their own timing, create follow-up work, and operate continuously without external coordination.</p>"},{"location":"concepts/scheduling/#quick-start","title":"Quick Start","text":"<p>Here's a workflow that schedules itself to run every day at 9 AM:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Temporalio.Workflows;\n\n[Workflow(\"Daily Report Workflow\")]\npublic class DailyReportWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string reportType)\n    {\n        // Do the work\n        await GenerateReport(reportType);\n\n        // Schedule next run\n        var schedule = await XiansContext.CurrentWorkflow.Schedules!\n            .Create(\"daily-report\")\n            .Daily(hour: 9, timezone: \"America/New_York\")\n            .WithInput(reportType)\n            .SkipIfRunning()\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 3,\n                InitialInterval = TimeSpan.FromSeconds(10),\n                BackoffCoefficient = 2.0\n            })\n            .StartAsync();\n    }\n}\n</code></pre> <p>That's it. The workflow runs, does its work, and schedules the next execution. Your agent is now autonomous.</p>"},{"location":"concepts/scheduling/#scheduling-options","title":"Scheduling Options","text":""},{"location":"concepts/scheduling/#time-based-schedules","title":"Time-Based Schedules","text":"C#<pre><code>// Daily at specific time (timezone-aware)\n.Daily(hour: 9, timezone: \"America/New_York\")\n\n// Weekdays only\n.Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n\n// Weekly on specific day\n.Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n\n// Monthly\n.Monthly(dayOfMonth: 1, hour: 8, timezone: \"Asia/Tokyo\")\n</code></pre>"},{"location":"concepts/scheduling/#interval-based-schedules","title":"Interval-Based Schedules","text":"C#<pre><code>// Fixed intervals (no timezone - duration-based)\n.EverySeconds(30)\n.EveryMinutes(15)\n.EveryHours(2)\n.EveryDays(3)\n</code></pre>"},{"location":"concepts/scheduling/#cron-expressions","title":"Cron Expressions","text":"C#<pre><code>// Every 2 hours\n.WithCronSchedule(\"0 */2 * * *\")\n\n// Weekdays at 9 AM ET\n.WithCronSchedule(\"0 9 * * 1-5\", timezone: \"America/New_York\")\n\n// First of month at midnight\n.WithCronSchedule(\"0 0 1 * *\", timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling/#one-time-execution","title":"One-Time Execution","text":"C#<pre><code>// Specific future date/time\nvar futureDate = new DateTime(2026, 12, 25, 9, 0, 0);\n.WithCalendarSchedule(futureDate, timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling/#overlap-policies","title":"Overlap Policies","text":"<p>What happens when a schedule triggers but the previous execution is still running?</p> C#<pre><code>.SkipIfRunning()      // Skip new run (recommended for most cases)\n.AllowOverlap()       // Allow concurrent executions\n.BufferOne()          // Queue one execution for after current\n.CancelOther()        // Cancel running, start new\n.TerminateOther()     // Force stop running (use with caution)\n</code></pre> <p>Recommendation: Use <code>.SkipIfRunning()</code> by default. It prevents execution pile-up when workflows take longer than the schedule interval.</p>"},{"location":"concepts/scheduling/#managing-schedules","title":"Managing Schedules","text":"<p>Full lifecycle control from within workflows:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Get existing schedule\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Pause/resume\nawait schedule.PauseAsync(\"System maintenance\");\nawait schedule.UnpauseAsync(\"Maintenance complete\");\n\n// Trigger immediate run (doesn't affect schedule)\nawait schedule.TriggerAsync();\n\n// Delete\nawait schedule.DeleteAsync();\n\n// List all schedules (tenant-filtered)\nvar allSchedules = await workflow.Schedules!.ListAsync();\n</code></pre>"},{"location":"concepts/scheduling/#multi-tenant-isolation","title":"Multi-Tenant Isolation","text":"<p>Schedules automatically respect tenant boundaries - zero configuration required:</p> C#<pre><code>[Workflow(\"Multi-Tenant Task\")]\npublic class TenantTaskWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Schedule automatically scoped to current tenant\n        await workflow.Schedules!\n            .Create(\"daily-task\")  // Internal ID: \"{tenantId}:daily-task\"\n            .Daily(hour: 9)\n            .StartAsync();\n    }\n}\n</code></pre> <p>What you get:</p> <ul> <li>Schedules prefixed with tenant ID internally</li> <li><code>ListAsync()</code> only returns current tenant's schedules</li> <li>Cross-tenant access blocked automatically</li> <li>No manual tenant filtering needed</li> </ul>"},{"location":"concepts/scheduling/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/scheduling/#self-scheduling-workflow-recommended","title":"Self-Scheduling Workflow (Recommended)","text":"<p>Workflows that create their own recurring schedules:</p> C#<pre><code>[Workflow(\"Content Crawler\")]\npublic class ContentCrawlerWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string url, int intervalHours)\n    {\n        // Do the work\n        var content = await CrawlContent(url);\n        await ProcessContent(content);\n\n        // Schedule next run\n        await XiansContext.CurrentWorkflow.Schedules!\n            .Create($\"crawler-{url}\")\n            .EveryHours(intervalHours)\n            .WithInput(url, intervalHours)\n            .SkipIfRunning()\n            .StartAsync();\n    }\n}\n</code></pre> <p>Why this works well:</p> <ul> <li>Workflow controls its own timing</li> <li>Automatic determinism (SDK uses activities internally)</li> <li>Tenant context always available</li> <li>Clean separation of concerns</li> </ul>"},{"location":"concepts/scheduling/#bulk-schedule-creation","title":"Bulk Schedule Creation","text":"<p>Set up schedules for multiple entities:</p> C#<pre><code>[Workflow(\"Research Setup\")]\npublic class ResearchSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string[] companies)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        foreach (var company in companies)\n        {\n            await workflow.Schedules!\n                .Create($\"research-{company.ToLower()}\")\n                .Weekdays(hour: 8, timezone: \"America/New_York\")\n                .WithInput(company)\n                .SkipIfRunning()\n                .StartAsync();\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/scheduling/#how-it-works-workflow-aware-api","title":"How It Works: Workflow-Aware API","text":"<p>The scheduling SDK is context-aware:</p> <p>Inside workflows:</p> <ul> <li>SDK detects <code>Workflow.InWorkflow == true</code></li> <li>Automatically uses pre-registered <code>ScheduleActivities</code></li> <li>Maintains determinism</li> <li>No manual activity registration needed</li> </ul> <p>Outside workflows:</p> <ul> <li>Direct Temporal client calls</li> <li>No workflow context required</li> </ul> <p>Important: <code>XiansContext.CurrentWorkflow</code> only works inside workflows/activities. Using it elsewhere throws <code>InvalidOperationException</code>.</p>"},{"location":"concepts/scheduling/#production-features","title":"Production Features","text":"<p>Every schedule can have:</p> C#<pre><code>await workflow.Schedules!\n    .Create(\"production-task\")\n    .Daily(hour: 9, timezone: \"America/New_York\")\n    .WithInput(params)\n\n    // Retry failed executions\n    .WithRetryPolicy(new RetryPolicy\n    {\n        MaximumAttempts = 3,\n        InitialInterval = TimeSpan.FromSeconds(10),\n        BackoffCoefficient = 2.0\n    })\n\n    // Timeout protection\n    .WithTimeout(TimeSpan.FromHours(2))\n\n    // Prevent pile-up\n    .SkipIfRunning()\n\n    // Custom metadata for tracking\n    .WithMemo(new Dictionary&lt;string, object&gt;\n    {\n        { \"team\", \"data-engineering\" },\n        { \"priority\", \"high\" }\n    })\n\n    .StartAsync();\n</code></pre>"},{"location":"concepts/scheduling/#best-practices","title":"Best Practices","text":"<p>Do:</p> <ul> <li>Use <code>.SkipIfRunning()</code> to prevent execution pile-up</li> <li>Add retry policies for production schedules</li> <li>Specify timezones for time-based schedules</li> <li>Use descriptive IDs: <code>daily-sync-{company}</code> not <code>schedule1</code></li> <li>Check <code>ExistsAsync()</code> before creating for idempotency</li> </ul> <p>Don't:</p> <ul> <li>Mix schedule creation with business logic</li> <li>Forget to handle timezone differences</li> <li>Create schedules without overlap policies</li> <li>Use generic schedule IDs</li> </ul>"},{"location":"concepts/scheduling/#quick-reference","title":"Quick Reference","text":"C#<pre><code>// Common schedule patterns\n.Daily(hour: 9, timezone: \"America/New_York\")\n.Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n.EveryMinutes(30)\n.EveryHours(2)\n.Monthly(dayOfMonth: 1, hour: 9, timezone: \"America/New_York\")\n.WithCronSchedule(\"0 */2 * * *\")  // Every 2 hours\n</code></pre>"},{"location":"concepts/scheduling/#whats-next","title":"What's Next?","text":"<ul> <li>Scheduling SDK - Complete API reference and advanced examples</li> <li>Agents - Agent architecture and patterns</li> </ul> <p>Bottom line: Schedules turn reactive workflows into autonomous agents. They're the difference between \"run this when I tell you\" and \"run this every day at 9 AM until I tell you to stop.\"</p>"},{"location":"concepts/sdk-patterns/","title":"SDK Access Patterns","text":"<p>The Xians SDK is designed around explicit ownership\u2014every operation is accessed through its logical owner. No confusion, no guessing. Just four simple access patterns that cover everything.</p>"},{"location":"concepts/sdk-patterns/#quick-reference","title":"Quick Reference","text":"Access Pattern What It's For Available In Common Examples <code>UserMessageContext</code> Message-specific operations Message handlers only <code>context.ReplyAsync()</code><code>context.GetChatHistoryAsync()</code> <code>CurrentAgent</code> Agent-level data All workflows <code>XiansContext.CurrentAgent.Knowledge.SearchAsync()</code><code>XiansContext.CurrentAgent.Documents.SaveAsync()</code> <code>CurrentWorkflow</code> Workflow-level operations All workflows <code>XiansContext.CurrentWorkflow.Schedules.Create()</code><code>XiansContext.CurrentWorkflow.WorkflowId</code> <code>XiansContext</code> Cross-cutting orchestration All workflows <code>XiansContext.Messaging.SendChatAsync()</code><code>XiansContext.A2A.SendChatAsync()</code><code>XiansContext.Workflows.StartAsync&lt;T&gt;()</code><code>XiansContext.GetAgent()</code> / <code>GetWorkflow()</code>"},{"location":"concepts/sdk-patterns/#the-four-access-patterns","title":"The Four Access Patterns","text":""},{"location":"concepts/sdk-patterns/#1-usermessagecontext--for-message-specific-operations","title":"1. UserMessageContext \u2192 For Message-Specific Operations","text":"<p>When handling user messages in built-in workflows, use the <code>UserMessageContext</code> parameter for message-specific operations.</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt; \n{\n    // Message metadata\n    var userId = context.Message.ParticipantId;\n    var threadId = context.Message.ThreadId;\n\n    // Reply to THIS message\n    await context.ReplyAsync(\"Response\");\n\n    // Get THIS conversation's history\n    var history = await context.GetChatHistoryAsync();\n\n    // A2A communication\n    var targetWorkflow = XiansContext.GetWorkflow(\"Agent:Workflow\");\n    var response = await XiansContext.A2A.SendChatAsync(\n        targetWorkflow, \n        new A2AMessage { Text = \"message\" }\n    );\n});\n</code></pre> <p>When: Inside built-in workflow message handlers only Use for: Replying, conversation history, message metadata, contextual A2A</p>"},{"location":"concepts/sdk-patterns/#2-currentagent--for-agent-level-data","title":"2. CurrentAgent \u2192 For Agent-Level Data","text":"<p>Access knowledge and documents\u2014data that belongs to your agent across all workflows.</p> C#<pre><code>// Search agent's knowledge base\nvar results = await XiansContext.CurrentAgent.Knowledge.SearchAsync(\"query\");\n\n// Store agent-wide documents\nawait XiansContext.CurrentAgent.Documents.SaveAsync(new Document\n{\n    Type = \"user-preferences\",\n    Key = \"user-123\",\n    Content = JsonSerializer.SerializeToElement(data)\n});\n</code></pre> <p>When: Any workflow (built-in or custom) Use for: Knowledge search, document storage, agent metadata</p>"},{"location":"concepts/sdk-patterns/#3-currentworkflow--for-workflow-level-operations","title":"3. CurrentWorkflow \u2192 For Workflow-Level Operations","text":"<p>Access schedules and workflow-specific information.</p> C#<pre><code>// Create a schedule for THIS workflow\nawait XiansContext.CurrentWorkflow.Schedules!\n    .Create(\"daily-report\")\n    .Daily(hour: 9, minute: 0)\n    .WithInput(\"user-123\")\n    .StartAsync();\n\n// Get workflow metadata\nvar workflowId = XiansContext.CurrentWorkflow.WorkflowId;\nvar taskQueue = XiansContext.CurrentWorkflow.TaskQueue;\n</code></pre> <p>When: Any workflow (built-in or custom) Use for: Schedules, workflow identity, task queue info</p>"},{"location":"concepts/sdk-patterns/#4-xianscontext--for-cross-cutting-operations","title":"4. XiansContext \u2192 For Cross-Cutting Operations","text":"<p>Access orchestration features\u2014messaging, sub-workflows, and agent/workflow discovery.</p> C#<pre><code>// Start a sub-workflow\nawait XiansContext.Workflows.StartAsync&lt;NotificationWorkflow&gt;(\n    idPostfix: \"notify-123\",\n    args: new object[] { \"user-123\", \"message\" }\n);\n\n// Send proactive message to any user\nawait XiansContext.Messaging.SendChatAsync(\n    participantId: \"user-456\",\n    text: \"Your order shipped!\"\n);\n\n// A2A communication\nvar analyzer = XiansContext.GetWorkflow(\"Analyzer:Process\");\nvar result = await XiansContext.A2A.SendChatAsync(\n    analyzer,\n    new A2AMessage { Text = \"Analyze this content\" }\n);\n\n// Discover agents and workflows\nvar allAgents = XiansContext.GetAllAgents();\nvar tenant = XiansContext.TenantId;\n</code></pre> <p>When: Any workflow (built-in or custom) Use for: Proactive messaging, A2A, sub-workflows, agent/workflow registry</p>"},{"location":"concepts/sdk-patterns/#design-philosophy","title":"Design Philosophy","text":"<p>Explicit ownership. Every SDK feature is accessed through its logical owner:</p> <ul> <li>UserMessageContext owns reply operations</li> <li>Agent owns knowledge and documents</li> <li>Workflow owns schedules</li> <li>XiansContext orchestrates everything else</li> </ul>"},{"location":"concepts/webhook/","title":"Webhooks","text":"<p>Webhooks enable external systems to trigger and interact with your agent workflows in real-time. Think of them as HTTP callbacks that let third-party services (payment processors, CRMs, monitoring systems, etc.) push events directly into your agent ecosystem.</p>"},{"location":"concepts/webhook/#quick-start","title":"Quick Start","text":""},{"location":"concepts/webhook/#1-register-a-webhook-handler","title":"1. Register a Webhook Handler","text":"<p>Built-in workflows can handle webhooks using the <code>OnWebhook()</code> method. You can use either a synchronous or async handler:</p>"},{"location":"concepts/webhook/#synchronous-handler-for-simple-non-async-operations","title":"Synchronous Handler (for simple, non-async operations)","text":"C#<pre><code>using DotNetEnv;\nusing System.Net;\nusing Xians.Lib.Agents.Core;\nusing Xians.Lib.Agents.Messaging;\n\n// Load environment variables\nEnv.Load();\n\nvar serverUrl = Environment.GetEnvironmentVariable(\"XIANS_SERVER_URL\") \n    ?? throw new InvalidOperationException(\"XIANS_SERVER_URL not found\");\nvar xiansApiKey = Environment.GetEnvironmentVariable(\"XIANS_API_KEY\") \n    ?? throw new InvalidOperationException(\"XIANS_API_KEY not found\");\n\n// Initialize platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey\n});\n\n// Register agent (system-scoped can handle webhooks across all tenants)\nvar xiansAgent = xiansPlatform.Agents.Register(new()\n{\n    Name = \"WebhookTestAgent\",\n    SystemScoped = true\n});\n\n// Define built-in workflow\nvar integratorWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Integrator\");\n\n// Handle incoming webhooks (synchronous)\nintegratorWorkflow.OnWebhook((context) =&gt;\n{\n    // Your webhook processing logic here\n    Console.WriteLine($\"Received: {context.Webhook.Name}\");\n    context.Respond(new { status = \"success\" });\n});\n\n// Start the agent\nawait xiansAgent.RunAllAsync();\n</code></pre>"},{"location":"concepts/webhook/#async-handler-when-you-need-async-operations","title":"Async Handler (when you need async operations)","text":"<p>Use the async version when you need to perform async operations like database calls, HTTP requests, etc.:</p> C#<pre><code>// Handle incoming webhooks (async)\nintegratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    // Perform async operations\n    var result = await ProcessWebhookAsync(context.Webhook.Payload);\n    context.Respond(new { status = \"success\", result });\n});\n</code></pre>"},{"location":"concepts/webhook/#2-call-your-webhook","title":"2. Call Your Webhook","text":"<p>Once your agent is running, send POST requests to:</p> Text Only<pre><code>POST {SERVER_URL}/api/user/webhooks/builtin\n</code></pre>"},{"location":"concepts/webhook/#required-query-parameters","title":"Required Query Parameters","text":"Parameter Description Example <code>apikey</code> Your Xians API key <code>sk-Xnai-abc123...</code> <code>agentName</code> The target agent name <code>WebhookTestAgent</code> <code>workflowName</code> The target workflow name <code>Integrator</code> <code>webhookName</code> Any identifier for this webhook event <code>Email Received</code> <code>participantId</code> Any User/participant identifier <code>user@example.com</code>"},{"location":"concepts/webhook/#optional-query-parameters","title":"Optional Query Parameters","text":"Parameter Description Example <code>timeoutSeconds</code> Request timeout (default: 30s) <code>60</code> <code>scope</code> Custom scope for context (same as Chat messages) <code>tenant-123</code> <code>authorization</code> Auth token for your logic <code>Bearer jwt-token</code>"},{"location":"concepts/webhook/#request-body","title":"Request Body","text":"<p>Send your webhook payload as JSON in the request body:</p> JSON<pre><code>{\n  \"orderId\": \"12345\",\n  \"amount\": 99.99,\n  \"status\": \"completed\"\n}\n</code></pre>"},{"location":"concepts/webhook/#complete-example","title":"Complete Example","text":"Bash<pre><code>curl -X POST \"http://localhost:5005/api/user/webhooks/builtin?apikey=sk-Xnai-zSsUNO5KaeyHefrWEyQvvyOBmX0&amp;timeoutSeconds=30&amp;agentName=WebhookTestAgent&amp;workflowName=Integrator&amp;webhookName=OrderCompleted&amp;scope=tenant-123&amp;authorization=Bearer-token&amp;participantId=customer@example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"orderId\": \"12345\", \"amount\": 99.99, \"status\": \"completed\"}'\n</code></pre>"},{"location":"concepts/webhook/#3-monitor-webhooks-in-the-ui","title":"3. Monitor Webhooks in the UI","text":"<p>All webhook messages are visible in the Messaging Playground in the Xians UI, just like chat and data messages. This provides full visibility into webhook execution, timing, and metadata.</p> <p></p> <p>In the Messaging Playground, you can:</p> <ul> <li>View webhook messages alongside other message types in the conversation view</li> <li>Inspect message details including:</li> <li>Message Type: <code>Webhook</code></li> <li>Webhook name and participant ID</li> <li>Request ID for tracking</li> <li>Scope and authorization data</li> <li>Complete payload data</li> <li>Execution status and timing</li> <li>Track conversations created by webhook invocations</li> <li>Debug webhook flows by observing the complete message history</li> </ul> <p>This makes it easy to monitor, debug, and audit webhook integrations without needing to add custom logging.</p>"},{"location":"concepts/webhook/#extracting-webhook-information","title":"Extracting Webhook Information","text":"<p>The <code>WebhookContext</code> provides access to all webhook data through the <code>Webhook</code> property:</p> C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    // Extract webhook metadata\n    var webhookName = context.Webhook.Name;           // \"OrderCompleted\"\n    var participantId = context.Webhook.ParticipantId; // \"customer@example.com\"\n    var scope = context.Webhook.Scope;                // \"tenant-123\"\n    var authorization = context.Webhook.Authorization; // \"Bearer-token\"\n    var requestId = context.Webhook.RequestId;        // Unique request ID\n    var tenantId = context.Webhook.TenantId;          // Tenant context\n\n    // Extract payload (from POST body)\n    var payload = context.Webhook.Payload;\n\n    // For typed access, cast or deserialize:\n    if (payload is JsonElement jsonElement)\n    {\n        var orderId = jsonElement.GetProperty(\"orderId\").GetString();\n        var amount = jsonElement.GetProperty(\"amount\").GetDecimal();\n        var status = jsonElement.GetProperty(\"status\").GetString();\n\n        Console.WriteLine($\"Processing order {orderId} for ${amount}\");\n    }\n});\n</code></pre>"},{"location":"concepts/webhook/#available-webhook-properties","title":"Available Webhook Properties","text":"Property Type Description <code>Name</code> <code>string</code> Webhook name from query parameter <code>ParticipantId</code> <code>string</code> Participant identifier <code>Payload</code> <code>object?</code> Request body data (JSON) <code>Scope</code> <code>string?</code> Optional scope context <code>Authorization</code> <code>string?</code> Optional auth token <code>RequestId</code> <code>string</code> Unique request identifier <code>TenantId</code> <code>string</code> Tenant context"},{"location":"concepts/webhook/#responding-to-webhooks","title":"Responding to Webhooks","text":"<p>You have three ways to respond, all with full control over HTTP status codes, headers, and content.</p>"},{"location":"concepts/webhook/#option-1-simple-object-response","title":"Option 1: Simple Object Response","text":"<p>Perfect for straightforward JSON responses:</p> C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    // Process webhook...\n\n    // Respond with an object (auto-serialized to JSON)\n    context.Respond(new \n    { \n        message = \"Success\", \n        processedAt = DateTime.UtcNow \n    });\n});\n</code></pre>"},{"location":"concepts/webhook/#option-2-full-control-response","title":"Option 2: Full Control Response","text":"<p>For custom status codes, headers, and content types:</p> C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    context.Response = new WebhookResponse\n    {\n        StatusCode = HttpStatusCode.OK,\n        Content = \"{\\\"message\\\": \\\"Success\\\", \\\"id\\\": \\\"12345\\\"}\",\n        ContentType = \"application/json\",\n        Headers = new Dictionary&lt;string, string[]&gt;\n        {\n            [\"X-Custom-Header\"] = new[] { \"CustomValue\" },\n            [\"X-Request-Id\"] = new[] { context.Webhook.RequestId }\n        }\n    };\n});\n</code></pre>"},{"location":"concepts/webhook/#option-3-static-factory-methods","title":"Option 3: Static Factory Methods","text":"<p>Convenient helpers for common responses:</p> C#<pre><code>integratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    try\n    {\n        // Process webhook...\n        var result = await ProcessOrderAsync(context.Webhook.Payload);\n\n        // Success response\n        context.Response = WebhookResponse.Ok(new \n        { \n            success = true, \n            orderId = result.OrderId \n        });\n    }\n    catch (ValidationException ex)\n    {\n        // Bad request (400)\n        context.Response = WebhookResponse.BadRequest(ex.Message);\n    }\n    catch (NotFoundException ex)\n    {\n        // Not found (404)\n        context.Response = WebhookResponse.NotFound(ex.Message);\n    }\n    catch (Exception ex)\n    {\n        // Internal server error (500)\n        context.Response = WebhookResponse.InternalServerError(\n            $\"Failed to process webhook: {ex.Message}\");\n    }\n});\n</code></pre>"},{"location":"concepts/webhook/#available-factory-methods","title":"Available Factory Methods","text":"Method Status Code Description <code>WebhookResponse.Ok(object)</code> 200 Success with JSON data <code>WebhookResponse.Ok(string)</code> 200 Success with custom content <code>WebhookResponse.BadRequest(message)</code> 400 Validation/client error <code>WebhookResponse.NotFound(message)</code> 404 Resource not found <code>WebhookResponse.InternalServerError(message)</code> 500 Server error <code>WebhookResponse.Error(code, message)</code> Custom Custom status code"},{"location":"concepts/webhook/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/webhook/#authentication--authorization","title":"Authentication &amp; Authorization","text":"C#<pre><code>integratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    // Verify authorization token\n    var authToken = context.Webhook.Authorization;\n    if (string.IsNullOrEmpty(authToken) || !await ValidateTokenAsync(authToken))\n    {\n        context.Response = WebhookResponse.Error(\n            HttpStatusCode.Unauthorized, \n            \"Invalid or missing authorization token\");\n        return;\n    }\n\n    // Process authenticated webhook\n    // ...\n});\n</code></pre>"},{"location":"concepts/webhook/#payload-validation","title":"Payload Validation","text":"C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    if (context.Webhook.Payload is not JsonElement payload)\n    {\n        context.Response = WebhookResponse.BadRequest(\"Invalid payload format\");\n        return;\n    }\n\n    if (!payload.TryGetProperty(\"orderId\", out var orderIdElement))\n    {\n        context.Response = WebhookResponse.BadRequest(\"Missing required field: orderId\");\n        return;\n    }\n\n    // Continue processing...\n});\n</code></pre>"},{"location":"concepts/webhook/#async-processing","title":"Async Processing","text":"C#<pre><code>integratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    var webhookName = context.Webhook.Name;\n    var payload = context.Webhook.Payload;\n\n    // Start async processing\n    _ = Task.Run(async () =&gt; \n    {\n        await ProcessLongRunningTaskAsync(webhookName, payload);\n    });\n\n    // Respond immediately\n    context.Respond(new \n    { \n        status = \"accepted\", \n        message = \"Processing started\",\n        requestId = context.Webhook.RequestId\n    });\n});\n</code></pre>"},{"location":"concepts/webhook/#important-notes","title":"Important Notes","text":"<ul> <li>Error Handling: Always wrap webhook logic in try-catch blocks to provide meaningful error responses</li> <li>Timeouts: Default timeout is 30 seconds; adjust via <code>timeoutSeconds</code> parameter for long-running operations</li> <li>Security: Use the <code>authorization</code> parameter to pass and validate tokens in your webhook handler</li> <li>Request IDs: Use <code>context.Webhook.RequestId</code> for logging and tracking webhook requests</li> </ul>"},{"location":"concepts/webhook/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Agents &amp; Workflows for built-in workflows and system-scoped agents</li> <li>Explore Replying to Users for more messaging capabilities</li> <li>Check out SDK Patterns for common implementation patterns</li> </ul>"},{"location":"concepts/workflows/","title":"Temporal Workflows","text":""},{"location":"concepts/workflows/#starting-and-executing-workflows","title":"Starting and Executing Workflows","text":"<p>The Xians SDK provides <code>XiansContext.Workflows</code> to start and execute child workflows. These methods automatically create the necessary Temporal workflow search attributes and memo values that help keep workflows properly scoped (to tenant, agent, and user) and discoverable via the Xians UI.</p> <p>Always use <code>XiansContext.Workflows</code> instead of direct Temporal SDK calls when starting workflows.</p>"},{"location":"concepts/workflows/#xianscontextworkflows-api","title":"XiansContext.Workflows API","text":"<p><code>XiansContext.Workflows</code> provides methods for two primary patterns:</p> <ol> <li>Fire and Forget - Start a workflow without waiting for completion (<code>StartAsync</code>)</li> <li>Wait for Result - Execute a workflow and wait for its result (<code>ExecuteAsync</code>)</li> </ol>"},{"location":"concepts/workflows/#method-reference","title":"Method Reference","text":"Method Description <code>StartAsync&lt;TWorkflow&gt;(string? idPostfix, params object[] args)</code> Start child workflow by type without waiting <code>StartAsync(string workflowType, string? idPostfix, params object[] args)</code> Start child workflow by type string without waiting <code>ExecuteAsync&lt;TWorkflow, TResult&gt;(string? idPostfix, params object[] args)</code> Execute child workflow and wait for result <code>ExecuteAsync&lt;TResult&gt;(string workflowType, string? idPostfix, params object[] args)</code> Execute child workflow by type string and wait for result"},{"location":"concepts/workflows/#starting-workflows-fire-and-forget","title":"Starting Workflows (Fire and Forget)","text":"<p>Use <code>StartAsync</code> to start a workflow without waiting for its completion. This is useful for background tasks or when you don't need the result immediately.</p>"},{"location":"concepts/workflows/#by-workflow-type","title":"By Workflow Type","text":"C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents.Core;\n\n[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string taskId)\n    {\n        // Start child workflow by type - fire and forget\n        await XiansContext.Workflows.StartAsync&lt;BackgroundTaskWorkflow&gt;(\n            idPostfix: taskId,\n            args: new object[] { \"param1\", \"param2\" }\n        );\n\n        // Continue without waiting for child to complete\n        Workflow.Logger.LogInformation(\"Background task started\");\n\n        // You can start multiple workflows in parallel\n        await Task.WhenAll(\n            XiansContext.Workflows.StartAsync&lt;Task1Workflow&gt;(idPostfix: \"task1\"),\n            XiansContext.Workflows.StartAsync&lt;Task2Workflow&gt;(idPostfix: \"task2\"),\n            XiansContext.Workflows.StartAsync&lt;Task3Workflow&gt;(idPostfix: \"task3\")\n        );\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#by-workflow-type-string","title":"By Workflow Type String","text":"C#<pre><code>[WorkflowRun]\npublic async Task RunAsync(string workflowType, string taskId)\n{\n    // Start workflow by type string (useful for dynamic workflow selection)\n    await XiansContext.Workflows.StartAsync(\n        workflowType: \"MyAgent:DynamicWorkflow\",\n        idPostfix: taskId,\n        args: new object[] { \"param1\", \"param2\" }\n    );\n}\n</code></pre>"},{"location":"concepts/workflows/#executing-workflows-wait-for-result","title":"Executing Workflows (Wait for Result)","text":"<p>Use <code>ExecuteAsync</code> to execute a workflow and wait for its result. This is useful when you need the workflow's output before continuing.</p>"},{"location":"concepts/workflows/#execute-by-workflow-type","title":"Execute By Workflow Type","text":"C#<pre><code>[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;ProcessingResult&gt; RunAsync(string data)\n    {\n        // Execute child workflow and wait for result\n        var result = await XiansContext.Workflows.ExecuteAsync&lt;ProcessingWorkflow, string&gt;(\n            idPostfix: \"process\",\n            args: new object[] { data }\n        );\n\n        // Use the result\n        Workflow.Logger.LogInformation(\"Processing completed: {Result}\", result);\n\n        return new ProcessingResult { Data = result };\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#execute-by-workflow-type-string","title":"Execute By Workflow Type String","text":"C#<pre><code>[WorkflowRun]\npublic async Task&lt;string&gt; RunAsync(string workflowType, string input)\n{\n    // Execute workflow by type string and wait for result\n    var result = await XiansContext.Workflows.ExecuteAsync&lt;string&gt;(\n        workflowType: \"MyAgent:DataProcessor\",\n        idPostfix: \"processor\",\n        args: new object[] { input }\n    );\n\n    return result;\n}\n</code></pre>"},{"location":"concepts/workflows/#workflow-id-generation","title":"Workflow ID Generation","text":"<p>The <code>idPostfix</code> parameter controls how workflow IDs are generated:</p> <ul> <li>With idPostfix: Workflow ID format is <code>{workflowType}-{idPostfix}</code></li> <li>Without idPostfix (null): A GUID is automatically generated</li> </ul> C#<pre><code>// Predictable ID: \"MyAgent:Task-12345\"\nawait XiansContext.Workflows.StartAsync&lt;TaskWorkflow&gt;(idPostfix: \"12345\");\n\n// Auto-generated ID: \"MyAgent:Task-a1b2c3d4-e5f6-...\"\nawait XiansContext.Workflows.StartAsync&lt;TaskWorkflow&gt;(idPostfix: null);\n</code></pre>"},{"location":"concepts/workflows/#error-handling","title":"Error Handling","text":"C#<pre><code>using Xians.Lib.Agents.Workflows;\n\n[WorkflowRun]\npublic async Task RunAsync(string taskId)\n{\n    try\n    {\n        await XiansContext.Workflows.StartAsync&lt;ProcessWorkflow&gt;(\n            idPostfix: taskId\n        );\n    }\n    catch (WorkflowAlreadyStartedException ex)\n    {\n        // Workflow with this ID is already running\n        Workflow.Logger.LogWarning(\n            \"Workflow already started: {WorkflowId}\", \n            ex.WorkflowId\n        );\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#context-behavior","title":"Context Behavior","text":"<p><code>XiansContext.Workflows</code> works both inside workflows and outside of workflows (e.g., in message handlers):</p> Context Behavior Inside Workflow Starts/executes as a child workflow Outside Workflow Starts/executes as a new workflow using the Temporal client <p>This allows you to use the same API consistently throughout your application.</p>"},{"location":"concepts/workflows/#complete-example","title":"Complete Example","text":"C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents.Core;\n\n[Workflow(\"MyAgent:OrderProcessor\")]\npublic class OrderProcessorWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;OrderResult&gt; ProcessOrderAsync(Order order)\n    {\n        // Start payment processing in the background\n        await XiansContext.Workflows.StartAsync&lt;PaymentWorkflow&gt;(\n            idPostfix: order.Id,\n            args: new object[] { order.PaymentInfo }\n        );\n\n        // Execute inventory check and wait for result\n        var inventoryResult = await XiansContext.Workflows\n            .ExecuteAsync&lt;InventoryCheckWorkflow, bool&gt;(\n                idPostfix: $\"inventory-{order.Id}\",\n                args: new object[] { order.Items }\n            );\n\n        if (!inventoryResult)\n        {\n            return new OrderResult { Success = false, Reason = \"Out of stock\" };\n        }\n\n        // Execute shipping calculation and wait for result\n        var shippingCost = await XiansContext.Workflows\n            .ExecuteAsync&lt;ShippingWorkflow, decimal&gt;(\n                idPostfix: $\"shipping-{order.Id}\",\n                args: new object[] { order.ShippingAddress }\n            );\n\n        return new OrderResult \n        { \n            Success = true, \n            TotalCost = order.Total + shippingCost \n        };\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#communicating-with-workflows","title":"Communicating with Workflows","text":"<p>For signaling, querying, or updating workflows after they've been started, use the standard Temporal .NET SDK. Xians does not provide wrapper methods for these operations to keep your workflows from depending on the Xians platform.</p>"},{"location":"concepts/workflows/#obtaining-the-temporal-client","title":"Obtaining the Temporal Client","text":"<p>The Xians SDK provides easy access to the Temporal client through <code>XiansContext.Workflows</code>:</p> C#<pre><code>using Temporalio.Client;\nusing Xians.Lib.Agents.Core;\n\n// Get the Temporal client from the current agent context\n// All agents share the same Temporal connection\nvar temporalClient = await XiansContext.Workflows.GetClientAsync();\n</code></pre> <p>The client is automatically configured when you initialize the platform with <code>XiansPlatform.InitializeAsync()</code>. Since all agents share the same Temporal connection, <code>GetClientAsync()</code> returns the shared client regardless of which agent is calling it.</p>"},{"location":"concepts/workflows/#signal-example","title":"Signal Example","text":""},{"location":"concepts/workflows/#using-getworkflowhandleasync-recommended","title":"Using GetWorkflowHandleAsync (Recommended)","text":"<p>The simplest way to get a workflow handle is using <code>XiansContext.Workflows.GetWorkflowHandleAsync()</code>, which automatically constructs the workflow ID:</p> C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Get workflow handle using the workflow class and ID postfix\n// This automatically constructs the full workflow ID\nvar workflowHandle = await XiansContext.Workflows.GetWorkflowHandleAsync&lt;MyWorkflow&gt;(\n    idPostfix: \"12345\"\n);\n\n// Send signal\nawait workflowHandle.SignalAsync(\n    wf =&gt; wf.HandleSignalAsync(new SignalData { Message = \"Update\" })\n);\n</code></pre>"},{"location":"concepts/workflows/#using-manual-workflow-id","title":"Using Manual Workflow ID","text":"<p>Alternatively, you can construct the workflow ID manually:</p> C#<pre><code>using Temporalio.Client;\nusing Xians.Lib.Agents.Core;\n\n// Get the Temporal client\nvar temporalClient = await XiansContext.Workflows.GetClientAsync();\n\n// Construct full workflow ID manually: {tenantId}:{agentName}:{workflowName}:{idPostfix}\nvar workflowHandle = temporalClient.GetWorkflowHandle&lt;MyWorkflow&gt;(\n    workflowId: \"tenant123:MyAgent:Task:12345\"\n);\n\n// Send signal\nawait workflowHandle.SignalAsync(\n    wf =&gt; wf.HandleSignalAsync(new SignalData { Message = \"Update\" })\n);\n</code></pre>"},{"location":"concepts/workflows/#query-example","title":"Query Example","text":"C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Get workflow handle (automatically constructs workflow ID)\nvar workflowHandle = await XiansContext.Workflows.GetWorkflowHandleAsync&lt;MyWorkflow&gt;(\n    idPostfix: \"12345\"\n);\n\n// Query workflow state\nvar status = await workflowHandle.QueryAsync(wf =&gt; wf.GetStatus());\n</code></pre>"},{"location":"concepts/workflows/#advanced-access-to-temporal-service","title":"Advanced: Access to Temporal Service","text":"<p>For advanced scenarios like health monitoring or reconnection, you can access the underlying <code>ITemporalClientService</code>:</p> C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Get the Temporal service\nvar temporalService = XiansContext.Workflows.GetService();\n\n// Check connection health\nbool isHealthy = temporalService.IsConnectionHealthy();\n\n// Force reconnection if needed\nif (!isHealthy)\n{\n    await temporalService.ForceReconnectAsync();\n}\n</code></pre> <p>For more information on message passing, see the Temporal .NET SDK documentation.</p>"},{"location":"concepts/workflows/#other-temporal-features","title":"Other Temporal Features","text":"<p>You are free to use all other Temporal SDK features when designing your agents, including:</p> <ul> <li>Timers and Sleep - <code>Workflow.DelayAsync()</code></li> <li>Conditions - <code>Workflow.WaitConditionAsync()</code></li> <li>Activities - <code>Workflow.ExecuteActivityAsync()</code></li> <li>Queries - <code>[WorkflowQuery]</code></li> <li>Signals - <code>[WorkflowSignal]</code></li> <li>Updates - <code>[WorkflowUpdate]</code></li> <li>Continue-As-New - <code>Workflow.ContinueAsNewAsync()</code></li> <li>Local Activities - For fast, local operations</li> <li>Side Effects - For non-deterministic operations</li> </ul> <p>Refer to Temporal Docs</p> <p>The Xians SDK enhances Temporal with multi-tenancy, agent scoping, and built-in workflows, but doesn't restrict your use of Temporal's powerful features.</p>"},{"location":"contribution/learning-path/","title":"Learning &amp; Contribution Path","text":"<p>Welcome to the Xians AI Platform development journey! Follow this structured path to become proficient in building AI agents and contributing to the platform.</p>"},{"location":"contribution/learning-path/#phase-1-explore-and-learn","title":"Phase 1: Explore and Learn","text":""},{"location":"contribution/learning-path/#get-started-with-the-platform","title":"Get Started with the Platform","text":"<ul> <li> 1.1 Login to agentri.ai (hosted version of Xians.AI platform)</li> <li> 1.2 Join the existing tenant 99x and request admin approval</li> <li> 1.4 Review the complete documentation to understand how Xians.AI helps developers build AI Agent systems</li> </ul>"},{"location":"contribution/learning-path/#make-your-first-contribution","title":"Make Your First Contribution","text":"<ul> <li> 1.5 Send a PR to the documentation repository to improve documentation</li> </ul>"},{"location":"contribution/learning-path/#phase-2-setting-up-development-environment","title":"Phase 2: Setting Up Development Environment","text":"<ul> <li> 2.1 Set up Xians Community Edition locally on your machine</li> <li> 2.2 Verify your local setup is working correctly</li> </ul>"},{"location":"contribution/learning-path/#phase-3-agent-development","title":"Phase 3: Agent Development","text":"<p>Build a few first agents and learn core concepts:</p> <p>For example,</p> <ul> <li>Agent with tools, MCPs</li> <li>Agent with Custom Workflows (Scheduling, A2A Communication)</li> <li>Etc.</li> </ul>"},{"location":"contribution/learning-path/#phase-4-platform-development","title":"Phase 4: Platform Development","text":"<p>Contribute to the core platform:</p>"},{"location":"contribution/learning-path/#setup-core-repositories","title":"Setup Core Repositories","text":"<ul> <li> 5.1 Clone and set up the following repositories locally:</li> <li>XiansAi.Server</li> <li>XiansAi.UI</li> <li>XiansAi.Lib</li> <li> 5.2 Configure your existing agent development projects to use the local Lib and Server</li> </ul>"},{"location":"contribution/learning-path/#contribute-to-platform","title":"Contribute to Platform","text":"<ul> <li> 5.3 Make improvements to the platform repositories (e.g., unit tests, UI enhancements)</li> <li> 5.4 Test your changes thoroughly</li> <li> 5.5 Submit a Pull Request with your improvements</li> </ul>"},{"location":"contribution/learning-path/#join-platform-development","title":"Join Platform Development","text":"<ul> <li> 5.6 Review tasks in the XiansAI Platform project board. Pick up a task and contribute to platform development</li> </ul>"},{"location":"contribution/learning-path/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, you'll be ready to:</p> <ul> <li>Build production-ready AI agents</li> <li>Contribute to the Xians AI Platform</li> <li>Help others in their learning journey</li> <li>Design and implement complex multi-agent systems</li> </ul> <p>Happy coding! \ud83d\ude80</p>"},{"location":"contribution/platform-development/","title":"Developer Guide - Agentic AI","text":"<p>This guide provides step-by-step instructions to set up and run the Agentic AI platform. Follow the steps below to clone the repositories, configure the server, and set up the UI.</p>"},{"location":"contribution/platform-development/#1-clone-the-repositories","title":"1. Clone the Repositories","text":"<p>To begin, clone the following three repositories from GitHub:</p> <ol> <li> <p>XiansAI.Server    Repository URL: https://github.com/XiansAiPlatform/XiansAi.Server.git    Command to clone:    Bash<pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.Server.git\n</code></pre></p> </li> <li> <p>XiansAI.Lib    Repository URL: https://github.com/XiansAiPlatform/XiansAi.Lib.git    Command to clone:    Bash<pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.Lib.git\n</code></pre></p> </li> <li> <p>XiansAI.UI    Repository URL: https://github.com/XiansAiPlatform/XiansAi.UI.git    Command to clone:    Bash<pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.UI.git\n</code></pre></p> </li> </ol>"},{"location":"contribution/platform-development/#2-setting-up-the-server","title":"2. Setting Up the Server","text":"<p>To configure and run the server, follow these steps:</p> <ol> <li> <p>Obtain Configuration Files</p> <p>Request the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files from a team member. These files contain the necessary configuration settings for the server.</p> </li> <li> <p>Place Configuration Files</p> <p>Copy the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files into the <code>src</code> folder of the <code>XiansAI.Server</code> repository.</p> <p>Example path: Text Only<pre><code>XiansAI.Server/src/\n</code></pre></p> </li> <li> <p>Run the Server</p> <p>Follow the specific instructions provided in the <code>XiansAI.Server</code> repository's README file to build and run the server.</p> </li> </ol>"},{"location":"contribution/platform-development/#3-setting-up-the-ui","title":"3. Setting Up the UI","text":"<p>To configure and run the UI, follow these steps:</p> <ol> <li> <p>Create a <code>.env</code> File </p> <ul> <li>Navigate to the root directory of the <code>XiansAI.UI</code> repository.  </li> <li>Create a new file named <code>.env</code>.</li> </ul> </li> <li> <p>Copy Environment Variables </p> <ul> <li>Open the <code>XiansAI.UI</code> repository and locate the <code>.env.development</code> file.  </li> <li>Copy the contents of the <code>.env.development</code> file into the newly created <code>.env</code> file.</li> </ul> </li> <li> <p>Install Dependencies </p> <ul> <li>Run the following command to install all required dependencies:   Bash<pre><code>npm install\n</code></pre></li> </ul> </li> <li> <p>Start the UI </p> <ul> <li> <p>Start the development server by running:   Bash<pre><code>npm start\n</code></pre></p> </li> <li> <p>The UI should now be accessible in your browser. The default URL is typically <code>http://localhost:3000</code>, but refer to the project documentation for confirmation.</p> </li> </ul> </li> </ol>"},{"location":"contribution/platform-development/#4-setting-up-the-library-xiansailib","title":"4. Setting Up the Library (XiansAI.Lib)","text":"<p>To configure and use the <code>XiansAI.Lib</code> library, follow these steps:</p> <ol> <li> <p>Run the Library </p> <ul> <li>After cloning the <code>XiansAI.Lib</code> repository, navigate to its root directory and run the following command to build and execute the library in release mode:   Bash<pre><code>dotnet run -c Release\n</code></pre></li> </ul> </li> <li> <p>Making Changes to the Library </p> <ul> <li>If you make any changes to the <code>XiansAI.Lib</code> codebase, you need to update its reference in the agent's package dependency list:</li> <li>Locate the <code>.csproj</code> file of the <code>XiansAI.Lib</code> project.</li> <li>Copy the file path of the <code>.csproj</code> file.</li> <li>Update the agent's package dependency list to reference the updated <code>.csproj</code> file location.</li> </ul> <p>Example of referencing the <code>.csproj</code> file in another project:   XML<pre><code>&lt;ProjectReference Include=\"path/to/XiansAI.Lib.csproj\" /&gt;\n</code></pre></p> </li> <li> <p>Rebuild the Dependent Project </p> <ul> <li>After updating the reference, rebuild the dependent project to ensure the changes in the library are applied.</li> </ul> </li> </ol>"},{"location":"contribution/platform-development/#notes","title":"Notes","text":"<ul> <li>Ensure you have the required versions of .NET SDK installed on your system before setting up the library. Refer to the <code>XiansAI.Lib</code> repository's README for version requirements.</li> <li>For the server and library, ensure you have the necessary runtime environment (e.g., .NET Core) installed. Check the respective repositories for specific prerequisites.</li> <li>If you encounter any issues during setup, consult the respective repository's documentation or reach out to your team for assistance.</li> </ul> <p>By following these steps, you should be able to successfully set up and run the Agentic AI platform.</p>"},{"location":"getting-started/chat-history/","title":"Chat History","text":""},{"location":"getting-started/chat-history/#the-problem-with-memory-loss","title":"The Problem with Memory Loss","text":"<p>Remember the MAF agent we built in the previous step? It has a significant limitation: no chat history. Every message is treated as an isolated conversation, as if the agent has amnesia between each interaction. This isn't how useful agents work in the real world!</p> <p>Imagine asking an agent \"What's the weather like?\" followed by \"How about tomorrow?\" - without context, the agent wouldn't know you're still talking about weather. Frustrating, right?</p>"},{"location":"getting-started/chat-history/#how-xians-manages-conversation-memory","title":"How Xians Manages Conversation Memory","text":"<p>The good news? Xians automatically stores all messages with proper isolation across:</p> <ul> <li>Tenants - keeping different organizations separate</li> <li>Agent-User pairs - each user gets their own conversation history</li> <li>Topics/Scopes - conversations can be organized by subject</li> </ul> <p>Secure &amp; Compliant Storage</p> <p>Xians stores all messages encrypted at rest, helping you build AI agents that are compliant with the EU AI Act and other data protection regulations. Your users' conversations are protected by default.</p> <p>The platform provides convenient methods to access this chat history for the current context, making your agents context-aware.</p>"},{"location":"getting-started/chat-history/#implementing-the-message-store","title":"Implementing the Message Store","text":"<p>To enable chat history in MAF (Microsoft Agent Framework), we need to implement a message store class. This bridges Xians' message storage with MAF's expectations.</p>"},{"location":"getting-started/chat-history/#step-1-create-the-xianschatmessagestore","title":"Step 1: Create the XiansChatMessageStore","text":"<p>Create a new class that implements MAF's <code>ChatMessageStore</code> interface:</p> C#<pre><code>using System.Text.Json;\nusing Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing Xians.Lib.Agents.Messaging;\n\nnamespace Xians.SimpleAgent.Utils;\n\ninternal sealed class XiansChatMessageStore : ChatMessageStore\n{\n    private readonly UserMessageContext _context;\n\n    public XiansChatMessageStore(UserMessageContext context)\n    {\n        _context = context;\n    }\n\n    public override async Task&lt;IEnumerable&lt;ChatMessage&gt;&gt; GetMessagesAsync(\n        CancellationToken cancellationToken)\n    {\n        // Get chat history from Xians\n        var xiansMessages = await _context.Messages.GetHistoryAsync(page: 1, pageSize: 10);\n\n        // Convert to ChatMessage format\n        var chatMessages = xiansMessages\n            .Where(msg =&gt; !string.IsNullOrEmpty(msg.Text))\n            .Select(msg =&gt; new ChatMessage(\n                msg.Direction.ToLowerInvariant() == \"outgoing\" ? ChatRole.Assistant : ChatRole.User,\n                msg.Text!))\n            .Reverse() // Xians returns newest first, we need oldest first\n            .ToList();\n\n        return chatMessages;\n    }\n\n    public override Task AddMessagesAsync(\n        IEnumerable&lt;ChatMessage&gt; messages,\n        CancellationToken cancellationToken)\n    {\n        // No-op: Xians automatically stores messages\n        return Task.CompletedTask;\n    }\n\n    public override JsonElement Serialize(JsonSerializerOptions? jsonSerializerOptions = null)\n    {\n        // Serialize the thread ID for state persistence\n        return JsonSerializer.SerializeToElement(_context.ThreadId);\n    }\n}\n</code></pre>"},{"location":"getting-started/chat-history/#understanding-the-key-methods","title":"Understanding the Key Methods","text":"<p>GetMessagesAsync: This retrieves the conversation history from Xians using <code>_context.GetChatHistoryAsync()</code>. The method:</p> <ul> <li>Fetches the most recent 10 messages (you can adjust <code>pageSize</code> as needed)</li> <li>Filters out empty messages</li> <li>Converts Xians message format to MAF's <code>ChatMessage</code> format</li> <li>Reverses the order (Xians returns newest first, but MAF expects oldest first)</li> </ul> <p>Scoped Conversations</p> <p>If the current conversation has a scope (topic), you'll only get messages from that scope. Messages without a scope use the default scope (<code>null</code>).</p> <p>AddMessagesAsync: This is a no-op because Xians automatically stores all messages for you - no manual saving required!</p> <p>Serialize: Persists the thread ID for state management across agent sessions.</p>"},{"location":"getting-started/chat-history/#step-2-update-your-maf-agent","title":"Step 2: Update Your MAF Agent","text":"<p>Now let's wire up the message store to your MAF agent. Notice we're now passing the entire <code>UserMessageContext</code> instead of just the message text:</p> C#<pre><code>public class MafSubAgent\n{\n    private readonly ChatClient _chatClient;\n\n    public MafSubAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        _chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n    }\n\n    public async Task&lt;string&gt; RunAsync(UserMessageContext context)\n    {\n        var agent = _chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = \"You are a helpful assistant.\"\n            },\n            ChatMessageStoreFactory = ctx =&gt; new XiansChatMessageStore(context)\n        });\n\n        var response = await agent.RunAsync(context.Message.Text);\n        return response.Text;\n    }\n}\n</code></pre> <p>The key change is in <code>ChatMessageStoreFactory</code> - we're now providing our custom <code>XiansChatMessageStore</code> that knows how to retrieve conversation history from Xians.</p>"},{"location":"getting-started/chat-history/#step-3-update-your-message-handler","title":"Step 3: Update Your Message Handler","text":"<p>Finally, update your <code>Program.cs</code> to pass the full context object to the agent:</p> C#<pre><code>// Handle incoming user messages\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var response = await mafAgent.RunAsync(context);\n    await context.ReplyAsync(response);\n});\n</code></pre>"},{"location":"getting-started/chat-history/#whats-next","title":"What's Next?","text":"<p>Congratulations! Your agent now has memory and can maintain context across conversations. Try asking follow-up questions and watch your agent understand the conversation flow.</p> <p>In the next section, we'll explore more advanced features like tool integration and multi-agent workflows.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get started with Xians.ai by choosing the installation path that best fits your needs.</p>"},{"location":"getting-started/installation/#choose-your-path","title":"Choose Your Path","text":"<p>Xians.ai offers two deployment options:</p> <ol> <li>SaaS Platform - Quick start with hosted infrastructure (Recommended for 99x employees and customers)</li> <li>Community Edition - Self-hosted deployment for development and testing</li> </ol>"},{"location":"getting-started/installation/#option-1-saas-platform","title":"Option 1: SaaS Platform","text":"<p>If you already have an account, the fastest way to get started is using our hosted SaaS platform at agentri.ai.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Active account at agentri.ai</li> <li>API key for authentication</li> </ul>"},{"location":"getting-started/installation/#getting-started","title":"Getting Started","text":"<ol> <li>Sign in at agentri.ai</li> <li>Obtain your API key from the tenant settings page</li> <li>Start building - You're ready to create your first agent! Follow Quick Start.</li> </ol>"},{"location":"getting-started/installation/#option-2-community-edition-self-hosted","title":"Option 2: Community Edition (Self-Hosted)","text":"<p>For local development, testing, or self-hosted deployments, use the Community Edition.</p>"},{"location":"getting-started/installation/#prerequisites_1","title":"Prerequisites","text":"<p>Before setting up the Community Edition, ensure you have:</p> <ul> <li>Operating System: Windows, macOS, or Linux</li> <li>Docker &amp; Docker Compose: Latest versions installed</li> <li>System Resources: Minimum 8GB RAM recommended</li> <li>OpenAI API Key: Required for LLM capabilities (optional)</li> </ul>"},{"location":"getting-started/installation/#quick-setup-with-docker-compose","title":"Quick Setup with Docker Compose","text":"<p>The Community Edition provides a one-command setup that includes all essential components:</p> <ul> <li>Xians Server - Core platform API and orchestration</li> <li>Xians UI - Web-based management interface</li> <li>Temporal - Workflow orchestration engine</li> <li>Keycloak - Authentication and authorization</li> <li>Database Components - Data persistence layer</li> </ul>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":"<p>For detailed setup instructions, configuration options, and troubleshooting, visit:</p> <p>\ud83d\udcda XiansAi Platform - Community Edition</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once your platform is running locally, proceed to the Quick Start guide to create your first agent.</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues:</p> <ul> <li>Community Edition: See the Git Repo</li> <li>Issues: Open an issue on GitHub</li> </ul>"},{"location":"getting-started/overview/","title":"Getting Started","text":"<p>Get up and running with Xians.ai in minutes. This section guides you through installation, creating your first agent, and enhancing it with essential features.</p> Page Description Installation Choose between SaaS platform or Community Edition self-hosted deployment Quick Start Create your first conversational agent using MAF and connect it to Xians platform Chat History Add conversation memory to your agent so it maintains context across interactions Tool Execution Integrate tools with your agent to access documents, knowledge, and workflows"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with your first Xians agent in minutes. This guide walks you through creating a simple conversational agent and connecting it to the Xians platform.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>.NET 9 SDK - Download here</li> <li>OpenAI API Key - Get one from OpenAI Platform</li> </ul>"},{"location":"getting-started/quick-start/#step-1-create-your-project","title":"Step 1: Create Your Project","text":"<p>Xians agents run as standard .NET applications that can be executed locally or deployed to any server environment. Start by creating a new console project:</p> Bash<pre><code>dotnet new console -n MyAgent\ncd MyAgent\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-build-a-simple-agent-with-maf","title":"Step 2: Build a Simple Agent with MAF","text":"<p>You can use any framework that supports .NET Core to create your agent. In this guide, we'll use the Microsoft Agent Framework (MAF).</p>"},{"location":"getting-started/quick-start/#install-required-packages","title":"Install Required Packages","text":"Bash<pre><code>dotnet add package Azure.AI.OpenAI --prerelease\ndotnet add package Azure.Identity\ndotnet add package Microsoft.Agents.AI.OpenAI --prerelease\n</code></pre>"},{"location":"getting-started/quick-start/#create-the-maf-agent-class","title":"Create the MAF Agent Class","text":"<p>Create a new file called <code>MafSubAgent.cs</code>:</p> <p>Note: We call this class <code>MafSubAgent</code>, not <code>MafAgent</code>, because production-grade agentic applications typically comprise multiple sub-agents. When you create an agent with Xians, it can have multiple workflows attached to different sub-agents. You'll see this pattern in the following examples.</p> Bash<pre><code>touch MafSubAgent.cs\n</code></pre> <p>Add the following code to <code>MafSubAgent.cs</code>:</p> C#<pre><code>using Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing OpenAI;\nusing OpenAI.Chat;\n\npublic class MafSubAgent\n{\n    private readonly ChatClient _chatClient;\n\n    public MafSubAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        _chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n    }\n\n    public async Task&lt;string&gt; RunAsync(string message)\n    {\n        var agent = _chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = \"You are a helpful assistant.\"\n            }\n        });\n\n        var response = await agent.RunAsync(message);\n        return response.Text;\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#update-programcs","title":"Update Program.cs","text":"<p>Replace the contents of <code>Program.cs</code> with:</p> C#<pre><code>// Get OpenAI API key (replace with your actual key or use environment variable)\nvar apiKey = Environment.GetEnvironmentVariable(\"OPENAI_API_KEY\") ?? \"your-openai-api-key\";\n\n// Create the agent\nvar agent = new MafSubAgent(apiKey);\n\n// Process a user message\nvar response = await agent.RunAsync(\"Hello! Can you write a one sentence story about a cat?\");\nConsole.WriteLine($\"Agent: {response}\");\n</code></pre> <p>Tip: You can set the <code>OPENAI_API_KEY</code> environment variable instead of hardcoding it. This is good practice even for simple tests.</p>"},{"location":"getting-started/quick-start/#test-your-agent","title":"Test Your Agent","text":"<p>Build and run your agent to verify it works:</p> Bash<pre><code>dotnet build\ndotnet run\n</code></pre> <p>You should see a creative response from your agent!</p> <p>Note: At this point, we've built a simple agent using MAF without any Xians SDK constructs. This demonstrates the core principle of Xians: work with your existing agent frameworks. Next, we'll enhance this agent with the power of the Xians platform.</p>"},{"location":"getting-started/quick-start/#step-3-connect-your-agent-to-xians","title":"Step 3: Connect Your Agent to Xians","text":"<p>While a standalone agent is great for demos, production systems require multi-tenancy, user management, conversation threading, and more. Building this infrastructure from scratch is time-consuming, but Xians provides all of this out of the box.</p>"},{"location":"getting-started/quick-start/#install-the-xians-sdk","title":"Install the Xians SDK","text":"Bash<pre><code>dotnet add package Xians.Lib\n</code></pre> <p>Note: Xians.Lib version 3+ is published under <code>Xians.Lib</code>, not <code>XiansAi.Lib</code> like previous versions.</p>"},{"location":"getting-started/quick-start/#get-your-xians-api-key","title":"Get Your Xians API Key","text":"<p>Before proceeding, you need to:</p> <ol> <li>Set up your Xians platform instance</li> <li>Navigate to Tenant Settings in the platform UI</li> <li>Copy your Agent Certificate and Server URL</li> </ol> <p></p>"},{"location":"getting-started/quick-start/#configuration-options","title":"Configuration Options","text":"<p>You can configure your agent's credentials in two ways:</p>"},{"location":"getting-started/quick-start/#option-1-direct-configuration-quick-testing","title":"Option 1: Direct Configuration (Quick Testing)","text":"<p>For quick testing and demos, you can hardcode the values directly in your code.</p>"},{"location":"getting-started/quick-start/#option-2-using-env-file-recommended","title":"Option 2: Using .env File (Recommended)","text":"<p>For better security and maintainability, use a <code>.env</code> file to manage your configuration. This prevents accidentally committing sensitive API keys to version control.</p> <p>Install the DotNetEnv package:</p> Bash<pre><code>dotnet add package DotNetEnv\n</code></pre> <p>Create a <code>.env</code> file in the root of your project:</p> Bash<pre><code># OpenAI Configuration\nOPENAI_API_KEY=your-openai-api-key\n\n# Xians Platform Configuration\nXIANS_SERVER_URL=https://your-xians-server.com\nXIANS_API_KEY=your-xians-certificate\n</code></pre> <p>Add <code>.env</code> to your <code>.gitignore</code> to prevent committing secrets:</p> Bash<pre><code>echo \".env\" &gt;&gt; .gitignore\n</code></pre> <p>Security Tip: Never commit your <code>.env</code> file to version control. Always add it to <code>.gitignore</code> to protect your API keys.</p>"},{"location":"getting-started/quick-start/#configure-and-connect-to-xians","title":"Configure and Connect to Xians","text":"<p>Replace the entire contents of <code>Program.cs</code> with the following:</p> <p>Using .env file (Recommended):</p> C#<pre><code>using DotNetEnv;\nusing Xians.Lib.Agents.Core;\n\n// Load environment variables from .env file\nEnv.Load();\n\n// Get configuration from environment variables\nvar openAiApiKey = Environment.GetEnvironmentVariable(\"OPENAI_API_KEY\") \n    ?? throw new InvalidOperationException(\"OPENAI_API_KEY not found in environment variables\");\nvar serverUrl = Environment.GetEnvironmentVariable(\"XIANS_SERVER_URL\") \n    ?? throw new InvalidOperationException(\"XIANS_SERVER_URL not found in environment variables\");\nvar xiansApiKey = Environment.GetEnvironmentVariable(\"XIANS_API_KEY\") \n    ?? throw new InvalidOperationException(\"XIANS_API_KEY not found in environment variables\");\n\n// Initialize Xians Platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new ()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey\n});\n\n// Register a new agent with Xians\nvar xiansAgent = xiansPlatform.Agents.Register(new ()\n{\n    Name = \"My Conversational Agent\",\n    SystemScoped = true  // See important notes below\n});\n\n// Define a built-in conversational workflow\nvar conversationalWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Conversational\");\n\n// Create your MAF agent instance\nvar mafSubAgent = new MafSubAgent(openAiApiKey);\n\n// Handle incoming user messages\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var response = await mafSubAgent.RunAsync(context.Message.Text);\n    await context.ReplyAsync(response);\n});\n\n// Start the agent and all workflows\nawait xiansAgent.RunAllAsync();\n</code></pre> <p>Or using direct configuration (for quick testing):</p> C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Configuration - replace with your actual values (not recommended for production)\nvar openAiApiKey = \"your-openai-api-key\";\nvar serverUrl = \"https://your-xians-server.com\";\nvar xiansApiKey = \"your-agent-certificate\";\n\n// Initialize Xians Platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new ()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey\n});\n\n// Register a new agent with Xians\nvar xiansAgent = xiansPlatform.Agents.Register(new ()\n{\n    Name = \"My Conversational Agent\",\n    SystemScoped = true  // See important notes below\n});\n\n// Define a built-in conversational workflow\nvar conversationalWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Conversational\");\n\n// Create your MAF agent instance\nvar mafSubAgent = new MafSubAgent(openAiApiKey);\n\n// Handle incoming user messages\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var response = await mafSubAgent.RunAsync(context.Message.Text);\n    await context.ReplyAsync(response);\n});\n\n// Start the agent and all workflows\nawait xiansAgent.RunAllAsync();\n</code></pre>"},{"location":"getting-started/quick-start/#important-configuration-notes","title":"Important Configuration Notes","text":"<p>SystemScoped Setting:</p> <ul> <li> <p><code>SystemScoped = true</code>: Adds the agent to the global Agent Templates library, making it available for any tenant admin to deploy. This option is only available if you're a system administrator.</p> </li> <li> <p><code>SystemScoped = false</code> (default): Immediately deploys the agent to your current tenant. Use this if you only have tenant-level permissions.</p> </li> </ul> <p>Understanding Workflows:</p> <ul> <li>A Xians agent is a definition that represents your agent in the platform</li> <li>The actual AI logic runs in your MAF agent (or any other framework you choose)</li> <li>Built-in workflows connect Xians' conversation handling capabilities to your agent logic</li> <li>One Xians agent can contain multiple built-in workflows, each connected to different AI agent implementations</li> </ul>"},{"location":"getting-started/quick-start/#step-4-deploy-your-agent","title":"Step 4: Deploy Your Agent","text":""},{"location":"getting-started/quick-start/#for-system-scoped-agents","title":"For System-Scoped Agents","text":"<p>If you registered your agent with <code>SystemScoped = true</code>, you'll find it in the Agent Templates section:</p> <p></p> <p>Tenant administrators can then deploy instances of this template to their tenants.</p>"},{"location":"getting-started/quick-start/#for-tenant-scoped-agents","title":"For Tenant-Scoped Agents","text":"<p>If you used <code>SystemScoped = false</code>, or after deploying a system template, your agent appears under Deployed Agents:</p> <p></p> <p>What You've Achieved: Xians has transformed your simple MAF agent into a multi-tenant, enterprise-ready solution. You can now manage agent lifecycles across different tenant scopes through the platform UI.</p>"},{"location":"getting-started/quick-start/#step-5-start-a-conversation","title":"Step 5: Start a Conversation","text":"<p>Now for the exciting part - talking to your agent!</p> <ol> <li>Navigate to Conversations in the platform UI</li> <li>Select your deployed agent from the list</li> <li>Click the + button to create a new conversation</li> <li>Start chatting with your agent!</li> </ol> <p></p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've successfully created and deployed your first Xians agent. Here's what you can explore next:</p> <ul> <li>Add Tools &amp; Functions - Extend your agent with custom capabilities</li> <li>Implement Chat History - Connect chat history for context-aware responses</li> </ul> <p>Ready to dive deeper? Check out our Core Concepts or explore Advanced Workflows.</p>"},{"location":"getting-started/tool-execution/","title":"Agents with Tools","text":"<p>Xians provides flexible tool integration that works seamlessly with your preferred agent framework. This guide shows you how to create and use tools within the Xians platform.</p>"},{"location":"getting-started/tool-execution/#overview","title":"Overview","text":"<p>Xians does not dictate or enforce a specific format for attaching tools to your agents. Instead, you can develop tools according to the recommendations of your chosen agent framework (such as Semantic Kernel, LangChain, or AutoGen).</p> <p>Within your tools, you can access Xians APIs for:</p> <ul> <li>Document DB access - Store and retrieve structured data</li> <li>Knowledge file access - Query knowledge bases and files</li> <li>Workflow orchestration - Start sub-workflows and manage execution</li> <li>Message handling - Send replies and manage conversations</li> <li>etc.</li> </ul>"},{"location":"getting-started/tool-execution/#accessing-xians-functionality","title":"Accessing Xians Functionality","text":""},{"location":"getting-started/tool-execution/#usermessagecontext","title":"UserMessageContext","text":"<p>For user message-related functionality, use the <code>UserMessageContext</code> class. This context object exposes SDKs for all operations related to the current user message.</p>"},{"location":"getting-started/tool-execution/#xianscontext","title":"XiansContext","text":"<p>For agent and workflow-level functionality, use the <code>XiansContext</code> static class:</p> <ul> <li><code>XiansContext.CurrentAgent.*</code> - Access agent-level SDKs and configuration</li> <li><code>XiansContext.CurrentWorkflow.*</code> - Access workflow-level SDKs and state</li> </ul>"},{"location":"getting-started/tool-execution/#example-creating-tool-classes","title":"Example: Creating Tool Classes","text":"<p>Here's a complete example showing how to create a tool class that integrates with Xians:</p> C#<pre><code>using System.ComponentModel;\nusing Xians.Lib.Agents.Messaging;\nusing Xians.Lib.Agents.Core;\n\npublic class MafSubAgentTools\n{\n    private readonly UserMessageContext _context;\n\n    public MafSubAgentTools(UserMessageContext context)\n    {\n        _context = context;\n    }\n\n    [Description(\"Get the current date and time.\")]\n    public async Task&lt;string&gt; GetCurrentDateTime()\n    {\n        // User message related functionality\n        await _context.Messages.ReplyAsync($\"The current date and time is: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\");\n        var now = DateTime.Now;\n        return $\"The current date and time is: {now:yyyy-MM-dd HH:mm:ss}\";\n    }\n\n    [Description(\"Get the target market description.\")]\n    public async Task&lt;string&gt; GetTargetMarketDescription()\n    {\n        // Agent related functionality\n        var targetMarketDescription = await XiansContext.CurrentAgent.Knowledge.GetAsync(\"Market Description\");\n        return targetMarketDescription?.Content ?? \"I couldn't find the target market description.\";\n    }\n}\n</code></pre>"},{"location":"getting-started/tool-execution/#associating-tools-with-your-agent","title":"Associating Tools with Your Agent","text":"<p>Once you've created your tool class, you need to associate it with your agent. The following example demonstrates how to integrate the <code>MafSubAgentTools</code> class with an agent using Microsoft's AI Extensions framework:</p> C#<pre><code>public class MafSubAgent\n{\n    private readonly ChatClient _chatClient;\n\n    public MafSubAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        _chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n    }\n\n    public async Task&lt;string&gt; RunAsync(UserMessageContext context)\n    {\n        if (string.IsNullOrWhiteSpace(context.Message.Text))\n        {\n            return \"I didn't receive any message. Please send a message.\";\n        }\n\n        // Create tools instance with the UserMessageContext\n        var tools = new MafSubAgentTools(context);\n\n        // Configure the AI agent with tools\n        var agent = _chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = \"You are a helpful assistant.\",\n                Tools =\n                [\n                    AIFunctionFactory.Create(tools.GetCurrentDateTime),\n                    AIFunctionFactory.Create(tools.GetTargetMarketDescription)\n                ]\n            },\n            // Use Xians chat message store for conversation history\n            ChatMessageStoreFactory = ctx =&gt; new XiansChatMessageStore(context)\n        });\n\n        // Run the agent and return the response\n        var response = await agent.RunAsync(context.Message.Text);\n        return response.Text;\n    }\n}\n</code></pre>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":""},{"location":"introduction/features/","title":"Features","text":"<p>Xians is a control plane for AI agents. It sits alongside your agent framework - not replacing it. It handles everything that becomes painful once agents graduate from demos to production.</p> <p>When you register an agent (say, one built with Azure AI Projects) with Xians and it gets following capabilities:</p> <ul> <li>Agent Registry - Framework-agnostic registration and identity management</li> <li>Multi-tenancy - Complete isolation across customers</li> <li>Agent-User Collaboration - Rich messaging and conversations</li> <li>Agent-Agent Collaboration - Coordinated multi-agent systems</li> <li>Human-in-the-Loop - Workflow pauses for human review</li> <li>Long-Running Workflows - Processes that span days or months</li> <li>Scheduling - Time-based agent activation</li> <li>Webhooks - Event-driven triggers and integrations</li> <li>Document DB - Flexible storage for structured data</li> <li>Prompt Management - Centralized prompt versioning and optimization</li> <li>Sub-Workflows - Composable, reusable workflow components</li> <li>Observability - Complete visibility into agent operations</li> </ul> <p>No changes to your agent's code. Because Xians is framework-agnostic, you can mix agents built on different stacks in the same system.</p>"},{"location":"introduction/features/#agent-registry","title":"Agent Registry","text":"<p>Your agents, regardless of framework, register with Xians to get identity, authentication, and operational infrastructure.</p> <p>Build with any framework - Microsoft Agent Framework, LangChain, Semantic Kernel, or raw OpenAI SDK - and register it with Xians. Each agent gets a unique identity, authentication credentials, and seamless integration with the platform's workflows, messaging, and scheduling infrastructure.</p> <p>Key capabilities:</p> <ul> <li>Framework-agnostic: Bring your own agent implementation</li> <li>Unique identity: Each agent gets a distinct ID and permission management</li> <li>Deployment models: Publish agents as templates and rollout to tenants</li> <li>Lifecycle management: Publish, deploy, version control, delete agents</li> </ul>"},{"location":"introduction/features/#multi-tenancy","title":"Multi-Tenancy","text":"<p>Complete isolation of agents, workflows, data, and conversations - while sharing infrastructure. Two flavors:</p> Deployment Model What It Means When to Use System-Scoped One runtime serves all tenants Common agents that will be rolled out to tenants Tenant-Scoped Dedicated runtime per tenant Custom logic, sensitive data, specific agents <p>Key capabilities:</p> <ul> <li>Data isolation: Each tenant's workflows and data is completely separated</li> <li>Resource boundaries: Possible to implement per-tenant quotas and rate limits</li> <li>Custom configurations: Same agent using different prompts or configurations per tenant</li> </ul> <p>Deploy system agents for the common, create tenant-scoped agents for the advanced deployment models.</p>"},{"location":"introduction/features/#agent-user-collaboration","title":"Agent-User Collaboration","text":"<p>Async message passing from users to agents with persistent conversation history and context management.</p> <p>Messages aren't just text - they're the conversational memory that makes agents intelligent and contextual. Each message thread maintains state across sessions, enabling multi-turn dialogues where agents remember context, preferences, and history.</p> <p>Xians provides a sophisticated message hierarchy with complete isolation at every level, allowing agents and users to scope conversations for their specific work:</p> <pre><code>graph TD\n    T[Tenant] --&gt;|has many| A[Agents]\n    A --&gt;|has many| W[Workflows]\n    W --&gt;|has many| TH[Conversation Threads]\n    TH --&gt;|has many| S[Topics/Scopes]\n    S --&gt;|has many| M[Messages]\n\n    style T fill:#eea52d,stroke:#333,stroke-width:2px,color:#1b1f2f\n    style A fill:#538cfc,stroke:#333,stroke-width:2px,color:#fff\n    style W fill:#41c18a,stroke:#333,stroke-width:2px,color:#fff\n    style TH fill:#9b59b6,stroke:#333,stroke-width:2px,color:#fff\n    style S fill:#e74c3c,stroke:#333,stroke-width:2px,color:#fff\n    style M fill:#95a5a6,stroke:#333,stroke-width:2px,color:#fff</code></pre> <p>This hierarchy enables powerful conversation organization: a single tenant can have multiple agents, each with different workflows handling various interactions. Within each workflow, users can maintain separate conversation threads, and even within a thread, organize messages by topic for cleaner context management</p> <p>Key capabilities:</p> <ul> <li>Conversation hierachy: Automatic context preservation across sessions</li> <li>Multiple transports: WebSocket, Server-Sent Events (SSE), REST APIs</li> <li>Rich messages: Text, structured data, and HITL Tasks</li> <li>Security: Message encryption, EU AI Act compliant</li> <li>Authentication: API keys or OIDC/OAuth 2.0 integration</li> </ul> <p>Users can interact with agents across different conversation threads, with full history and context automatically managed.</p>"},{"location":"introduction/features/#agent-agent-collaboration","title":"Agent-Agent Collaboration","text":"<p>Orchestrate multiple agents working together to solve complex problems through message passing and workflow coordination.</p> <p>Complex agentic systems often require multiple specialized agents collaborating as a team - one agent conversing with users, another analyzing data, one searching and reading the web, another making decisions. Xians enables sophisticated multi-agent architectures through two key mechanisms:</p> <p>Multi-Workflow Agents: A single agent can contain multiple specialized workflows, each handling a specific responsibility (conversation, research, analysis, decision-making). These workflows operate as a coordinated team behind a unified agent interface.</p> <p>Agent-to-Agent Protocol (A2A): Agents communicate with each other using Xians' A2A protocol SDK, which provides in-process communication for speed and resource optimization. Messages are routed, context is shared, and results are aggregated automatically.</p> <pre><code>graph TB\n    U[User] --&gt;|Message| A1[Customer Support Agent]\n\n    subgraph A1_Team[Customer Support Agent - Multi-Workflow]\n        A1W1[Conversation Workflow]\n        A1W2[Analysis Workflow]\n        A1W3[Action Workflow]\n    end\n\n    A1 --&gt; A1W1\n    A1W1 --&gt;|A2A Protocol| A1W2\n    A1W2 --&gt;|A2A Protocol| A1W3\n\n    A1W3 --&gt;|A2A Protocol| A2[Knowledge Agent]\n    A1W3 --&gt;|A2A Protocol| A3[Data Agent]\n\n    subgraph A2_Team[Knowledge Agent - Multi-Workflow]\n        A2W1[Search Workflow]\n        A2W2[RAG Workflow]\n    end\n\n    A2 --&gt; A2W1\n    A2W1 --&gt; A2W2\n    A2W2 --&gt;|Results| A1W3\n    A3 --&gt;|Results| A1W3\n\n    A1W3 --&gt; A1W1\n    A1W1 --&gt;|Response| U\n\n    style A1 fill:#538cfc,stroke:#333,stroke-width:3px,color:#fff\n    style A2 fill:#41c18a,stroke:#333,stroke-width:3px,color:#fff\n    style A3 fill:#e74c3c,stroke:#333,stroke-width:3px,color:#fff\n    style A1W1 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A1W2 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A1W3 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A2W1 fill:#6dd5a5,stroke:#333,stroke-width:1px,color:#000\n    style A2W2 fill:#6dd5a5,stroke:#333,stroke-width:1px,color:#000</code></pre> <p>This architecture enables building sophisticated agent teams where each agent specializes in a domain (customer support, data analysis, web research) and each workflow within an agent handles a specific task type.</p>"},{"location":"introduction/features/#human-in-the-loop","title":"Human-in-the-Loop","text":"<p>Workflows can pause for hours, days, or weeks waiting for human input, then automatically resume.</p> <pre><code>sequenceDiagram\n    participant W as Agent Workflow\n    participant T as Task\n    participant H as Human Reviewer\n\n    W-&gt;&gt;T: Create Task with Draft\n    T-&gt;&gt;H: Assigned To\n    Note over W: Workflow pauses&lt;br/&gt;(can wait hours/days/weeks)\n    H-&gt;&gt;T: Review &amp; Edit Draft in Task\n    H-&gt;&gt;T: Approve/Reject Decision\n    T-&gt;&gt;W: Resume with Feedback\n    Note over W: Workflow continues\n    W-&gt;&gt;W: Process Next Steps</code></pre> <p>Key capabilities:</p> <ul> <li>Task creation: Agents create tasks requiring human judgment</li> <li>Draft review: Human reviewers edit and approve agent outputs</li> <li>Flexible timing: Workflows can wait indefinitely for human input</li> <li>Approval chains: Multi-step review processes with multiple tasks</li> <li>Audit trails: Complete history of reviews and decisions</li> </ul> <p>Agents create tasks, attach drafts, and wait for approval. Humans review, edit, approve, or reject. Workflow continues with the feedback. Everything tracked in the audit trail.</p>"},{"location":"introduction/features/#long-running-workflows","title":"Long-Running Workflows","text":"<p>Built on Temporal, so your workflows can run for days, months, or years with automatic state management and recovery.</p> <p>Traditional automation breaks on long-running processes. Xians workflows are durable, maintaining state across restarts, failures, and deployments. A customer onboarding workflow can span weeks; an annual compliance workflow runs for months - all reliably managed.</p> <p>Key capabilities:</p> <ul> <li>Durable execution: Workflows survive failures and infrastructure restarts</li> <li>State persistence: Maintain context across distributed operations</li> <li>Auto-retry: Automatic recovery from transient failures</li> <li>Composition: Orchestrate complex multi-step processes</li> </ul> <p>Each agent can have multiple workflows for conversations, events, or custom business processes. The \"Default Workflow\" gives you all platform functions out-of-the-box.</p>"},{"location":"introduction/features/#scheduling","title":"Scheduling","text":"<p>Create time-based workflow automation with a modern, fluent API that works the same everywhere - in regular code, agent tools, and even inside workflows themselves.</p> <p>Time-based automation lets agents work autonomously - generating reports at 9 AM, processing overnight data, sending weekly summaries - without manual triggers.</p> <p>Key capabilities:</p> <ul> <li>Flexible scheduling: Cron expressions, intervals, daily/weekly/monthly helpers, or one-time calendar schedules</li> <li>Timezone support: Schedule in any timezone using IANA timezone database</li> <li>Workflow-aware: Same API works both inside and outside workflows with automatic determinism</li> <li>Full lifecycle management: Create, pause, resume, trigger, update, and delete schedules</li> <li>Dynamic creation: Agents create schedules based on conversations</li> <li>Multi-tenant isolation: Automatic tenant security and isolation</li> </ul> <p>Built on Temporal's durable execution, so schedules survive restarts and system failures. Manage everything programmatically via SDK or through the UI.</p>"},{"location":"introduction/features/#webhooks","title":"Webhooks","text":"<p>TBD.</p>"},{"location":"introduction/features/#document-storage","title":"Document Storage","text":"<p>Persist and query structured data with a tenant-scoped JSON document store. Save user preferences, conversation memory, session state, analytics - any data your agent needs to remember.</p> <p>Agents need structured memory beyond conversations. Document storage provides flexible JSON persistence with semantic keys, metadata filtering, and automatic cleanup - without database complexity.</p> <p>Key capabilities:</p> <ul> <li>JSON storage: Store any JSON-serializable object with no schema constraints</li> <li>Semantic keys: Use meaningful identifiers like \"user-123-preferences\" instead of random IDs</li> <li>Metadata filtering: Query by type, metadata fields, and date ranges</li> <li>TTL support: Auto-delete documents after expiration (sessions, caches, temporary data)</li> <li>Dual access: Available at agent-level and from within workflow contexts</li> <li>Tenant isolation: Automatic data separation per customer</li> </ul> <p>Common use cases: conversation memory, user preferences, session state, analytics tracking, API response caching. Simple, fast, and purpose-built for agent workflows.</p>"},{"location":"introduction/features/#knowledge-management","title":"Knowledge Management","text":"<p>Shared storage for agent configuration, prompts, instructions, and reference data. Both agents (via code) and humans (via UI) can read and write the same knowledge.</p> <p>Agents need more than just code - they need prompts, instructions, configs, and reference data that can be updated without redeployment. Knowledge provides a shared filing cabinet accessible to both code and humans.</p> <p>Key capabilities:</p> <ul> <li>Dual access: Agents use SDK methods, humans use UI portal - same data</li> <li>Automatic scoping: Per-agent and per-tenant isolation</li> <li>Multiple content types: Prompts, instructions, JSON configs, markdown docs, preferences</li> <li>Simple CRUD: Get, update, delete, and list operations</li> <li>Fast retrieval: Automatic caching for performance</li> <li>Flexible storage: Any text content - no schema constraints</li> </ul> <p>Common uses: AI prompts editable via UI, user preferences, feature flags, instructions, API configurations, templates, FAQ content. Update agent behavior without code changes.</p>"},{"location":"introduction/features/#sub-workflows","title":"Sub-Workflows","text":"<p>Composable workflow components that can be reused across different parent workflows.</p> <p>Complex workflows benefit from modularity. Sub-workflows are reusable building blocks - a \"send email\" sub-workflow, a \"verify identity\" sub-workflow - that compose into larger processes.</p> <p>Key capabilities:</p> <ul> <li>Reusability: Define once, use across multiple parent workflows</li> <li>Composition: Nest workflows for clean architecture</li> <li>Independent scaling: Sub-workflows can have different worker pools</li> <li>Isolated testing: Test sub-workflows independently</li> <li>Failure isolation: Sub-workflow failures don't cascade</li> </ul> <p>Build a library of workflow components. Compose them into sophisticated business processes. Maintain and test each piece separately.</p>"},{"location":"introduction/features/#observability","title":"Observability","text":"<p>Built-in logging, metrics, and audit trails so you can actually see what your agents are doing.</p>"},{"location":"introduction/features/#logs--exceptions","title":"Logs &amp; Exceptions","text":"<p>Auto-captured with stack traces. View in the UI, search by agent/tenant/workflow/time. Real-time alerts when things explode.</p>"},{"location":"introduction/features/#metrics","title":"Metrics","text":"What We Track Why Response times, latency Find bottlenecks Token usage, API calls Control costs Job counts, message volumes Monitor load Success/failure rates Catch issues"},{"location":"introduction/features/#opentelemetry-support","title":"OpenTelemetry Support","text":"<p>Distributed tracing, structured logs, correlation IDs. Works with Datadog, New Relic, Grafana, and friends.</p>"},{"location":"introduction/features/#audit-trails","title":"Audit Trails","text":"<p>Immutable execution history for compliance. Every workflow, every action, every decision - timestamped and logged.</p>"},{"location":"introduction/features/#in-short","title":"In Short","text":"<p>Xians is the infrastructure layer for agents. Keep your agent code focused on AI logic. Let Xians handle the production plumbing: agent registration, multi-tenancy, collaboration, workflows, scheduling, data storage, observability, and human oversight.</p> <p>Not another agent framework. The control plane that makes your agents production-ready.</p>"},{"location":"introduction/overview/","title":"Introduction","text":"<p>Welcome to Xians.ai - an enterprise-grade Agent Development Kit for building, deploying, and orchestrating AI agents in production environments.</p> Page Description Where Does it Fit Learn how Xians integrates into your architecture as a dedicated Agent Microservice between your web server and AI agents Features Explore Xians' complete feature set including multi-tenancy, agent collaboration, workflows, scheduling, and observability"},{"location":"introduction/where-does-it-fit/","title":"Where Does it Fit?","text":"<p>Xians is designed to integrate seamlessly into your existing architecture as a dedicated Agent Microservice. It sits between your web server and your AI agents, handling all agent management, orchestration, and communication.</p>"},{"location":"introduction/where-does-it-fit/#your-product-architecture","title":"Your Product Architecture","text":"<p>The diagram above illustrates how Xians fits into a typical microservices architecture:</p> <ol> <li>Your Product UI - Your frontend application where users interact with your product</li> <li>Your Web Server - Your backend/BFF (Backend for Frontend) layer that handles UI logic</li> <li>Agent Microservice (Xians Server) - The dedicated service for managing AI agents</li> <li>Your Agents - The AI agents that perform tasks and interact with users</li> </ol>"},{"location":"introduction/where-does-it-fit/#direct-integration-option","title":"Direct Integration Option","text":"<p>Alternatively, the Xians Server can use OIDC to connect directly with your web UI in scenarios where a BFF/Web Server layer is not mediating the communication. Developers may use the Xians TypeScript SDK (Optional) to easily integrate with the server's APIs.</p>"},{"location":"introduction/where-does-it-fit/#xians-subcomponents","title":"Xians Subcomponents","text":"<p>Xians is built with a modular architecture comprising the following major components:</p> <p></p> <ol> <li>Xians Server - The core orchestration engine that provides APIs for agents and external applications to interact with the platform. Both Web and Temporal servers are a part of this.</li> <li>Xians UI - A comprehensive web interface for managing and controlling all aspects of your agents (serves as an alternative to direct API integration)</li> <li>Xians Lib - A .NET Core class library that agents use to establish connections and communicate with the Xians server</li> </ol>"},{"location":"introduction/where-does-it-fit/#built-on-temporal","title":"Built on Temporal","text":"<p>Xians is built on the industry-proven open source Temporal workflow server, which acts as the agent's work execution engine. This foundation unlocks powerful capabilities:</p> <ul> <li>Distributed Execution - Agents run as independent processes focused purely on business logic, while Xians handles all external interactions</li> <li>Horizontal Scalability - Simply spawn more agent containers and watch Xians automatically distribute the workload</li> <li>Fault Tolerance - Leverage Temporal's battle-tested timeout and retry policies to keep your agents resilient</li> <li>Long-running Processes - Xians can orchestrate durable, multi-step agent workflows that can span minutes, hours, or even years, with state managed reliably by Temporal.</li> </ul>"},{"location":"introduction/where-does-it-fit/#asynchronous--stateless","title":"Asynchronous &amp; Stateless","text":"<p>Xians agents communicate with the external world through a fully asynchronous message queue architecture:</p> <pre><code>sequenceDiagram\n    participant External as External System\n    participant XServer as Xians Server\n    participant Queue as Temporal Queue\n    participant Agent as Agent Worker (Xians Lib)\n\n    External-&gt;&gt;XServer: HTTP Request (e.g., Webhook)\n    XServer-&gt;&gt;Queue: Queue Message\n    Queue-&gt;&gt;Agent: Process Request\n    Agent-&gt;&gt;XServer: Return Response\n    XServer-&gt;&gt;External: HTTP Response</code></pre> <p>Even when you send a synchronous HTTP webhook request, Xians processes it asynchronously under the hood using queues with configurable timeouts. This architectural choice enables:</p> <ul> <li>Massive Scalability - Handle high loads by distributing work across multiple agents</li> <li>Stateless Execution - Each request is processed independently, making agents easier to scale and maintain </li> </ul>"},{"location":"sdk-reference/scheduling-sdk/","title":"Scheduling Deep Dive","text":"<p>This guide provides comprehensive coverage of Xians scheduling capabilities, including advanced patterns, production configurations, error handling, and real-world examples.</p>"},{"location":"sdk-reference/scheduling-sdk/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Architecture Overview</li> <li>Complete Scheduling Patterns</li> <li>Production Configuration</li> <li>Lifecycle Management</li> <li>Error Handling</li> <li>Workflow-Aware Execution</li> <li>Multi-Tenant Security</li> <li>Real-World Examples</li> <li>API Reference</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#architecture-overview","title":"Architecture Overview","text":""},{"location":"sdk-reference/scheduling-sdk/#how-xians-scheduling-works","title":"How Xians Scheduling Works","text":"<p>Xians scheduling is built on Temporal's Schedule feature, which provides:</p> <ol> <li>Durable Storage - Schedules are persisted in Temporal's database</li> <li>Distributed Execution - No single point of failure; runs across cluster</li> <li>Event-Driven - Triggers workflow executions based on time rules</li> <li>Audit Trail - Complete history of schedule changes and executions</li> </ol>"},{"location":"sdk-reference/scheduling-sdk/#xians-enhancements","title":"Xians Enhancements","text":"<p>Xians adds several layers on top of Temporal:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Fluent API (ScheduleBuilder)           \u2502  \u2190 Developer-friendly interface\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Multi-Tenant Isolation                 \u2502  \u2190 Automatic tenant scoping\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Workflow-Aware Context Detection       \u2502  \u2190 Auto-determinism\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Schedule Activities (System)           \u2502  \u2190 Pre-registered activities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Temporal Schedule API                  \u2502  \u2190 Core scheduling engine\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#key-components","title":"Key Components","text":"<p>ScheduleCollection (<code>workflow.Schedules!</code>) - Factory for creating and managing schedules - Tenant-aware querying and filtering - Lifecycle operations (create, get, list, delete)</p> <p>ScheduleBuilder - Fluent API for schedule configuration - Type-safe scheduling options - Terminal <code>.StartAsync()</code> method</p> <p>XiansSchedule - Handle to individual schedule instance - Operations: pause, resume, trigger, update, delete - Information retrieval via <code>DescribeAsync()</code></p> <p>ScheduleActivities - System-registered activities for workflow context - Automatic usage when <code>Workflow.InWorkflow == true</code> - Maintains determinism in workflow executions</p>"},{"location":"sdk-reference/scheduling-sdk/#complete-scheduling-patterns","title":"Complete Scheduling Patterns","text":""},{"location":"sdk-reference/scheduling-sdk/#time-based-schedules-with-timezones","title":"Time-Based Schedules with Timezones","text":"<p>All time-based schedules support IANA timezone configuration:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Temporalio.Workflows;\n\n[Workflow(\"Schedule Setup Workflow\")]\npublic class ScheduleSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Daily at specific time\n        await workflow.Schedules!\n            .Create(\"daily-morning-report\")\n            .Daily(hour: 9, minute: 30, timezone: \"America/New_York\")\n            .WithInput(\"report-type\", \"daily\")\n            .StartAsync();\n\n        // Weekly on specific day\n        await workflow.Schedules!\n            .Create(\"weekly-monday-sync\")\n            .Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n            .WithInput(\"sync-config\")\n            .StartAsync();\n\n        // Monthly on specific day\n        await workflow.Schedules!\n            .Create(\"monthly-first-billing\")\n            .Monthly(dayOfMonth: 1, hour: 8, timezone: \"Asia/Tokyo\")\n            .WithInput(\"billing-params\")\n            .StartAsync();\n\n        // Weekdays only (Monday-Friday)\n        await workflow.Schedules!\n            .Create(\"weekday-check\")\n            .Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n            .WithInput(\"health-check\")\n            .StartAsync();\n\n        // Every hour at specific minute\n        await workflow.Schedules!\n            .Create(\"hourly-quarter-past\")\n            .Hourly(minute: 15)\n            .WithInput(\"monitoring-data\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"All schedules created successfully\");\n    }\n}\n</code></pre> <p>Timezone Behavior: - Default: UTC if timezone not specified - DST Handling: Temporal automatically adjusts for daylight saving time - IANA Names: Use standard names like <code>\"America/New_York\"</code>, not abbreviations like <code>\"EST\"</code></p>"},{"location":"sdk-reference/scheduling-sdk/#interval-based-schedules","title":"Interval-Based Schedules","text":"<p>Duration-based schedules that don't use timezones:</p> C#<pre><code>[Workflow(\"Interval Schedule Setup\")]\npublic class IntervalScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Simple intervals\n        await workflow.Schedules!\n            .Create(\"every-30-seconds\")\n            .EverySeconds(30)\n            .WithInput(\"fast-polling\")\n            .StartAsync();\n\n        await workflow.Schedules!\n            .Create(\"every-30-minutes\")\n            .EveryMinutes(30)\n            .WithInput(\"medium-polling\")\n            .StartAsync();\n\n        await workflow.Schedules!\n            .Create(\"every-2-hours\")\n            .EveryHours(2)\n            .WithInput(\"slow-polling\")\n            .StartAsync();\n\n        // Custom interval with offset\n        await workflow.Schedules!\n            .Create(\"custom-interval\")\n            .WithIntervalSchedule(\n                interval: TimeSpan.FromMinutes(5),\n                offset: TimeSpan.FromSeconds(30)  // Start 30 seconds into each 5-minute window\n            )\n            .WithInput(\"offset-task\")\n            .StartAsync();\n\n        // Every N days (uses Daily internally if days=1)\n        await workflow.Schedules!\n            .Create(\"every-3-days\")\n            .EveryDays(3, hour: 9, minute: 0, timezone: \"America/New_York\")\n            .WithInput(\"tri-daily-task\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Interval schedules created\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#cron-expression-schedules","title":"Cron Expression Schedules","text":"<p>Advanced scheduling patterns using 5-field cron expressions:</p> C#<pre><code>[Workflow(\"Cron Schedule Setup\")]\npublic class CronScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Every day at 9 AM UTC\n        await workflow.Schedules!\n            .Create(\"cron-daily\")\n            .WithCronSchedule(\"0 9 * * *\")\n            .WithInput(\"daily-cron\")\n            .StartAsync();\n\n        // Weekdays at 9 AM with timezone\n        await workflow.Schedules!\n            .Create(\"cron-weekdays\")\n            .WithCronSchedule(\"0 9 * * 1-5\", timezone: \"America/New_York\")\n            .WithInput(\"weekday-cron\")\n            .StartAsync();\n\n        // First of month at midnight\n        await workflow.Schedules!\n            .Create(\"cron-monthly\")\n            .WithCronSchedule(\"0 0 1 * *\", timezone: \"America/New_York\")\n            .WithInput(\"monthly-cron\")\n            .StartAsync();\n\n        // Every 30 minutes\n        await workflow.Schedules!\n            .Create(\"cron-30min\")\n            .WithCronSchedule(\"*/30 * * * *\")\n            .WithInput(\"half-hourly\")\n            .StartAsync();\n\n        // Every 2 hours\n        await workflow.Schedules!\n            .Create(\"cron-2hours\")\n            .WithCronSchedule(\"0 */2 * * *\")\n            .WithInput(\"bi-hourly\")\n            .StartAsync();\n\n        // Complex pattern: Every 15 minutes during business hours (9 AM - 5 PM) on weekdays\n        await workflow.Schedules!\n            .Create(\"cron-business-hours\")\n            .WithCronSchedule(\"*/15 9-17 * * 1-5\", timezone: \"America/New_York\")\n            .WithInput(\"business-hours-monitoring\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Cron schedules created\");\n    }\n}\n</code></pre> <p>Cron Format (5 fields): Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n\u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1 - 31)\n\u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n\u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of week (0 - 6) (Sunday=0)\n\u2502 \u2502 \u2502 \u2502 \u2502\n* * * * *\n</code></pre></p>"},{"location":"sdk-reference/scheduling-sdk/#calendar-based-one-time-schedules","title":"Calendar-Based (One-Time) Schedules","text":"<p>Execute at a specific date and time:</p> C#<pre><code>[Workflow(\"Calendar Schedule Setup\")]\npublic class CalendarScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Specific future date and time\n        var scheduledTime = new DateTime(2026, 12, 25, 9, 0, 0);\n\n        await workflow.Schedules!\n            .Create(\"christmas-morning\")\n            .WithCalendarSchedule(scheduledTime, timezone: \"America/New_York\")\n            .WithInput(\"holiday-greeting\")\n            .StartAsync();\n\n        // Relative to current time\n        var futureTime = DateTime.UtcNow.AddHours(24);\n\n        await workflow.Schedules!\n            .Create(\"delayed-start\")\n            .WithCalendarSchedule(futureTime)\n            .WithInput(\"delayed-task\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Calendar schedules created\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#production-configuration","title":"Production Configuration","text":""},{"location":"sdk-reference/scheduling-sdk/#complete-production-ready-schedule","title":"Complete Production-Ready Schedule","text":"<p>This example shows all recommended production features:</p> C#<pre><code>using Temporalio.Common;\nusing Temporalio.Workflows;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"Production Schedule Setup\")]\npublic class ProductionScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        var schedule = await workflow.Schedules!\n            .Create(\"production-daily-report\")\n\n            // Schedule timing\n            .Daily(hour: 9, timezone: \"America/New_York\")\n\n            // Workflow input\n            .WithInput(\"report-config\", \"additional-params\")\n\n            // Retry policy - handle transient failures\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 5,\n                InitialInterval = TimeSpan.FromSeconds(10),\n                BackoffCoefficient = 2.0,  // Exponential backoff: 10s, 20s, 40s, 80s, 160s\n                MaximumInterval = TimeSpan.FromMinutes(10)\n            })\n\n            // Timeout - prevent runaway workflows\n            .WithTimeout(TimeSpan.FromHours(2))\n\n            // Overlap policy - prevent execution pile-up\n            .SkipIfRunning()\n\n            // Metadata - tracking and debugging\n            .WithMemo(new Dictionary&lt;string, object&gt;\n            {\n                { \"environment\", \"production\" },\n                { \"owner\", \"data-team\" },\n                { \"priority\", \"high\" },\n                { \"version\", \"2.1.0\" },\n                { \"created_by\", workflow.GetType().Name }\n            })\n\n            // Start the schedule\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Production schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#overlap-policies-explained","title":"Overlap Policies Explained","text":"<p>Control behavior when new execution is triggered while previous is still running:</p> C#<pre><code>// RECOMMENDED: Skip if already running\n// Use case: Most scenarios - prevents pile-up\n.SkipIfRunning()\n\n// Allow concurrent executions\n// Use case: Independent, fast executions\n.AllowOverlap()\n\n// Queue one execution for after current completes\n// Use case: Must process at least once more after current\n.BufferOne()\n\n// Cancel currently running execution, start new one\n// Use case: Newer data supersedes current processing\n.CancelOther()\n\n// Terminate currently running execution (immediate stop)\n// Use case: Rare - forces stop without cleanup\n.TerminateOther()\n\n// Or use the policy method directly\n.WithOverlapPolicy(ScheduleOverlapPolicy.Skip)\n</code></pre> <p>Decision Matrix:</p> Scenario Recommended Policy Daily reports that take hours <code>SkipIfRunning()</code> Fast, independent health checks <code>AllowOverlap()</code> Data sync that must catch up <code>BufferOne()</code> Real-time data where latest matters <code>CancelOther()</code> Emergency shutdown required <code>TerminateOther()</code> (use with caution)"},{"location":"sdk-reference/scheduling-sdk/#retry-policies","title":"Retry Policies","text":"<p>Configure automatic retry behavior for failed executions:</p> C#<pre><code>.WithRetryPolicy(new RetryPolicy\n{\n    // Maximum number of retry attempts\n    MaximumAttempts = 5,\n\n    // Initial delay before first retry\n    InitialInterval = TimeSpan.FromSeconds(10),\n\n    // Multiplier for exponential backoff\n    BackoffCoefficient = 2.0,\n\n    // Cap for maximum delay between retries\n    MaximumInterval = TimeSpan.FromMinutes(10),\n\n    // Optional: Retry only specific exception types\n    // NonRetryableErrorTypes = new[] { \"BusinessLogicException\" }\n})\n</code></pre> <p>Example Retry Sequence: - Attempt 1 fails \u2192 wait 10s - Attempt 2 fails \u2192 wait 20s (10s \u00d7 2.0) - Attempt 3 fails \u2192 wait 40s (20s \u00d7 2.0) - Attempt 4 fails \u2192 wait 80s (40s \u00d7 2.0) - Attempt 5 fails \u2192 wait 160s, but capped at 600s (10 minutes)</p>"},{"location":"sdk-reference/scheduling-sdk/#workflow-timeouts","title":"Workflow Timeouts","text":"<p>Set execution time limits:</p> C#<pre><code>// Absolute timeout for workflow execution\n.WithTimeout(TimeSpan.FromHours(2))\n\n// Workflow will be terminated if it exceeds 2 hours\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#custom-metadata","title":"Custom Metadata","text":"<p>Add tracking information to scheduled workflows:</p> C#<pre><code>.WithMemo(new Dictionary&lt;string, object&gt;\n{\n    { \"environment\", \"production\" },\n    { \"team\", \"data-engineering\" },\n    { \"cost_center\", \"engineering-ops\" },\n    { \"sla\", \"99.9%\" },\n    { \"on_call\", \"team-alpha\" },\n    { \"documentation\", \"https://docs.example.com/workflows/daily-sync\" }\n})\n</code></pre> <p>Metadata is attached to each workflow execution and visible in Temporal UI.</p>"},{"location":"sdk-reference/scheduling-sdk/#start-paused","title":"Start Paused","text":"<p>Create schedule in paused state for later activation:</p> C#<pre><code>[Workflow(\"Approval-Based Schedule Setup\")]\npublic class ApprovalScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(bool approved)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Create paused schedule\n        await workflow.Schedules!\n            .Create(\"pending-approval-schedule\")\n            .Daily(hour: 9, timezone: \"America/New_York\")\n            .WithInput(\"data\")\n            .StartPaused(paused: true, note: \"Awaiting stakeholder approval\")\n            .StartAsync();\n\n        if (approved)\n        {\n            // Activate immediately if already approved\n            var schedule = await workflow.Schedules!.GetAsync(\"pending-approval-schedule\");\n            await schedule.UnpauseAsync(\"Approved by stakeholder on 2026-01-15\");\n\n            Workflow.Logger.LogInformation(\"Schedule approved and activated\");\n        }\n        else\n        {\n            Workflow.Logger.LogInformation(\"Schedule created in paused state, awaiting approval\");\n        }\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"sdk-reference/scheduling-sdk/#retrieve-and-inspect-schedules","title":"Retrieve and Inspect Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Get specific schedule\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Get detailed information\nvar description = await schedule.DescribeAsync();\n\n// Access schedule information\nvar nextRun = description.Info.NextActionTimes.FirstOrDefault();\nvar recentRuns = description.Info.RecentActions;\nvar isPaused = description.Schedule.State.Paused;\nvar pauseNote = description.Schedule.State.Note;\n\nConsole.WriteLine($\"Schedule ID: {schedule.Id}\");\nConsole.WriteLine($\"Next execution: {nextRun}\");\nConsole.WriteLine($\"Status: {(isPaused ? \"Paused\" : \"Active\")}\");\nif (!string.IsNullOrEmpty(pauseNote))\n{\n    Console.WriteLine($\"Note: {pauseNote}\");\n}\n\n// Recent execution history\nConsole.WriteLine(\"Recent executions:\");\nforeach (var action in recentRuns.Take(5))\n{\n    Console.WriteLine($\"  - {action.ActualTime}: {action.TakenAt}\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#pause-and-resume","title":"Pause and Resume","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Pause with descriptive note\nawait schedule.PauseAsync(\"System maintenance - database migration in progress\");\n\n// ... perform maintenance ...\n\n// Resume with completion note\nawait schedule.UnpauseAsync(\"Maintenance completed successfully at 2026-01-15 10:30 UTC\");\n\n// Or use collection methods\nawait workflow.Schedules!.PauseAsync(\"my-schedule\", \"Temporary pause for testing\");\nawait workflow.Schedules!.UnpauseAsync(\"my-schedule\", \"Testing complete\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#trigger-immediate-execution","title":"Trigger Immediate Execution","text":"<p>Execute schedule immediately without affecting its regular timing:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar schedule = await workflow.Schedules!.GetAsync(\"daily-report\");\n\n// Trigger now (doesn't change next scheduled execution)\nawait schedule.TriggerAsync();\n\nConsole.WriteLine(\"Manual execution triggered\");\n\n// Or via collection\nawait workflow.Schedules!.TriggerAsync(\"daily-report\");\n</code></pre> <p>Use Cases: - Manual report generation - Testing schedule configuration - Catch-up after fixing a bug - User-requested immediate execution</p>"},{"location":"sdk-reference/scheduling-sdk/#update-schedule-configuration","title":"Update Schedule Configuration","text":"<p>Modify existing schedule settings:</p> C#<pre><code>var schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\nawait schedule.UpdateAsync(input =&gt; \n{\n    var updatedSchedule = input.Description.Schedule;\n\n    // Change schedule time (e.g., from 9 AM to 10 AM)\n    updatedSchedule = new Schedule(\n        Action: updatedSchedule.Action,\n        Spec: new ScheduleSpec\n        {\n            CronExpressions = new List&lt;string&gt; \n            { \n                \"0 10 * * *\"  // 10 AM instead of 9 AM\n            },\n            TimeZoneName = \"America/New_York\"\n        })\n    {\n        Policy = updatedSchedule.Policy,\n        State = updatedSchedule.State\n    };\n\n    return new ScheduleUpdate(updatedSchedule);\n});\n\nConsole.WriteLine(\"Schedule updated to 10 AM\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#delete-schedules","title":"Delete Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Delete via schedule instance\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\nawait schedule.DeleteAsync();\n\n// Or via collection\nawait workflow.Schedules!.DeleteAsync(\"my-schedule\");\n\n// Check existence first (idempotent deletion)\nif (await workflow.Schedules!.ExistsAsync(\"my-schedule\"))\n{\n    await workflow.Schedules!.DeleteAsync(\"my-schedule\");\n    Console.WriteLine(\"Schedule deleted\");\n}\nelse\n{\n    Console.WriteLine(\"Schedule doesn't exist\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#list-all-schedules","title":"List All Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// List all schedules for this workflow (automatically filtered by tenant)\nvar schedules = await workflow.Schedules!.ListAsync();\n\nConsole.WriteLine(\"All schedules:\");\nawait foreach (var scheduleInfo in schedules)\n{\n    Console.WriteLine($\"\\nSchedule ID: {scheduleInfo.Id}\");\n\n    // Get full details\n    var schedule = await workflow.Schedules!.GetAsync(scheduleInfo.Id);\n    var description = await schedule.DescribeAsync();\n\n    var nextRun = description.Info.NextActionTimes.FirstOrDefault();\n    var isPaused = description.Schedule.State.Paused;\n    var memo = description.Memo;\n\n    Console.WriteLine($\"  Next run: {nextRun}\");\n    Console.WriteLine($\"  Status: {(isPaused ? \"Paused\" : \"Active\")}\");\n\n    if (memo?.Fields != null &amp;&amp; memo.Fields.ContainsKey(\"environment\"))\n    {\n        Console.WriteLine($\"  Environment: {memo.Fields[\"environment\"]}\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#backfill-missed-executions","title":"Backfill Missed Executions","text":"<p>Execute schedule for past time ranges (useful after system downtime):</p> C#<pre><code>var schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Run schedule for last week (e.g., after outage)\nvar backfills = new List&lt;ScheduleBackfill&gt;\n{\n    new(\n        StartAt: DateTime.UtcNow.AddDays(-7),\n        EndAt: DateTime.UtcNow,\n        Overlap: ScheduleOverlapPolicy.AllowAll  // Allow all backfill executions\n    )\n};\n\nawait schedule.BackfillAsync(backfills);\nConsole.WriteLine(\"Backfill started for past 7 days\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#error-handling","title":"Error Handling","text":""},{"location":"sdk-reference/scheduling-sdk/#exception-types","title":"Exception Types","text":"C#<pre><code>using Xians.Lib.Agents.Scheduling.Models;\n\nvar workflow = XiansContext.CurrentWorkflow;\n\ntry\n{\n    var schedule = await workflow.Schedules!\n        .Create(\"my-schedule\")\n        .Daily(hour: 9)\n        .WithInput(\"data\")\n        .StartAsync();\n\n    Console.WriteLine($\"Schedule created: {schedule.Id}\");\n}\ncatch (ScheduleAlreadyExistsException ex)\n{\n    // Schedule with this ID already exists\n    Console.WriteLine($\"Warning: Schedule '{ex.ScheduleId}' already exists\");\n\n    // Option 1: Get existing schedule\n    var existing = await workflow.Schedules!.GetAsync(ex.ScheduleId);\n    Console.WriteLine(\"Using existing schedule\");\n\n    // Option 2: Delete and recreate\n    // await workflow.Schedules!.DeleteAsync(ex.ScheduleId);\n    // var newSchedule = await workflow.Schedules!.Create(ex.ScheduleId)...StartAsync();\n}\ncatch (InvalidScheduleSpecException ex)\n{\n    // Invalid schedule configuration\n    Console.WriteLine($\"Error: Invalid schedule specification: {ex.Message}\");\n    // Examples: Missing spec, invalid cron, invalid parameters\n}\ncatch (ScheduleNotFoundException ex)\n{\n    // Trying to access non-existent schedule\n    Console.WriteLine($\"Error: Schedule '{ex.ScheduleId}' not found\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#idempotent-schedule-creation","title":"Idempotent Schedule Creation","text":"<p>Safe creation that handles existing schedules:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar scheduleId = \"my-recurring-task\";\n\n// Pattern 1: Check existence first\nif (!await workflow.Schedules!.ExistsAsync(scheduleId))\n{\n    await workflow.Schedules!\n        .Create(scheduleId)\n        .Daily(hour: 9, timezone: \"America/New_York\")\n        .WithInput(\"data\")\n        .StartAsync();\n\n    Console.WriteLine(\"Schedule created\");\n}\nelse\n{\n    Console.WriteLine(\"Schedule already exists\");\n}\n\n// Pattern 2: Try-catch approach\ntry\n{\n    await workflow.Schedules!\n        .Create(scheduleId)\n        .Daily(hour: 9)\n        .StartAsync();\n}\ncatch (ScheduleAlreadyExistsException)\n{\n    // Already exists - safe to continue\n    Console.WriteLine(\"Schedule already exists\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#graceful-degradation","title":"Graceful Degradation","text":"C#<pre><code>async Task&lt;XiansSchedule?&gt; CreateScheduleSafely(string scheduleId)\n{\n    try\n    {\n        return await workflow.Schedules!\n            .Create(scheduleId)\n            .Daily(hour: 9)\n            .WithInput(\"data\")\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 3,\n                InitialInterval = TimeSpan.FromSeconds(10)\n            })\n            .StartAsync();\n    }\n    catch (ScheduleAlreadyExistsException)\n    {\n        _logger.LogInformation(\"Schedule {ScheduleId} already exists\", scheduleId);\n        return await workflow.Schedules!.GetAsync(scheduleId);\n    }\n    catch (InvalidScheduleSpecException ex)\n    {\n        _logger.LogError(ex, \"Invalid schedule specification for {ScheduleId}\", scheduleId);\n        return null;\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError(ex, \"Unexpected error creating schedule {ScheduleId}\", scheduleId);\n        return null;\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#workflow-aware-execution","title":"Workflow-Aware Execution","text":"<p>** Recommended Pattern**: Create schedules from within workflows for automatic determinism and tenant context.</p>"},{"location":"sdk-reference/scheduling-sdk/#inside-workflow-context-recommended","title":"Inside Workflow Context (Recommended)","text":"<p>Workflows create and manage schedules with automatic activity usage for determinism:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\n\n[Workflow(\"Self-Scheduling Workflow\")]\npublic class SelfSchedulingWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;SelfSchedulingWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string taskName, int intervalHours)\n    {\n        _logger.LogInformation(\"Creating recurring schedule for {TaskName}\", taskName);\n\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // SDK detects Workflow.InWorkflow == true\n        // Automatically uses ScheduleActivities for determinism!\n        var schedule = await workflow.Schedules!\n            .Create($\"recurring-{taskName}\")\n            .EveryHours(intervalHours)\n            .WithInput(taskName, intervalHours)\n            .SkipIfRunning()\n            .StartAsync();\n\n        _logger.LogInformation(\"Schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre> <p>How It Works:</p> <ol> <li>SDK checks <code>Workflow.InWorkflow</code> property</li> <li>If true: Automatically delegates to pre-registered <code>ScheduleActivities</code></li> <li>Maintains workflow determinism</li> <li>No manual activity registration needed!</li> </ol> <p>Benefits: -  Automatic determinism through activities -  Tenant context automatically available -  Clean workflow-centric design -  No external setup required</p>"},{"location":"sdk-reference/scheduling-sdk/#system-activities-auto-registered","title":"System Activities Auto-Registered","text":"<p>System activities are automatically registered - no configuration needed:</p> C#<pre><code>// You DON'T need to do this - activities auto-registered!\n// worker.AddActivity&lt;ScheduleActivities&gt;();\n\n// Just use the schedule API from within your workflow\n[WorkflowRun]\npublic async Task RunAsync()\n{\n    var workflow = XiansContext.CurrentWorkflow;\n\n    var schedule = await workflow.Schedules!\n        .Create(\"auto-schedule\")\n        .Daily(hour: 9)\n        .StartAsync();\n}\n</code></pre> <p>Important: <code>XiansContext.CurrentWorkflow</code> can only be used inside workflows or activities. It will throw <code>InvalidOperationException</code> if used outside workflow context.</p>"},{"location":"sdk-reference/scheduling-sdk/#multi-tenant-security","title":"Multi-Tenant Security","text":""},{"location":"sdk-reference/scheduling-sdk/#automatic-tenant-isolation","title":"Automatic Tenant Isolation","text":"<p>Schedules are automatically scoped to the current tenant when created from workflows:</p> C#<pre><code>[Workflow(\"Multi-Tenant Report Workflow\")]\npublic class MultiTenantReportWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context - automatically includes tenant context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // When this workflow runs for tenant \"acme-corp\"\n        await workflow.Schedules!\n            .Create(\"daily-report\")  // Internal ID: \"acme-corp:daily-report\"\n            .Daily(hour: 9)\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Schedule created for tenant: {TenantId}\", \n            XiansContext.TenantId);\n    }\n}\n\n// When the same workflow runs for tenant \"techco\"\n// It creates: \"techco:daily-report\" (completely separate schedule)\n\n// Both schedules exist independently - complete isolation!\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#tenant-scoped-queries","title":"Tenant-Scoped Queries","text":"<p>All schedule operations respect tenant boundaries:</p> C#<pre><code>// In workflow context for tenant \"acme-corp\"\nvar workflow = XiansContext.CurrentWorkflow;\n\n// List only returns schedules for \"acme-corp\"\nvar schedules = await workflow.Schedules!.ListAsync();\n\n// Get only works for \"acme-corp\" schedules\nvar schedule = await workflow.Schedules!.GetAsync(\"daily-report\");\n// This gets \"acme-corp:daily-report\", NOT \"techco:daily-report\"\n\n// Delete only affects \"acme-corp\" schedules\nawait workflow.Schedules!.DeleteAsync(\"daily-report\");\n// This deletes \"acme-corp:daily-report\", NOT \"techco:daily-report\"\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#security-guarantees","title":"Security Guarantees","text":"<p>Complete Isolation - Tenants cannot access each other's schedules - Schedule IDs automatically prefixed with tenant ID - All operations filtered by current tenant context</p> <p>No Cross-Tenant Leakage - List operations only return current tenant's schedules - Get operations fail for other tenants' schedules - Delete operations cannot affect other tenants</p> <p>Automatic Enforcement - No manual tenant filtering required - SDK enforces security transparently - Works in both workflow and non-workflow contexts</p>"},{"location":"sdk-reference/scheduling-sdk/#real-world-examples","title":"Real-World Examples","text":""},{"location":"sdk-reference/scheduling-sdk/#example-1-daily-report-generation","title":"Example 1: Daily Report Generation","text":"<p>Complete production setup for daily morning reports:</p> C#<pre><code>using Temporalio.Workflows;\nusing Temporalio.Common;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n// Define the report workflow\n[Workflow(\"Daily Report Workflow\")]\npublic class DailyReportWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;DailyReportWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string reportType, string recipients)\n    {\n        _logger.LogInformation(\"Generating {ReportType} report for {Recipients}\", \n            reportType, recipients);\n\n        // Report generation logic...\n        await GenerateReport(reportType);\n        await EmailReport(recipients);\n\n        _logger.LogInformation(\"Report generated and sent\");\n    }\n\n    private async Task GenerateReport(string reportType)\n    {\n        // Implementation...\n        await Task.CompletedTask;\n    }\n\n    private async Task EmailReport(string recipients)\n    {\n        // Implementation...\n        await Task.CompletedTask;\n    }\n}\n\n// Setup schedule (in Program.cs or agent initialization)\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"ReportingAgent\",\n    SystemScoped = true\n});\n\nvar workflow = await agent.Workflows.DefineCustom&lt;DailyReportWorkflow&gt;(maxConcurrent: 100);\n\nvar schedule = await workflow.Schedules!\n    .Create(\"daily-morning-report\")\n    .Daily(hour: 9, timezone: \"America/New_York\")\n    .WithInput(\"sales-summary\", \"team@company.com\")\n    .WithRetryPolicy(new RetryPolicy\n    {\n        MaximumAttempts = 3,\n        InitialInterval = TimeSpan.FromSeconds(30),\n        BackoffCoefficient = 2.0\n    })\n    .WithTimeout(TimeSpan.FromHours(1))\n    .SkipIfRunning()\n    .WithMemo(new Dictionary&lt;string, object&gt;\n    {\n        { \"team\", \"sales\" },\n        { \"report_type\", \"daily_sales_summary\" },\n        { \"priority\", \"high\" }\n    })\n    .StartAsync();\n\nConsole.WriteLine($\"Daily report schedule created: {schedule.Id}\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-2-self-scheduling-content-discovery","title":"Example 2: Self-Scheduling Content Discovery","text":"<p>Workflow that creates its own recurring schedule:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"Content Discovery Workflow\")]\npublic class ContentDiscoveryWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;ContentDiscoveryWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string contentUrl, int checkIntervalHours)\n    {\n        _logger.LogInformation(\"Discovering content from {Url}\", contentUrl);\n\n        // Process content\n        var newContent = await DiscoverContent(contentUrl);\n\n        if (newContent != null)\n        {\n            await ProcessNewContent(newContent);\n        }\n\n        // Create recurring schedule for future checks\n        // SDK automatically uses ScheduleActivities for determinism!\n        try\n        {\n            var scheduleId = $\"content-discovery-{SanitizeUrl(contentUrl)}-{checkIntervalHours}h\";\n\n            var schedule = await XiansContext.CurrentWorkflow.Schedules!\n                .Create(scheduleId)\n                .EveryHours(checkIntervalHours)\n                .WithInput(contentUrl, checkIntervalHours)\n                .SkipIfRunning()\n                .WithRetryPolicy(new RetryPolicy\n                {\n                    MaximumAttempts = 3,\n                    InitialInterval = TimeSpan.FromSeconds(10)\n                })\n                .WithMemo(new Dictionary&lt;string, object&gt;\n                {\n                    { \"content_url\", contentUrl },\n                    { \"interval_hours\", checkIntervalHours }\n                })\n                .StartAsync();\n\n            _logger.LogInformation(\"Recurring schedule created: {ScheduleId}\", schedule.Id);\n        }\n        catch (ScheduleAlreadyExistsException ex)\n        {\n            _logger.LogInformation(\"Schedule {ScheduleId} already exists - content discovery will continue\", \n                ex.ScheduleId);\n        }\n        catch (InvalidScheduleSpecException ex)\n        {\n            _logger.LogError(\"Invalid schedule specification: {Message}\", ex.Message);\n            throw;\n        }\n    }\n\n    private async Task&lt;object?&gt; DiscoverContent(string url)\n    {\n        // Content discovery logic...\n        await Task.CompletedTask;\n        return new { Title = \"Sample Content\" };\n    }\n\n    private async Task ProcessNewContent(object content)\n    {\n        // Process discovered content...\n        await Task.CompletedTask;\n    }\n\n    private string SanitizeUrl(string url)\n    {\n        // Convert URL to safe schedule ID component\n        return url.Replace(\"https://\", \"\")\n                  .Replace(\"http://\", \"\")\n                  .Replace(\"/\", \"-\")\n                  .Replace(\".\", \"-\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-3-multi-entity-scheduling","title":"Example 3: Multi-Entity Scheduling","text":"<p>Create schedules for multiple entities dynamically within a workflow:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\nusing Temporalio.Common;\nusing Temporalio.Workflows;\n\n[Workflow(\"Company Research Setup Workflow\")]\npublic class CompanyResearchSetupWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;CompanyResearchSetupWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Create schedules for multiple companies\n        var companies = new[] \n        { \n            new { Name = \"ACME Corp\", Ticker = \"ACME\" },\n            new { Name = \"TechCo\", Ticker = \"TECH\" },\n            new { Name = \"GlobalInc\", Ticker = \"GLOB\" }\n        };\n\n        foreach (var company in companies)\n        {\n            var scheduleId = $\"research-{company.Ticker.ToLower()}\";\n\n            try\n            {\n                var schedule = await workflow.Schedules!\n                    .Create(scheduleId)\n                    .Weekdays(hour: 8, minute: 30, timezone: \"America/New_York\")\n                    .WithInput(company.Name, company.Ticker)\n                    .WithRetryPolicy(new RetryPolicy\n                    {\n                        MaximumAttempts = 3,\n                        InitialInterval = TimeSpan.FromSeconds(15),\n                        BackoffCoefficient = 2.0\n                    })\n                    .SkipIfRunning()\n                    .WithMemo(new Dictionary&lt;string, object&gt;\n                    {\n                        { \"company_name\", company.Name },\n                        { \"ticker\", company.Ticker },\n                        { \"research_type\", \"daily_market_analysis\" }\n                    })\n                    .StartAsync();\n\n                _logger.LogInformation(\"Schedule created for {Company} ({ScheduleId})\", \n                    company.Name, schedule.Id);\n            }\n            catch (ScheduleAlreadyExistsException)\n            {\n                _logger.LogWarning(\"Schedule for {Company} already exists\", company.Name);\n            }\n        }\n\n        _logger.LogInformation(\"Created {Count} research schedules\", companies.Length);\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-4-scheduled-monitoring-with-alerts","title":"Example 4: Scheduled Monitoring with Alerts","text":"<p>Health monitoring that runs every 5 minutes:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\n\n[Workflow(\"System Health Check\")]\npublic class HealthCheckWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;HealthCheckWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string[] services)\n    {\n        _logger.LogInformation(\"Running health check for {ServiceCount} services\", services.Length);\n\n        var unhealthyServices = new List&lt;string&gt;();\n\n        foreach (var service in services)\n        {\n            var isHealthy = await CheckServiceHealth(service);\n\n            if (!isHealthy)\n            {\n                unhealthyServices.Add(service);\n                _logger.LogWarning(\"Service {Service} is unhealthy\", service);\n            }\n        }\n\n        if (unhealthyServices.Any())\n        {\n            await SendAlert(unhealthyServices);\n        }\n\n        _logger.LogInformation(\"Health check complete\");\n    }\n\n    private async Task&lt;bool&gt; CheckServiceHealth(string service)\n    {\n        // Health check logic...\n        await Task.CompletedTask;\n        return true;\n    }\n\n    private async Task SendAlert(List&lt;string&gt; unhealthyServices)\n    {\n        // Alert logic...\n        await Task.CompletedTask;\n    }\n}\n\n// Setup within a workflow\n[Workflow(\"Health Check Setup Workflow\")]\npublic class HealthCheckSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string[] services)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        var schedule = await workflow.Schedules!\n            .Create(\"health-check-5min\")\n            .EveryMinutes(5)\n            .WithInput(services)\n            .AllowOverlap()  // Health checks are independent and fast\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 2,  // Fail fast for health checks\n                InitialInterval = TimeSpan.FromSeconds(5)\n            })\n            .WithTimeout(TimeSpan.FromMinutes(2))\n            .WithMemo(new Dictionary&lt;string, object&gt;\n            {\n                { \"monitor_type\", \"health_check\" },\n                { \"alert_channel\", \"ops-alerts\" }\n            })\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Health check schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-5-schedule-management-dashboard","title":"Example 5: Schedule Management Dashboard","text":"<p>List and manage all schedules:</p> C#<pre><code>using Xians.Lib.Agents;\n\npublic class ScheduleManager\n{\n    private readonly XiansWorkflowContext _workflow;\n\n    public ScheduleManager(XiansWorkflowContext workflow)\n    {\n        _workflow = workflow;\n    }\n\n    public async Task DisplayAllSchedules()\n    {\n        Console.WriteLine(\"=== All Schedules ===\\n\");\n\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            var description = await schedule.DescribeAsync();\n\n            var nextRun = description.Info.NextActionTimes.FirstOrDefault();\n            var isPaused = description.Schedule.State.Paused;\n            var pauseNote = description.Schedule.State.Note;\n\n            Console.WriteLine($\"Schedule: {schedule.Id}\");\n            Console.WriteLine($\"   Status: {(isPaused ? \"Paused\" : \"Active\")}\");\n            Console.WriteLine($\"   Next run: {nextRun?.ToString() ?? \"N/A\"}\");\n\n            if (!string.IsNullOrEmpty(pauseNote))\n            {\n                Console.WriteLine($\"   Note: {pauseNote}\");\n            }\n\n            // Display memo if available\n            if (description.Memo?.Fields != null)\n            {\n                Console.WriteLine(\"   Metadata:\");\n                foreach (var kvp in description.Memo.Fields)\n                {\n                    Console.WriteLine($\"     - {kvp.Key}: {kvp.Value}\");\n                }\n            }\n\n            // Recent execution history\n            if (description.Info.RecentActions.Any())\n            {\n                Console.WriteLine(\"   Recent executions:\");\n                foreach (var action in description.Info.RecentActions.Take(3))\n                {\n                    Console.WriteLine($\"     - {action.ActualTime}\");\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n\n    public async Task PauseAllSchedules(string reason)\n    {\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            await schedule.PauseAsync(reason);\n            Console.WriteLine($\"Paused: {scheduleInfo.Id}\");\n        }\n    }\n\n    public async Task ResumeAllSchedules(string reason)\n    {\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            await schedule.UnpauseAsync(reason);\n            Console.WriteLine($\"Resumed: {scheduleInfo.Id}\");\n        }\n    }\n}\n\n// Usage\nvar workflow = XiansContext.CurrentWorkflow;\nvar manager = new ScheduleManager(workflow);\n\nawait manager.DisplayAllSchedules();\n\n// Pause all for maintenance\nawait manager.PauseAllSchedules(\"Database migration in progress\");\n\n// Resume after maintenance\nawait manager.ResumeAllSchedules(\"Migration completed successfully\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#api-reference","title":"API Reference","text":""},{"location":"sdk-reference/scheduling-sdk/#schedulecollection","title":"ScheduleCollection","text":"<p>Access: <code>workflow.Schedules!</code> or <code>XiansContext.CurrentWorkflow.Schedules!</code></p>"},{"location":"sdk-reference/scheduling-sdk/#creation","title":"Creation","text":"<ul> <li><code>Create(scheduleId)</code> \u2192 <code>ScheduleBuilder</code> - Start building new schedule</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#retrieval","title":"Retrieval","text":"<ul> <li><code>GetAsync(scheduleId)</code> \u2192 <code>Task&lt;XiansSchedule&gt;</code> - Get schedule (async)</li> <li><code>Get(scheduleId)</code> \u2192 <code>XiansSchedule</code> - Get schedule (sync)</li> <li><code>ListAsync()</code> \u2192 <code>Task&lt;IAsyncEnumerable&lt;ScheduleListDescription&gt;&gt;</code> - List all schedules</li> <li><code>ExistsAsync(scheduleId)</code> \u2192 <code>Task&lt;bool&gt;</code> - Check existence</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#management","title":"Management","text":"<ul> <li><code>PauseAsync(scheduleId, note?)</code> \u2192 <code>Task</code> - Pause schedule</li> <li><code>UnpauseAsync(scheduleId, note?)</code> \u2192 <code>Task</code> - Resume schedule</li> <li><code>TriggerAsync(scheduleId)</code> \u2192 <code>Task</code> - Trigger immediate execution</li> <li><code>DeleteAsync(scheduleId)</code> \u2192 <code>Task</code> - Delete schedule</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#schedulebuilder","title":"ScheduleBuilder","text":""},{"location":"sdk-reference/scheduling-sdk/#schedule-timing-methods-choose-one","title":"Schedule Timing Methods (choose one)","text":"<p>Convenience Extensions: - <code>.Daily(hour, minute = 0, timezone?)</code> - Daily at specific time - <code>.Weekly(dayOfWeek, hour, minute = 0, timezone?)</code> - Weekly on day - <code>.Monthly(dayOfMonth, hour, minute = 0, timezone?)</code> - Monthly on day - <code>.Hourly(minute = 0)</code> - Every hour at minute - <code>.Weekdays(hour, minute = 0, timezone?)</code> - Monday-Friday - <code>.EverySeconds(seconds)</code> - Interval in seconds - <code>.EveryMinutes(minutes)</code> - Interval in minutes - <code>.EveryHours(hours)</code> - Interval in hours - <code>.EveryDays(days, hour = 0, minute = 0, timezone?)</code> - Interval in days</p> <p>Core Methods: - <code>.WithCronSchedule(expression, timezone?)</code> - Cron expression - <code>.WithIntervalSchedule(interval, offset?)</code> - Duration interval - <code>.WithCalendarSchedule(dateTime, timezone?)</code> - Specific date/time - <code>.WithScheduleSpec(spec)</code> - Custom Temporal spec</p>"},{"location":"sdk-reference/scheduling-sdk/#workflow-configuration","title":"Workflow Configuration","text":"<ul> <li><code>.WithInput(params object[] args)</code> - Workflow input arguments</li> <li><code>.WithMemo(Dictionary&lt;string, object&gt;)</code> - Custom metadata</li> <li><code>.WithRetryPolicy(RetryPolicy)</code> - Retry policy</li> <li><code>.WithTimeout(TimeSpan)</code> - Execution timeout</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#overlap-policies","title":"Overlap Policies","text":"<ul> <li><code>.SkipIfRunning()</code> - Skip if running (recommended)</li> <li><code>.AllowOverlap()</code> - Allow concurrent executions</li> <li><code>.BufferOne()</code> - Queue one execution</li> <li><code>.CancelOther()</code> - Cancel running, start new</li> <li><code>.TerminateOther()</code> - Terminate running (caution)</li> <li><code>.WithOverlapPolicy(ScheduleOverlapPolicy)</code> - Set policy</li> <li><code>.WithSchedulePolicy(SchedulePolicy)</code> - Advanced policy</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#schedule-state","title":"Schedule State","text":"<ul> <li><code>.StartPaused(paused = true, note?)</code> - Create paused</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#execution","title":"Execution","text":"<ul> <li><code>.StartAsync()</code> - Create and start schedule (required)</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#xiansschedule","title":"XiansSchedule","text":""},{"location":"sdk-reference/scheduling-sdk/#properties","title":"Properties","text":"<ul> <li><code>Id</code> \u2192 <code>string</code> - Schedule identifier</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#information","title":"Information","text":"<ul> <li><code>DescribeAsync()</code> \u2192 <code>Task&lt;ScheduleDescription&gt;</code> - Get details</li> <li><code>Info.NextActionTimes</code> - Upcoming executions</li> <li><code>Info.RecentActions</code> - Execution history</li> <li><code>Schedule.State.Paused</code> - Paused status</li> <li><code>Schedule.State.Note</code> - State note</li> <li><code>Schedule.Spec</code> - Schedule specification</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#operations","title":"Operations","text":"<ul> <li><code>PauseAsync(note?)</code> \u2192 <code>Task</code> - Pause</li> <li><code>UnpauseAsync(note?)</code> \u2192 <code>Task</code> - Resume</li> <li><code>TriggerAsync()</code> \u2192 <code>Task</code> - Trigger now</li> <li><code>UpdateAsync(updater)</code> \u2192 <code>Task</code> - Modify config</li> <li><code>DeleteAsync()</code> \u2192 <code>Task</code> - Delete</li> <li><code>BackfillAsync(backfills)</code> \u2192 <code>Task</code> - Execute for past ranges</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#advanced","title":"Advanced","text":"<ul> <li><code>GetHandle()</code> \u2192 <code>ScheduleHandle</code> - Temporal handle</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#exceptions","title":"Exceptions","text":"<p>Namespace: <code>Xians.Lib.Agents.Scheduling.Models</code></p> <ul> <li><code>ScheduleAlreadyExistsException</code> - Schedule ID exists</li> <li><code>ScheduleNotFoundException</code> - Schedule not found</li> <li><code>InvalidScheduleSpecException</code> - Invalid configuration</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"sdk-reference/scheduling-sdk/#1-always-configure-overlap-policies","title":"1. Always Configure Overlap Policies","text":"C#<pre><code>.SkipIfRunning()  // Recommended for most cases\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#2-add-retry-policies-for-production","title":"2. Add Retry Policies for Production","text":"C#<pre><code>.WithRetryPolicy(new RetryPolicy\n{\n    MaximumAttempts = 3,\n    InitialInterval = TimeSpan.FromSeconds(10),\n    BackoffCoefficient = 2.0\n})\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#3-use-timezones-for-user-facing-schedules","title":"3. Use Timezones for User-Facing Schedules","text":"C#<pre><code>.Daily(hour: 9, timezone: \"America/New_York\")\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#4-check-existence-for-idempotency","title":"4. Check Existence for Idempotency","text":"C#<pre><code>if (!await workflow.Schedules!.ExistsAsync(\"my-schedule\"))\n{\n    await workflow.Schedules!.Create(\"my-schedule\")...StartAsync();\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#5-use-meaningful-schedule-ids","title":"5. Use Meaningful Schedule IDs","text":"C#<pre><code>.Create($\"daily-sync-{companyId}\")  // Good\n.Create(\"schedule1\")                // Bad\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#6-add-metadata-with-memo","title":"6. Add Metadata with Memo","text":"C#<pre><code>.WithMemo(new Dictionary&lt;string, object&gt;\n{\n    { \"owner\", \"team-name\" },\n    { \"purpose\", \"data-sync\" }\n})\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#7-set-appropriate-timeouts","title":"7. Set Appropriate Timeouts","text":"C#<pre><code>.WithTimeout(TimeSpan.FromHours(2))\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#8-use-descriptive-pause-notes","title":"8. Use Descriptive Pause Notes","text":"C#<pre><code>await schedule.PauseAsync(\"Database migration - ETA 2 hours\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#conclusion","title":"Conclusion","text":"<p>Xians scheduling provides production-grade time-based automation for AI agents with:</p> <ul> <li>Flexible scheduling - Cron, intervals, calendars, convenience methods</li> <li>Production features - Retries, timeouts, overlap policies</li> <li>Multi-tenant security - Automatic isolation and filtering</li> <li>Developer experience - Fluent API, auto-determinism, zero config</li> <li>Enterprise reliability - Built on Temporal's proven scheduling engine</li> </ul> <p>Use schedules to transform reactive agents into autonomous, proactive systems that operate on your timeline.</p> <p>Next Steps:</p> <ul> <li>Scheduling Concepts - Quick start guide</li> <li>Agents - Agent architecture</li> </ul>"},{"location":"server/encryption/","title":"Chat Message Encryption","text":"<p>All chat messages stored in the database are encrypted at rest to ensure data privacy and security. This encryption is mandatory and complies with the EU AI Act requirements for data protection in AI systems.</p>"},{"location":"server/encryption/#encryption-overview","title":"Encryption Overview","text":"<p>The system uses AES encryption to secure all conversation messages before storing them in the database. Each message is encrypted using a combination of:</p> <ul> <li>A base secret key for foundational encryption</li> <li>A unique conversation message key for additional security layers</li> </ul> <p>This dual-key approach ensures that even if one key is compromised, the data remains protected.</p>"},{"location":"server/encryption/#eu-ai-act-compliance","title":"EU AI Act Compliance","text":"<p>Under the EU AI Act, AI systems that process personal data must implement appropriate technical and organizational measures to ensure data protection. Message encryption is a critical requirement for:</p> <ul> <li>Data Minimization: Only encrypted data is stored, limiting exposure</li> <li>Security by Design: Encryption is built into the system architecture</li> <li>Data Protection: Personal conversations are protected against unauthorized access</li> <li>Transparency: Users can be assured their messages are encrypted</li> </ul>"},{"location":"server/encryption/#environment-configuration","title":"Environment Configuration","text":"<p>Important: The encryption keys must be configured in your environment before the system can encrypt and store messages. Without proper key configuration, the system cannot function securely.</p>"},{"location":"server/encryption/#required-environment-variables","title":"Required Environment Variables","text":"<p>Configure the following encryption keys in your environment:</p> Text Only<pre><code># Base encryption secret - use a long, random string (minimum 32 characters)\nEncryptionKeys__BaseSecret=&lt;LONG_RANDOM_BASE_SECRET&gt;\n\n# Conversation message encryption key - unique secret for chat messages\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=&lt;UNIQUE_SECRET_FOR_MESSAGES&gt;\n</code></pre>"},{"location":"server/encryption/#key-generation-guidelines","title":"Key Generation Guidelines","text":"<ul> <li>Base Secret: Generate a cryptographically secure random string of at least 32 characters</li> <li>Message Key: Use a different random string, also minimum 32 characters</li> <li>Security: Never reuse keys across different environments (dev/staging/prod)</li> <li>Storage: Store keys securely using your organization's secret management system</li> </ul>"},{"location":"server/encryption/#example-configuration","title":"Example Configuration","text":"Bash<pre><code># Generate secure keys (Linux/macOS)\nopenssl rand -base64 32\n\n# Example .env configuration\nEncryptionKeys__BaseSecret=YourSecureBase64EncodedSecretKeyHere123456789\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=AnotherSecureRandomKeyForMessages987654321\n</code></pre>"},{"location":"server/encryption/#security-considerations","title":"Security Considerations","text":"<ul> <li>Key Rotation: Regularly rotate encryption keys according to your security policy</li> <li>Access Control: Limit access to encryption keys to authorized personnel only</li> <li>Backup: Ensure encryption keys are included in your secure backup procedures</li> <li>Monitoring: Monitor for any unauthorized access attempts to encrypted data</li> </ul>"},{"location":"server/encryption/#troubleshooting","title":"Troubleshooting","text":"<p>\"Encryption keys not configured\": Ensure both <code>BaseSecret</code> and <code>ConversationMessageKey</code> are set in your environment</p> <p>\"Unable to decrypt messages\": Verify that the same encryption keys used to encrypt the data are being used for decryption</p> <p>\"Key format invalid\": Ensure keys are properly base64 encoded and meet minimum length requirements</p>"},{"location":"server/scaling/","title":"Scaling","text":"<p>The Xians platform provides flexible scaling options to handle varying workloads efficiently. You can scale both horizontally (multiple agent instances) and vertically (workers per workflow), with the platform automatically handling distribution and fault tolerance through Temporal.</p>"},{"location":"server/scaling/#horizontal-scaling---multiple-agent-instances","title":"Horizontal Scaling - Multiple Agent Instances","text":"<p>You can spawn any number of agent console applications, and the platform automatically takes care of scaling and fault tolerance of agent runtimes. This is handled through Temporal workers and activity distribution.</p>"},{"location":"server/scaling/#how-it-works","title":"How It Works","text":"<p>When you start multiple instances of the same agent application:</p> <ol> <li>Each instance registers as a Temporal worker for the same task queue</li> <li>Temporal automatically distributes workflow executions and activities across all available workers</li> <li>If one instance fails, Temporal redistributs work to healthy instances</li> <li>No configuration changes needed - just start more instances</li> </ol>"},{"location":"server/scaling/#example","title":"Example","text":"Bash<pre><code># Terminal 1\ndotnet run --project MyAgent\n\n# Terminal 2\ndotnet run --project MyAgent\n\n# Terminal 3\ndotnet run --project MyAgent\n</code></pre> <p>All three instances will:</p> <ul> <li>Share the workload automatically</li> <li>Provide fault tolerance (if one crashes, others continue)</li> <li>Scale processing capacity linearly</li> </ul>"},{"location":"server/scaling/#benefits","title":"Benefits","text":"<ul> <li>Automatic Load Distribution: Temporal handles work distribution across all instances</li> <li>Fault Tolerance: Failed instances don't cause workflow failures</li> <li>Zero Configuration: No changes to code or configuration required</li> <li>Linear Scaling: More instances = more processing capacity</li> </ul>"},{"location":"server/scaling/#vertical-scaling---workers-per-workflow","title":"Vertical Scaling - Workers per Workflow","text":"<p>Within a single agent instance, you can configure the number of maxConcurrent per workflow to handle concurrent executions. This is specified when defining workflows.</p>"},{"location":"server/scaling/#built-in-workflows","title":"Built-In Workflows","text":"<p>Use the <code>maxConcurrent</code> parameter in <code>DefineBuiltIn()</code>:</p> C#<pre><code>// Single worker (default)\nagent.Workflows.DefineBuiltIn();\n\n// Multiple maxConcurrent for concurrent executions\nagent.Workflows.DefineBuiltIn(name: \"Data Processor Workflow\", maxConcurrent: 200);\n</code></pre>"},{"location":"server/scaling/#custom-workflows","title":"Custom Workflows","text":"<p>Use the <code>maxConcurrent</code> parameter in <code>DefineCustom&lt;T&gt;()</code>:</p> C#<pre><code>// Single worker (default)\nagent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;();\n\n// Multiple maxConcurrent for concurrent executions\nagent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;(maxConcurrent: 5);\n</code></pre>"},{"location":"server/scaling/#example-multi-workflow-agent","title":"Example: Multi-Workflow Agent","text":"C#<pre><code>var agent = platform.Agents.DefineAgent(\"DataPipeline\");\n\n// Low concurrency workflow\nagent.Workflows.DefineBuiltIn(name: \"Coordinator\", maxConcurrent: 2);\n\n// High concurrency workflow for data processing\nagent.Workflows.DefineBuiltIn(name: \"Processor\", maxConcurrent: 20);\n\n// Custom workflow with moderate concurrency\nagent.Workflows.DefineCustom&lt;ValidationWorkflow&gt;(maxConcurrent: 10);\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"server/scaling/#combining-horizontal-and-vertical-scaling","title":"Combining Horizontal and Vertical Scaling","text":"<p>You can combine both scaling strategies for maximum flexibility:</p> C#<pre><code>// Define agent with 10 maxConcurrent per workflow\nvar agent = platform.Agents.DefineAgent(\"HighThroughputAgent\");\nagent.Workflows.DefineBuiltIn(maxConcurrent: 10);\n\nawait agent.RunAsync();\n</code></pre> <p>Then spawn 5 instances:</p> <ul> <li>Total capacity: 5 instances \u00d7 10 maxConcurrent = 50 concurrent executions</li> <li>Fault tolerance: If 2 instances fail, 30 maxConcurrent still available</li> <li>Flexible scaling: Add/remove instances as needed</li> </ul>"},{"location":"server/scaling/#auto-scaling-based-on-queue-metrics","title":"Auto Scaling Based on Queue Metrics","text":"<p>For dynamic scaling scenarios, you can monitor the Temporal queue size to automatically adjust the number of workers. This approach enables responsive scaling based on actual workload demand.</p>"},{"location":"server/scaling/#monitoring-queue-size-for-auto-scaling","title":"Monitoring Queue Size for Auto Scaling","text":"<p>Temporal provides metrics that allow you to monitor the backlog of pending workflow executions and activities. By tracking these metrics, you can implement auto-scaling logic to spawn or terminate agent instances based on demand.</p>"},{"location":"server/scaling/#implementation-approaches","title":"Implementation Approaches","text":""},{"location":"server/scaling/#1-external-monitoring-service","title":"1. External Monitoring Service","text":"<p>Set up a monitoring service that:</p> <ul> <li>Queries Temporal metrics API for queue depth</li> <li>Compares against threshold values</li> <li>Triggers scaling actions (e.g., Kubernetes HPA, AWS Auto Scaling)</li> </ul> Bash<pre><code># Example: Query Temporal metrics (pseudo-code)\ncurl http://temporal:9090/metrics | grep temporal_task_queue_depth\n</code></pre>"},{"location":"server/scaling/#2-kubernetes-horizontal-pod-autoscaler-hpa","title":"2. Kubernetes Horizontal Pod Autoscaler (HPA)","text":"<p>Use Kubernetes HPA with custom metrics:</p> YAML<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: xians-agent-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: xians-agent\n  minReplicas: 2\n  maxReplicas: 20\n  metrics:\n  - type: External\n    external:\n      metric:\n        name: temporal_task_queue_backlog\n        selector:\n          matchLabels:\n            queue: \"DataPipeline:BuiltIn Workflow\"\n      target:\n        type: AverageValue\n        averageValue: \"10\"  # Scale up if &gt;10 tasks per pod\n</code></pre>"},{"location":"server/scaling/#3-programmatic-monitoring","title":"3. Programmatic Monitoring","text":"<p>Implement custom auto-scaling logic:</p> C#<pre><code>// Pseudo-code example\npublic class AutoScaler\n{\n    public async Task MonitorAndScale(CancellationToken ct)\n    {\n        while (!ct.IsCancellationRequested)\n        {\n            var queueDepth = await GetTemporalQueueDepth();\n\n            if (queueDepth &gt; 100)\n            {\n                // High load - signal to spawn more instances\n                await ScaleUp();\n            }\n            else if (queueDepth &lt; 10)\n            {\n                // Low load - signal to reduce instances\n                await ScaleDown();\n            }\n\n            await Task.Delay(TimeSpan.FromSeconds(30), ct);\n        }\n    }\n}\n</code></pre>"},{"location":"server/scaling/#auto-scaling-metrics-to-monitor","title":"Auto Scaling Metrics to Monitor","text":"<ul> <li>Task Queue Depth: Number of pending workflow/activity executions</li> <li>Worker Utilization: Percentage of busy workers</li> <li>Execution Rate: Workflows started vs completed per minute</li> <li>Latency: Time from workflow start to first activity execution</li> </ul>"},{"location":"server/scaling/#best-practices-for-auto-scaling","title":"Best Practices for Auto Scaling","text":"<ol> <li>Set Appropriate Thresholds</li> <li>Scale up before queues become too large</li> <li>Scale down gradually to avoid thrashing</li> <li> <p>Consider time-of-day patterns</p> </li> <li> <p>Implement Cooldown Periods</p> </li> <li>Wait before scaling again (e.g., 5 minutes)</li> <li> <p>Prevents rapid scaling oscillations</p> </li> <li> <p>Monitor Both Queue and Resource Utilization</p> </li> <li>Don't just scale on queue depth</li> <li> <p>Consider CPU, memory, and network metrics</p> </li> <li> <p>Test Scaling Behavior</p> </li> <li>Simulate high load scenarios</li> <li>Verify graceful scale-down behavior</li> <li> <p>Ensure no workflow failures during scaling</p> </li> <li> <p>Set Min/Max Boundaries</p> </li> <li>Minimum instances for availability</li> <li>Maximum instances for cost control</li> </ol>"},{"location":"server/scaling/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"server/scaling/#resource-limits","title":"Resource Limits","text":"<ul> <li>Memory: Each worker consumes memory; ensure adequate RAM</li> <li>CPU: More workers = more CPU usage</li> <li>Connections: Each worker maintains Temporal connections</li> </ul>"},{"location":"server/scaling/#temporal-configuration","title":"Temporal Configuration","text":"<p>Ensure your Temporal cluster can handle the load:</p> <ul> <li>Adequate history service capacity</li> <li>Sufficient matching service resources</li> <li>Properly sized persistence layer</li> </ul>"},{"location":"server/scaling/#network-latency","title":"Network Latency","text":"<ul> <li>Workers in different regions may have higher latency</li> <li>Consider deploying Temporal workers close to Temporal server</li> </ul>"},{"location":"server/scaling/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Start with fewer workers and scale up as needed</li> <li>Monitor actual utilization vs provisioned capacity</li> <li>Use auto-scaling to optimize costs during low-traffic periods</li> </ul>"},{"location":"server/scaling/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>Track these metrics to optimize scaling:</p> <ul> <li>Workflow Execution Rate: Throughput per worker/instance</li> <li>Queue Latency: Time tasks wait before execution</li> <li>Worker Utilization: Percentage of workers actively processing</li> <li>Failure Rate: Failed executions (may indicate overload)</li> </ul> <p>Use Temporal's built-in metrics and integrate with your monitoring stack (Prometheus, Grafana, etc.) for comprehensive observability.</p>"},{"location":"server/scaling/#summary","title":"Summary","text":"Scaling Type Method Use Case Configuration Horizontal Multiple instances High availability, fault tolerance Just spawn more processes Vertical Workers per workflow Concurrent executions within instance <code>maxConcurrent</code> parameter Auto Scaling Queue-based scaling Dynamic workload adaptation External monitoring + orchestration <p>The Xians platform's integration with Temporal provides powerful, flexible scaling capabilities with minimal configuration. Start simple and scale as your workload demands.</p>"},{"location":"user-guide/overview/","title":"User Guide Overview","text":"<p>Welcome to the Xians.ai User Guide. This comprehensive guide will help you master agent development with Xians.ai.</p>"},{"location":"user-guide/overview/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers everything you need to know to build production-ready AI agents:</p> <ul> <li>Agent Architecture - Understanding how agents work</li> <li>Development Workflow - Best practices for agent development</li> <li>Deployment - Taking your agents to production</li> <li>Monitoring &amp; Debugging - Keeping your agents healthy</li> <li>Advanced Topics - Multi-agent systems, workflows, and more</li> </ul>"},{"location":"user-guide/overview/#getting-started","title":"Getting Started","text":"<p>If you're new to Xians.ai, we recommend following this learning path:</p> <ol> <li>Installation - Set up your environment</li> <li>Quick Start - Create your first agent</li> <li>Configuration - Learn about configuration options</li> </ol>"},{"location":"user-guide/overview/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/overview/#agents","title":"Agents","text":"<p>Agents are autonomous AI systems that can:</p> <ul> <li>Understand natural language</li> <li>Execute tasks and workflows</li> <li>Learn from interactions</li> <li>Collaborate with other agents</li> </ul>"},{"location":"user-guide/overview/#capabilities","title":"Capabilities","text":"<p>Capabilities are specific skills or functions that agents can perform:</p> Python<pre><code>@capability(description=\"Send email to user\")\ndef send_email(self, to: str, subject: str, body: str) -&gt; bool:\n    # Implementation\n    return True\n</code></pre>"},{"location":"user-guide/overview/#workflows","title":"Workflows","text":"<p>Workflows orchestrate multiple agent capabilities into complex processes:</p> Python<pre><code>workflow = Workflow(\"customer_onboarding\")\nworkflow.add_step(\"verify_email\")\nworkflow.add_step(\"create_account\")\nworkflow.add_step(\"send_welcome\")\n</code></pre>"},{"location":"user-guide/overview/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD\n    A[User] --&gt;|Request| B[Agent]\n    B --&gt;|Process| C[LLM]\n    C --&gt;|Response| B\n    B --&gt;|Execute| D[Capabilities]\n    D --&gt;|Result| B\n    B --&gt;|Reply| A</code></pre>"},{"location":"user-guide/overview/#development-workflow","title":"Development Workflow","text":""},{"location":"user-guide/overview/#1-design","title":"1. Design","text":"<ul> <li>Define agent purpose and capabilities</li> <li>Identify required integrations</li> <li>Plan conversation flows</li> </ul>"},{"location":"user-guide/overview/#2-implement","title":"2. Implement","text":"<ul> <li>Create agent class</li> <li>Define capabilities</li> <li>Configure LLM and settings</li> </ul>"},{"location":"user-guide/overview/#3-test","title":"3. Test","text":"<ul> <li>Unit test capabilities</li> <li>Integration testing</li> <li>User acceptance testing</li> </ul>"},{"location":"user-guide/overview/#4-deploy","title":"4. Deploy","text":"<ul> <li>Production configuration</li> <li>Monitoring setup</li> <li>Gradual rollout</li> </ul>"},{"location":"user-guide/overview/#best-practices","title":"Best Practices","text":"<p>Development Best Practices</p> <ul> <li>Start simple and iterate</li> <li>Test thoroughly before deployment</li> <li>Monitor agent performance</li> <li>Keep capabilities focused and modular</li> <li>Document your agent's behavior</li> </ul> <p>Common Pitfalls</p> <ul> <li>Overly complex initial implementations</li> <li>Insufficient error handling</li> <li>Poor testing coverage</li> <li>Inadequate monitoring</li> </ul>"},{"location":"user-guide/overview/#next-steps","title":"Next Steps","text":"<p>Explore specific topics:</p> <ul> <li>Agent Development - Detailed agent development guide</li> <li>Capabilities - Creating custom capabilities</li> <li>Workflows - Building complex workflows</li> <li>Deployment - Production deployment guide</li> <li>Monitoring - Observability and debugging</li> </ul>"},{"location":"user-guide/overview/#community--support","title":"Community &amp; Support","text":"<ul> <li>Discord Community - Get help and share ideas</li> <li>GitHub Discussions - Ask questions</li> <li>Examples - Sample projects</li> <li>Blog - Latest updates and tutorials</li> </ul>"}]}