{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Control Plane for AI Agents","text":"<p>  Build agents with whatever framework you like - Azure AI, Bedrock, Semantic Kernel, LangGraph, or your own custom runtime. Xians doesn't dictate how your agents think - it handles the plumbing that becomes painful once agents graduate beyond the demos. Multi-tenancy, human-in-the-loop workflows, long-running processes, scheduling, external triggers, agent-to-agent collaboration, scalability, fault tolerance, and observability. The complete control plane you need but would never want to build yourself.   </p> Get Started Introduction"},{"location":"#quick-links","title":"Quick Links","text":""},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Getting Started - Set up your development environment and create your first agent</li> <li>User Guide - Comprehensive guides for building and deploying agents</li> <li>API Reference - Detailed API documentation</li> <li>Contributing - Learn how to contribute to the project</li> </ul>"},{"location":"#useful-resources","title":"Useful Resources","text":"<ul> <li>GitHub Organization</li> <li>Discord Community</li> <li>Official Website</li> </ul>"},{"location":"api-reference/overview/","title":"API Reference Overview","text":""},{"location":"concepts/agents/","title":"Agents","text":""},{"location":"concepts/agents/#build-anywhere-manage-everywhere","title":"Build Anywhere, Manage Everywhere","text":"<p>Xians takes a fundamentally different approach to AI agents. We don't lock you into a proprietary framework or force you to rebuild your agents. Instead, Xians is an agent management and operational platform that lets you build agents with any framework you choose\u2014Microsoft Agent Framework (MAF), LangChain, Semantic Kernel, or even raw OpenAI SDK\u2014and provides the production-grade infrastructure to deploy, manage, and scale them.</p>"},{"location":"concepts/agents/#the-problem-xians-solves","title":"The Problem Xians Solves","text":"<p>Building an AI agent is one thing. Operating it in production is another entirely.</p>"},{"location":"concepts/agents/#the-challenge-with-agent-frameworks","title":"The Challenge with Agent Frameworks","text":"<p>Most agent frameworks focus on the development experience:</p> <ul> <li>They help you build sophisticated reasoning loops</li> <li>They provide tools and prompt management</li> <li>They offer local testing and debugging</li> </ul> <p>But when you're ready for production, you face critical questions:</p> <ul> <li>How do I deploy multiple agents across different tenants?</li> <li>How do I handle message routing and conversation state?</li> <li>How do I schedule agent tasks and manage workflows?</li> <li>How do I monitor performance and handle failures?</li> <li>How do I integrate with my existing systems via webhooks and APIs?</li> </ul> <p>This is where Xians comes in.</p>"},{"location":"concepts/agents/#xians-your-agent-management-plane","title":"Xians: Your Agent Management Plane","text":"<p>Think of Xians as the control plane for your AI agents\u2014the operational infrastructure that sits between your agent logic and your users, handling all the complexity of production deployment.</p>"},{"location":"concepts/agents/#what-xians-provides","title":"What Xians Provides","text":"<p>1. Agent Registration &amp; Identity</p> <p>Your agents, built with any framework, register with Xians to get:</p> <ul> <li>Unique identity and authentication</li> <li>Tenant isolation and multi-tenancy support</li> <li>System or tenant-scoped deployment options</li> </ul> <p>2. Message &amp; Conversation Management</p> <ul> <li>Automatic message routing to the right agent</li> <li>Conversation threading and context management</li> <li>User message queuing and delivery guarantees</li> </ul> <p>3. Workflow Orchestration</p> <ul> <li>Built-in workflows for common patterns</li> <li>Custom workflow definitions for complex logic</li> <li>Worker management and scaling</li> </ul> <p>4. Scheduling Infrastructure</p> <ul> <li>Cron-based and interval schedules</li> <li>Time-based agent activation</li> <li>Automatic schedule lifecycle management</li> </ul> <p>5. Integration &amp; Connectivity</p> <ul> <li>Webhook triggers and callbacks</li> <li>Event streaming and notifications</li> <li>API-first architecture for external systems</li> </ul>"},{"location":"concepts/agents/#core-architecture","title":"Core Architecture","text":""},{"location":"concepts/agents/#the-separation-of-concerns","title":"The Separation of Concerns","text":"<p>Xians embraces a clean architectural principle:</p> <p>Your Code (Agent Logic)</p> <ul> <li>Build with ANY framework: MAF, LangChain, Semantic Kernel, OpenAI SDK</li> <li>Implement your AI reasoning, tools, and business logic</li> <li>Test and iterate locally with your preferred tooling</li> </ul> <p>Xians Platform (Operations)</p> <ul> <li>Register your agent with Xians</li> <li>Define workflows and message handlers</li> <li>Configure schedules and integrations</li> <li>Deploy and scale across tenants</li> </ul>"},{"location":"concepts/agents/#agent-registration-model","title":"Agent Registration Model","text":"C#<pre><code>// Initialize connection to Xians platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new XiansOptions\n{\n    ServerUrl = \"https://your-xians-instance.com\",\n    ApiKey = xiansApiKey  // Includes tenant context\n});\n\n// Register your agent (built with ANY framework)\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"CustomerSupportAgent\",\n    SystemScoped = true  // or tenant-scoped\n});\n</code></pre>"},{"location":"concepts/agents/#quick-start-connecting-your-agent","title":"Quick Start: Connecting Your Agent","text":"<p>Here's how you connect an agent built with any framework to Xians:</p>"},{"location":"concepts/agents/#step-1-build-your-agent-logic","title":"Step 1: Build Your Agent Logic","text":"<p>Use your preferred framework to implement the AI logic:</p> C#<pre><code>// Your agent implementation - use ANY framework!\n// This example uses OpenAI SDK, but could be MAF, LangChain, etc.\npublic class ConversationalAgent\n{\n    public static async Task&lt;string&gt; ProcessMessageAsync(\n        IUserMessageContext context, \n        string openAiApiKey)\n    {\n        // Your AI logic here - framework agnostic\n        var client = new OpenAIClient(openAiApiKey);\n        var response = await client.GetChatCompletionAsync(\n            model: \"gpt-4\",\n            messages: BuildMessages(context)\n        );\n\n        return response.Content;\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#step-2-register-with-xians--define-workflows","title":"Step 2: Register with Xians &amp; Define Workflows","text":"<p>Connect your agent to Xians operational infrastructure:</p> C#<pre><code>// Register the agent\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"CustomerSupportAgent\",\n    SystemScoped = true\n});\n\n// Define workflow for handling user messages\nvar conversationalWorkflow = agent.Workflows.DefineBuiltIn(\n    name: \"Conversational\", \n    workers: 1\n);\n\n// Connect your agent logic to the workflow\nconversationalWorkflow.OnUserMessage(async (context) =&gt;\n{\n    // Call YOUR agent implementation (any framework)\n    var response = await ConversationalAgent.ProcessMessageAsync(\n        context, \n        openAiApiKey\n    );\n\n    // Xians handles message delivery, threading, and state\n    await context.ReplyAsync(response);\n});\n</code></pre>"},{"location":"concepts/agents/#step-3-add-schedules-optional","title":"Step 3: Add Schedules (Optional)","text":"<p>Enable time-based agent activation:</p> C#<pre><code>// Define a custom workflow for scheduled tasks\nvar scheduledWorkflow = agent.Workflows.DefineCustom&lt;DailyReportWorkflow&gt;(\n    workers: 1\n);\n\n// Xians automatically provides schedule infrastructure\n// Your workflow can create schedules using built-in activities:\nawait scheduledWorkflow.Schedules\n    .Create(\"daily-report\")\n    .WithCronSchedule(\"0 9 * * *\")  // 9 AM daily\n    .StartAsync();\n</code></pre>"},{"location":"concepts/agents/#step-4-run-your-agent","title":"Step 4: Run Your Agent","text":"C#<pre><code>// Start all workflows - Xians handles message routing, \n// scaling, and operational concerns\nawait agent.RunAllAsync();\n</code></pre>"},{"location":"concepts/agents/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"concepts/agents/#pattern-1-multi-workflow-agent","title":"Pattern 1: Multi-Workflow Agent","text":"<p>One agent, multiple specialized workflows.</p> C#<pre><code>// Single agent with different workflows for different use cases\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"CustomerServiceHub\",\n    SystemScoped = true\n});\n\n// Conversational workflow for chat interactions\nvar chatWorkflow = agent.Workflows.DefineBuiltIn(\"Conversational\", workers: 3);\n\n// Web workflow for web-based interactions\nvar webWorkflow = agent.Workflows.DefineBuiltIn(\"Web\", workers: 2);\n\n// Custom workflow for background research\nvar researchWorkflow = agent.Workflows.DefineCustom&lt;ResearchWorkflow&gt;(workers: 1);\n</code></pre> <p>Use Case: Different interaction patterns for the same logical agent (chat, web, scheduled tasks).</p>"},{"location":"concepts/agents/#pattern-2-multi-tenant-deployment","title":"Pattern 2: Multi-Tenant Deployment","text":"<p>Same agent logic, isolated per tenant.</p> C#<pre><code>// System-scoped agent serves ALL tenants\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"SharedAssistant\",\n    SystemScoped = true  // Xians handles tenant isolation\n});\n\n// Each tenant gets isolated conversations, data, and context\n// Your agent logic remains the same\nconversationalWorkflow.OnUserMessage(async (context) =&gt;\n{\n    // context.TenantId automatically provided by Xians\n    var response = await ProcessWithTenantContext(context);\n    await context.ReplyAsync(response);\n});\n</code></pre> <p>Use Case: SaaS applications where each customer needs their own agent instance.</p>"},{"location":"concepts/agents/#pattern-3-framework-agnostic","title":"Pattern 3: Framework Agnostic","text":"<p>Mix and match frameworks in the same deployment.</p> C#<pre><code>// One workflow using Microsoft Agent Framework\nvar mafWorkflow = agent.Workflows.DefineBuiltIn(\"MAF-Powered\", workers: 1);\nmafWorkflow.OnUserMessage(async (context) =&gt;\n{\n    var response = await MyMAFAgent.ProcessAsync(context);\n    await context.ReplyAsync(response);\n});\n\n// Another workflow using LangChain\nvar langchainWorkflow = agent.Workflows.DefineBuiltIn(\"LangChain-Powered\", workers: 1);\nlangchainWorkflow.OnUserMessage(async (context) =&gt;\n{\n    var response = await MyLangChainAgent.ProcessAsync(context);\n    await context.ReplyAsync(response);\n});\n</code></pre> <p>Use Case: Evaluate different frameworks or use the best tool for each specific task.</p>"},{"location":"concepts/agents/#why-this-architecture-matters","title":"Why This Architecture Matters","text":""},{"location":"concepts/agents/#the-old-way-diy-everything","title":"The Old Way: DIY Everything","text":"Text Only<pre><code>Agent Logic + Message Queues + State Management + Scheduling + \nTenant Isolation + Monitoring + Scaling + Deployment + ...\n</code></pre> <p>Result: Months building infrastructure instead of agent capabilities.</p>"},{"location":"concepts/agents/#the-xians-way-focus-on-your-agent","title":"The Xians Way: Focus on Your Agent","text":"Text Only<pre><code>Your Agent Logic (any framework) \u2192 Xians Platform (handles everything else)\n</code></pre> <p>Result: Production-ready deployment in hours, not months.</p>"},{"location":"concepts/agents/#real-world-example","title":"Real-World Example","text":""},{"location":"concepts/agents/#before-xians-the-infrastructure-nightmare","title":"Before Xians: The Infrastructure Nightmare","text":"C#<pre><code>// Build your agent\nvar agent = new MyAIAgent();\n\n// Now build everything else...\nvar messageQueue = await SetupRabbitMQ();\nvar stateStore = await SetupRedis();\nvar scheduler = await SetupHangfire();\n\n// Handle message routing manually\nawait messageQueue.Subscribe(\"user-messages\", async msg =&gt;\n{\n    // Parse tenant context\n    var tenantId = ExtractTenant(msg);\n\n    // Load conversation state\n    var state = await stateStore.GetConversationState(msg.ThreadId);\n\n    // Process with agent\n    var response = await agent.Process(msg, state);\n\n    // Save state\n    await stateStore.SaveConversationState(msg.ThreadId, state);\n\n    // Send response\n    await SendToUser(response, tenantId);\n});\n\n// Setup scheduled tasks manually\nawait scheduler.Schedule(() =&gt; \n{\n    // Figure out which tenant, which agent, which context...\n    await agent.PerformScheduledTask();\n}, \"0 9 * * *\");\n\n// And we haven't even touched deployment, scaling, monitoring...\n</code></pre>"},{"location":"concepts/agents/#with-xians-focus-on-agent-logic","title":"With Xians: Focus on Agent Logic","text":"C#<pre><code>// 1. Build your agent with ANY framework\npublic class MyAgent\n{\n    public static async Task&lt;string&gt; ProcessAsync(\n        IUserMessageContext context,\n        string apiKey)\n    {\n        // Your AI logic here - use MAF, LangChain, whatever you want\n        return await YourFramework.Process(context.Message);\n    }\n}\n\n// 2. Connect to Xians\nvar xians = await XiansPlatform.InitializeAsync(options);\nvar agent = xians.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"MyAgent\",\n    SystemScoped = true\n});\n\n// 3. Define workflow and connect your logic\nvar workflow = agent.Workflows.DefineBuiltIn(\"Conversational\", workers: 1);\nworkflow.OnUserMessage(async (context) =&gt;\n{\n    // Xians automatically provides:\n    // - Tenant context (context.TenantId)\n    // - Conversation threading (context.ThreadId)\n    // - Message delivery guarantees\n    // - State management\n\n    var response = await MyAgent.ProcessAsync(context, apiKey);\n    await context.ReplyAsync(response);\n});\n\n// 4. Run it\nawait agent.RunAllAsync();\n\n// That's it. Xians handles:\n// \u2705 Message routing and queuing\n// \u2705 Conversation state and threading\n// \u2705 Tenant isolation\n// \u2705 Scaling and worker management\n// \u2705 Scheduled task infrastructure\n// \u2705 Webhook integration\n// \u2705 Monitoring and health checks\n</code></pre>"},{"location":"concepts/agents/#framework-compatibility","title":"Framework Compatibility","text":"<p>Xians is 100% framework agnostic. Build with:</p>"},{"location":"concepts/agents/#microsoft-agent-framework-maf","title":"Microsoft Agent Framework (MAF)","text":"C#<pre><code>// Your MAF agent\nvar mafAgent = new AgentBuilder()\n    .WithModel(\"gpt-4\")\n    .WithTools(...)\n    .Build();\n\n// Connect to Xians\nworkflow.OnUserMessage(async (context) =&gt;\n{\n    var response = await mafAgent.ExecuteAsync(context.Message);\n    await context.ReplyAsync(response);\n});\n</code></pre>"},{"location":"concepts/agents/#langchain","title":"LangChain","text":"Python<pre><code># Your LangChain agent\nfrom langchain.agents import create_openai_functions_agent\n\nagent = create_openai_functions_agent(llm, tools, prompt)\n\n# Connect to Xians via SDK\n@workflow.on_user_message\nasync def handle(context):\n    response = await agent.ainvoke({\"input\": context.message})\n    await context.reply(response)\n</code></pre>"},{"location":"concepts/agents/#semantic-kernel","title":"Semantic Kernel","text":"C#<pre><code>// Your SK agent\nvar kernel = Kernel.CreateBuilder()\n    .AddOpenAIChatCompletion(...)\n    .Build();\n\n// Connect to Xians\nworkflow.OnUserMessage(async (context) =&gt;\n{\n    var response = await kernel.InvokeAsync(context.Message);\n    await context.ReplyAsync(response);\n});\n</code></pre>"},{"location":"concepts/agents/#raw-openai-sdk","title":"Raw OpenAI SDK","text":"C#<pre><code>// Direct OpenAI calls\nvar openAI = new OpenAIClient(apiKey);\n\nworkflow.OnUserMessage(async (context) =&gt;\n{\n    var response = await openAI.GetChatCompletionAsync(...);\n    await context.ReplyAsync(response.Content);\n});\n</code></pre>"},{"location":"concepts/agents/#best-practices","title":"Best Practices","text":"<p>\u2705 DO:</p> <ul> <li>Choose the right framework for your agent logic\u2014Xians supports them all</li> <li>Use SystemScoped for multi-tenant deployments</li> <li>Leverage workflows to separate concerns (chat vs. scheduled tasks vs. web interactions)</li> <li>Let Xians manage state instead of building your own infrastructure</li> <li>Use built-in schedules for time-based agent activation</li> <li>Test locally with your framework, then deploy to Xians for production</li> </ul> <p>\u274c DON'T:</p> <ul> <li>Build your own message queues\u2014Xians provides production-ready infrastructure</li> <li>Mix operational concerns with agent logic\u2014keep them separate</li> <li>Ignore tenant context\u2014always use <code>context.TenantId</code> for isolation</li> <li>Hardcode credentials\u2014use environment variables and Xians authentication</li> <li>Skip error handling in your agent logic\u2014Xians handles delivery, but your logic should be robust</li> </ul>"},{"location":"concepts/agents/#key-benefits-of-the-xians-approach","title":"Key Benefits of the Xians Approach","text":""},{"location":"concepts/agents/#-framework-freedom","title":"\ud83c\udfa8 Framework Freedom","text":"<p>Build with MAF today, switch to LangChain tomorrow. Xians doesn't care\u2014it manages operations, not your AI logic.</p>"},{"location":"concepts/agents/#-production-infrastructure","title":"\ud83c\udfd7\ufe0f Production Infrastructure","text":"<p>Message routing, state management, scheduling, tenant isolation\u2014all handled by Xians out of the box.</p>"},{"location":"concepts/agents/#-built-in-scaling","title":"\ud83d\udcc8 Built-in Scaling","text":"<p>Configure worker counts per workflow. Xians automatically manages load distribution and scaling.</p>"},{"location":"concepts/agents/#-multi-tenancy-by-default","title":"\ud83d\udd12 Multi-Tenancy by Default","text":"<p>Deploy once, serve many tenants with complete data isolation and security.</p>"},{"location":"concepts/agents/#-rapid-development","title":"\u26a1 Rapid Development","text":"<p>Focus on agent capabilities, not infrastructure. Get to production in hours, not months.</p>"},{"location":"concepts/agents/#going-deeper","title":"Going Deeper","text":"<p>Your agents become even more powerful when you leverage Xians' full operational platform:</p> <ul> <li>Workflows: Orchestrate complex agent processes with built-in and custom workflows</li> <li>Messages: Rich, stateful communication with automatic threading and context management</li> <li>Knowledge: Connect agents to your data with the document database</li> <li>Schedules: Time-based agent activation with cron and interval schedules</li> <li>Webhooks: Trigger agents from external events and systems</li> <li>Tenants: Multi-tenant deployment with complete isolation</li> </ul> <p>The Bottom Line: Xians is not an agent framework\u2014it's the operational platform that makes your agents production-ready. Build with any framework you love, deploy with infrastructure you trust.</p>"},{"location":"concepts/document-db/","title":"Document DB","text":""},{"location":"concepts/document-db/#flexible-data-storage-for-ai","title":"Flexible Data Storage for AI","text":"<p>Your agents need to remember things. Customer profiles, order history, session data, analytics\u2014structured information that doesn't fit neatly into prompts. Document DB gives your agents a schema-less, queryable memory that scales.</p>"},{"location":"concepts/document-db/#the-data-storage-problem","title":"The Data Storage Problem","text":"<p>Traditional Databases: Text Only<pre><code>Define rigid schema \u2192 Hope you got it right\nNeed a new field? \u2192 Migration script, downtime, anxiety\nNested data? \u2192 Junction tables, complex joins, headaches\n</code></pre></p> <p>Document DB: Text Only<pre><code>Store JSON documents \u2192 No schema needed\nNew field? \u2192 Just add it\nNested data? \u2192 Natural and simple\nQuery flexibly \u2192 Find exactly what you need\n</code></pre></p>"},{"location":"concepts/document-db/#why-document-db-matters-for-ai-development","title":"Why Document DB Matters for AI Development","text":""},{"location":"concepts/document-db/#the-challenge-agents-need-context-beyond-conversations","title":"The Challenge: Agents Need Context Beyond Conversations","text":"<p>AI agents are powerful, but they need structured data: - Customer context: Who are they? What's their history? - Session state: Where are we in a complex process? - Business data: Products, orders, inventory, analytics - Agent memory: Decisions made, actions taken</p>"},{"location":"concepts/document-db/#the-solution-schema-less-ai-friendly-storage","title":"The Solution: Schema-Less, AI-Friendly Storage","text":"<p>Document DB provides: - Flexible schema: Store any structure without migrations - Fast queries: Find data instantly with indexes - Tenant isolation: Automatic data separation - AI-native: Perfect for unstructured, evolving data</p>"},{"location":"concepts/document-db/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/document-db/#documents-are-just-json","title":"Documents Are Just JSON","text":"TypeScript<pre><code>// Customer document\n{\n  _id: \"cust_123\",\n  _collection: \"customers\",\n  _tenantId: \"acme-corp\",\n  _createdAt: \"2024-01-15T10:30:00Z\",\n\n  // Your data - any structure you want\n  name: \"Jane Smith\",\n  email: \"jane@example.com\",\n  plan: \"enterprise\",\n  tags: [\"vip\", \"early-adopter\"],\n  preferences: {\n    notifications: true,\n    theme: \"dark\"\n  },\n  purchaseHistory: [\n    { date: \"2024-01-10\", amount: 299.99 },\n    { date: \"2024-02-15\", amount: 499.99 }\n  ]\n}\n</code></pre>"},{"location":"concepts/document-db/#collections-organize-documents","title":"Collections Organize Documents","text":"Text Only<pre><code>Document DB\n\u251c\u2500\u2500 customers       \u2192 Customer profiles\n\u251c\u2500\u2500 orders          \u2192 Order history\n\u251c\u2500\u2500 sessions        \u2192 User sessions\n\u251c\u2500\u2500 agent-state     \u2192 Agent memory\n\u251c\u2500\u2500 products        \u2192 Product catalog\n\u2514\u2500\u2500 analytics       \u2192 Usage metrics\n</code></pre>"},{"location":"concepts/document-db/#quick-start","title":"Quick Start","text":""},{"location":"concepts/document-db/#store-data","title":"Store Data","text":"TypeScript<pre><code>// Create a customer record\nconst customer = await xians.documentDB.insert(\"customers\", {\n  name: \"John Doe\",\n  email: \"john@example.com\",\n  plan: \"professional\",\n  signupDate: new Date(),\n  metadata: {\n    source: \"website\",\n    campaign: \"q4-2024\"\n  }\n});\n\n// Document ID returned\nconsole.log(customer._id);  // \"cust_xyz789\"\n</code></pre>"},{"location":"concepts/document-db/#query-data","title":"Query Data","text":"TypeScript<pre><code>// Find VIP customers\nconst vipCustomers = await xians.documentDB.find(\"customers\", {\n  tags: { $contains: \"vip\" },\n  plan: \"enterprise\"\n});\n\n// Find by ID\nconst customer = await xians.documentDB.findById(\"customers\", \"cust_123\");\n\n// Complex queries\nconst results = await xians.documentDB.find(\"orders\", {\n  total: { $gt: 100, $lt: 1000 },\n  status: \"completed\",\n  createdAt: { $gte: startOfMonth }\n});\n</code></pre>"},{"location":"concepts/document-db/#update-data","title":"Update Data","text":"TypeScript<pre><code>// Update customer\nawait xians.documentDB.updateById(\"customers\", \"cust_123\", {\n  plan: \"enterprise\",  // Update field\n  tags: { $push: \"premium\" }  // Add to array\n});\n</code></pre>"},{"location":"concepts/document-db/#why-this-changes-ai-development","title":"Why This Changes AI Development","text":""},{"location":"concepts/document-db/#before-document-db-manual-data-management","title":"Before Document DB: Manual Data Management","text":"JavaScript<pre><code>// Manually manage database connections\nconst pool = new Pool({ connectionString: DB_URL });\n\n// Write SQL for every query\nconst result = await pool.query(\n  `SELECT * FROM customers \n   WHERE plan = $1 AND tags @&gt; $2`,\n  ['enterprise', ['vip']]\n);\n\n// Map rows to objects\nconst customers = result.rows.map(row =&gt; ({\n  id: row.customer_id,\n  name: row.customer_name,\n  // ... manual mapping\n}));\n\n// Store complex nested data? Good luck.\n</code></pre>"},{"location":"concepts/document-db/#with-document-db","title":"With Document DB","text":"TypeScript<pre><code>// Just store and query\nconst customers = await xians.documentDB.find(\"customers\", {\n  plan: \"enterprise\",\n  tags: { $contains: \"vip\" }\n});\n\n// Nested data? No problem.\n// Complex structures? Natural.\n// Schema changes? Just do it.\n</code></pre>"},{"location":"concepts/document-db/#powerful-patterns-for-ai-agents","title":"Powerful Patterns for AI Agents","text":""},{"location":"concepts/document-db/#pattern-1-agent-memory","title":"Pattern 1: Agent Memory","text":"TypeScript<pre><code>// Agent remembers decisions across conversations\nconst conversationAgent = await xians.createAgent({\n  name: \"SalesAgent\",\n\n  onMessage: async (message, context) =&gt; {\n    // Load agent memory for this customer\n    const memory = await xians.documentDB.findOne(\"agent-memory\", {\n      customerId: message.userId,\n      agentId: \"sales-agent\"\n    });\n\n    // Agent sees: what was discussed, decisions made, next steps\n    const response = await llm.chat({\n      message: message.content,\n      context: memory || {}\n    });\n\n    // Update memory\n    await xians.documentDB.updateById(\"agent-memory\", memory._id, {\n      lastInteraction: new Date(),\n      topics: { $push: response.topic },\n      nextSteps: response.nextSteps\n    });\n\n    return response;\n  }\n});\n</code></pre>"},{"location":"concepts/document-db/#pattern-2-dynamic-context-for-agents","title":"Pattern 2: Dynamic Context for Agents","text":"TypeScript<pre><code>// Agent looks up customer context automatically\nconst agent = await xians.createAgent({\n  name: \"SupportAgent\",\n\n  beforeMessage: async (message) =&gt; {\n    // Enrich with customer data\n    const customer = await xians.documentDB.findOne(\"customers\", {\n      email: message.userEmail\n    });\n\n    const recentOrders = await xians.documentDB.find(\"orders\", {\n      customerId: customer._id,\n      createdAt: { $gte: thirtyDaysAgo }\n    }, {\n      sort: { createdAt: -1 },\n      limit: 5\n    });\n\n    // Agent gets full context automatically\n    return {\n      ...message,\n      customerContext: {\n        plan: customer.plan,\n        vip: customer.tags?.includes(\"vip\"),\n        recentOrders: recentOrders\n      }\n    };\n  }\n});\n</code></pre>"},{"location":"concepts/document-db/#pattern-3-workflow-state-persistence","title":"Pattern 3: Workflow State Persistence","text":"TypeScript<pre><code>// Store complex workflow state\nconst workflow = await xians.createWorkflow({\n  name: \"CustomerOnboarding\",\n\n  onStep: async (step, data) =&gt; {\n    // Save state after each step\n    await xians.documentDB.updateById(\"workflow-state\", data.executionId, {\n      currentStep: step.id,\n      stepData: {\n        [step.id]: data.output\n      },\n      updatedAt: new Date()\n    });\n  },\n\n  onResume: async (executionId) =&gt; {\n    // Resume from saved state\n    const state = await xians.documentDB.findOne(\"workflow-state\", {\n      executionId\n    });\n\n    return state.stepData;\n  }\n});\n</code></pre>"},{"location":"concepts/document-db/#querying-power","title":"Querying Power","text":""},{"location":"concepts/document-db/#rich-query-operators","title":"Rich Query Operators","text":"TypeScript<pre><code>// Comparison\nconst orders = await xians.documentDB.find(\"orders\", {\n  total: { $gt: 100, $lt: 1000 },\n  status: { $in: [\"pending\", \"processing\"] },\n  createdAt: { $gte: startDate, $lte: endDate }\n});\n\n// Logical operators\nconst customers = await xians.documentDB.find(\"customers\", {\n  $or: [\n    { plan: \"enterprise\" },\n    { revenue: { $gt: 10000 } },\n    { tags: { $contains: \"vip\" } }\n  ]\n});\n\n// Nested fields\nconst results = await xians.documentDB.find(\"customers\", {\n  \"address.country\": \"USA\",\n  \"metadata.verified\": true,\n  \"preferences.notifications\": true\n});\n\n// Array operations\nconst products = await xians.documentDB.find(\"products\", {\n  tags: { $contains: \"featured\" },\n  categories: { $containsAny: [\"electronics\", \"gadgets\"] }\n});\n</code></pre>"},{"location":"concepts/document-db/#aggregation-for-analytics","title":"Aggregation for Analytics","text":"TypeScript<pre><code>// Group and count\nconst stats = await xians.documentDB.aggregate(\"orders\", [\n  { $match: { status: \"completed\" } },\n  { \n    $group: {\n      _id: \"$customerId\",\n      totalOrders: { $count: {} },\n      totalRevenue: { $sum: \"$total\" },\n      avgOrder: { $avg: \"$total\" }\n    }\n  },\n  { $sort: { totalRevenue: -1 } },\n  { $limit: 10 }\n]);\n\n// Top customers by revenue\nconsole.log(stats);\n</code></pre>"},{"location":"concepts/document-db/#real-world-examples","title":"Real-World Examples","text":""},{"location":"concepts/document-db/#e-commerce-agent-with-product-catalog","title":"E-Commerce Agent with Product Catalog","text":"TypeScript<pre><code>// Agent queries product database\nconst productAgent = await xians.createAgent({\n  name: \"ProductRecommendationAgent\",\n\n  tools: [{\n    name: \"searchProducts\",\n    handler: async ({ query, filters }) =&gt; {\n      return await xians.documentDB.find(\"products\", {\n        $text: { $search: query },\n        inStock: true,\n        price: filters.priceRange,\n        categories: { $containsAny: filters.categories }\n      }, {\n        limit: 10,\n        sort: { popularity: -1 }\n      });\n    }\n  }],\n\n  systemPrompt: `You help customers find products. Use searchProducts \n  to look up our catalog and make personalized recommendations.`\n});\n\n// Agent can now intelligently search products\nconst response = await productAgent.chat({\n  message: \"I need wireless headphones under $200\"\n});\n</code></pre>"},{"location":"concepts/document-db/#session-state-management","title":"Session State Management","text":"TypeScript<pre><code>// Multi-step form with AI assistance\nconst formAgent = await xians.createAgent({\n  name: \"FormAssistant\",\n\n  onMessage: async (message, context) =&gt; {\n    // Load session state\n    const session = await xians.documentDB.findOne(\"sessions\", {\n      sessionId: context.sessionId\n    }) || {\n      sessionId: context.sessionId,\n      currentStep: 1,\n      formData: {}\n    };\n\n    // Process current step\n    const stepResult = await processStep(message, session.currentStep);\n\n    // Update session\n    session.formData[`step${session.currentStep}`] = stepResult;\n    session.currentStep += 1;\n\n    await xians.documentDB.upsert(\"sessions\", \n      { sessionId: context.sessionId },\n      session\n    );\n\n    return {\n      message: `Great! Moving to step ${session.currentStep}...`,\n      progress: `${session.currentStep} of 5`\n    };\n  }\n});\n</code></pre>"},{"location":"concepts/document-db/#performance-indexes","title":"Performance: Indexes","text":""},{"location":"concepts/document-db/#speed-up-queries","title":"Speed Up Queries","text":"TypeScript<pre><code>// Create index on frequently queried fields\nawait xians.documentDB.createIndex(\"customers\", {\n  field: \"email\",\n  unique: true  // Enforce uniqueness\n});\n\n// Compound index for complex queries\nawait xians.documentDB.createIndex(\"orders\", {\n  fields: [\"customerId\", \"status\", \"createdAt\"],\n  name: \"customer_orders_idx\"\n});\n\n// Text index for search\nawait xians.documentDB.createIndex(\"products\", {\n  field: \"description\",\n  type: \"text\"\n});\n\n// Now queries are fast\n</code></pre>"},{"location":"concepts/document-db/#best-practices","title":"Best Practices","text":"<p>\u2705 Use Metadata Richly TypeScript<pre><code>// Good - Rich metadata for flexible queries\n{\n  _id: \"order_123\",\n  customerId: \"cust_456\",\n  status: \"completed\",\n  tags: [\"express\", \"vip\"],\n  metadata: {\n    source: \"mobile-app\",\n    campaign: \"summer-sale\",\n    priority: \"high\"\n  }\n}\n</code></pre></p> <p>\u2705 Index Frequently Queried Fields TypeScript<pre><code>// If you query by customerId often\nawait xians.documentDB.createIndex(\"orders\", {\n  field: \"customerId\"\n});\n</code></pre></p> <p>\u2705 Use Pagination for Large Results TypeScript<pre><code>const page1 = await xians.documentDB.find(\"orders\", \n  { status: \"completed\" },\n  { limit: 50, skip: 0 }\n);\n\nconst page2 = await xians.documentDB.find(\"orders\",\n  { status: \"completed\" },\n  { limit: 50, skip: 50 }\n);\n</code></pre></p> <p>\u274c Don't Store Huge Documents Keep documents under 1MB. Split large data into separate documents.</p> <p>\u274c Don't Over-Nest TypeScript<pre><code>// Bad - too deep\ncustomer.orders[0].items[0].product.category.parent.grandparent\n\n// Good - reference instead\ncustomer.orderIds \u2192 separate orders collection\n</code></pre></p>"},{"location":"concepts/document-db/#tenant-isolation-automatic","title":"Tenant Isolation: Automatic","text":"TypeScript<pre><code>// When operating in tenant context\nconst tenant = xians.tenant(\"acme-corp\");\n\n// All queries automatically scoped to tenant\nconst customers = await tenant.documentDB.find(\"customers\", {});\n// Returns ONLY acme-corp customers\n\n// Impossible to accidentally query another tenant's data\n</code></pre>"},{"location":"concepts/document-db/#integration-points","title":"Integration Points","text":"<p>Document DB powers the entire platform:</p> <ul> <li>Agents: Store agent memory and context</li> <li>Workflows: Persist workflow state</li> <li>Messages: Enrich messages with business data</li> <li>Knowledge: Different use case - semantic search vs structured queries</li> <li>Tenants: Automatic tenant isolation</li> </ul> <p>The Bottom Line: Document DB gives your AI agents a flexible, queryable memory. It's the structured data layer that makes agents context-aware, intelligent, and useful beyond simple Q&amp;A.</p>"},{"location":"concepts/knowledge/","title":"Knowledge","text":""},{"location":"concepts/knowledge/#give-your-agents-domain-expertise","title":"Give Your Agents Domain Expertise","text":"<p>LLMs are smart, but they don't know your business. Your products, your policies, your documentation. Knowledge bases solve this through Retrieval-Augmented Generation (RAG)\u2014letting agents search your content and ground their answers in your truth.</p>"},{"location":"concepts/knowledge/#the-hallucination-problem","title":"The Hallucination Problem","text":"<p>Raw LLM: Text Only<pre><code>User: \"What's your return policy?\"\nAgent: \"I think it's probably 30 days...\" \u2190 Made it up\nUser: \"How much does the Pro plan cost?\"\nAgent: \"Around $50/month I believe...\" \u2190 Guessing\n</code></pre></p> <p>With Knowledge Base: Text Only<pre><code>User: \"What's your return policy?\"\nAgent searches knowledge base \u2192 Finds policy doc\nAgent: \"Our return policy allows returns within 60 days...\" \u2190 Accurate\n\nUser: \"How much does the Pro plan cost?\"\nAgent searches knowledge base \u2192 Finds pricing\nAgent: \"The Pro plan is $49/month, billed annually...\" \u2190 Factual\n</code></pre></p>"},{"location":"concepts/knowledge/#why-knowledge-transforms-ai-development","title":"Why Knowledge Transforms AI Development","text":""},{"location":"concepts/knowledge/#the-challenge-llms-dont-know-your-content","title":"The Challenge: LLMs Don't Know Your Content","text":"<ul> <li>Training data ends months/years ago</li> <li>Doesn't include your docs, products, policies</li> <li>Can't access real-time information</li> <li>Makes up plausible-sounding lies (hallucinations)</li> </ul>"},{"location":"concepts/knowledge/#the-solution-retrieval-augmented-generation-rag","title":"The Solution: Retrieval-Augmented Generation (RAG)","text":"<p>Knowledge bases provide: - Semantic Search: Find relevant content by meaning, not just keywords - Grounded Responses: Answers based on your actual documents - Always Current: Update docs, agent knows immediately - Source Citations: See exactly what the agent used</p>"},{"location":"concepts/knowledge/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/knowledge/#how-rag-works","title":"How RAG Works","text":"Text Only<pre><code>1. User asks question\n   \u2193\n2. Question \u2192 Embedding \u2192 Vector\n   \u2193\n3. Search knowledge base for similar content\n   \u2193\n4. Retrieve top relevant chunks\n   \u2193\n5. LLM generates answer using retrieved context\n   \u2193\n6. Response grounded in your documents\n</code></pre>"},{"location":"concepts/knowledge/#knowledge-base-structure","title":"Knowledge Base Structure","text":"TypeScript<pre><code>const kb = await xians.createKnowledgeBase({\n  name: \"company-docs\",\n\n  // How to process documents\n  chunking: {\n    strategy: \"semantic\",     // Smart chunking\n    maxChunkSize: 512,        // Tokens per chunk\n    overlap: 50               // Context preservation\n  },\n\n  // How to search\n  embedding: {\n    model: \"text-embedding-3-large\",\n    dimensions: 1536\n  }\n});\n</code></pre>"},{"location":"concepts/knowledge/#quick-start","title":"Quick Start","text":""},{"location":"concepts/knowledge/#create-and-populate-knowledge-base","title":"Create and Populate Knowledge Base","text":"TypeScript<pre><code>// Create knowledge base\nconst kb = await xians.createKnowledgeBase({\n  name: \"product-docs\",\n  description: \"Product manuals and documentation\"\n});\n\n// Add documents\nawait kb.addDocument({\n  title: \"Pro Plan Features\",\n  content: `\n    The Pro Plan includes:\n    - Unlimited API calls\n    - 24/7 support\n    - Custom integrations\n    - SLA: 99.9% uptime\n    Price: $99/month\n  `,\n  metadata: {\n    category: \"pricing\",\n    lastUpdated: new Date()\n  }\n});\n\n// Upload files\nawait kb.uploadFile(\"./employee-handbook.pdf\");\nawait kb.uploadFile(\"./product-guide.md\");\n</code></pre>"},{"location":"concepts/knowledge/#connect-agent-to-knowledge-base","title":"Connect Agent to Knowledge Base","text":"TypeScript<pre><code>const agent = await xians.createAgent({\n  name: \"SupportAgent\",\n  model: \"gpt-4\",\n\n  // Connect to knowledge bases\n  knowledgeBases: [\"product-docs\", \"support-articles\"],\n\n  // RAG configuration\n  ragConfig: {\n    retrievalCount: 5,         // Top 5 relevant chunks\n    minRelevanceScore: 0.7,    // Filter low-quality matches\n    includeInPrompt: true      // Auto-inject into context\n  },\n\n  systemPrompt: `You are a helpful support agent. \n  Answer questions based on our documentation.\n  If you're not sure, say so\u2014don't make things up.`\n});\n\n// Agent automatically searches knowledge base\nconst response = await agent.chat({\n  message: \"What's included in the Pro plan?\"\n});\n\n// Response grounded in uploaded documents\nconsole.log(response.message);\nconsole.log(response.sources);  // Which docs were used\n</code></pre>"},{"location":"concepts/knowledge/#why-this-changes-ai-development","title":"Why This Changes AI Development","text":""},{"location":"concepts/knowledge/#before-rag-hardcoded-knowledge","title":"Before RAG: Hardcoded Knowledge","text":"JavaScript<pre><code>// Manually stuff knowledge into prompts\nconst prompt = `\nContext: Our return policy is 60 days. Pro plan costs $99/month...\n[Paste entire documentation here...]\n\nUser question: ${userQuestion}\n\nAnswer:`;\n\n// Problems:\n// - Context window limits (can't fit everything)\n// - Stale (update docs = update all prompts)\n// - Inefficient (send irrelevant info every time)\n// - Expensive (tokens for unused context)\n</code></pre>"},{"location":"concepts/knowledge/#with-knowledge-bases","title":"With Knowledge Bases","text":"TypeScript<pre><code>// Just connect and go\nconst agent = await xians.createAgent({\n  name: \"SupportAgent\",\n  knowledgeBases: [\"all-docs\"]\n});\n\n// Agent automatically:\n// - Finds relevant docs for each question\n// - Uses only what's needed\n// - Stays current with doc updates\n// - Cites sources\n</code></pre>"},{"location":"concepts/knowledge/#powerful-knowledge-patterns","title":"Powerful Knowledge Patterns","text":""},{"location":"concepts/knowledge/#pattern-1-multi-source-agent","title":"Pattern 1: Multi-Source Agent","text":"TypeScript<pre><code>// Agent with multiple knowledge bases\nconst agent = await xians.createAgent({\n  name: \"UniversalAgent\",\n  knowledgeBases: [\n    \"product-docs\",       // Product information\n    \"support-articles\",   // How-to guides\n    \"company-policies\",   // HR policies\n    \"legal-docs\"          // Terms, privacy, etc.\n  ],\n\n  ragConfig: {\n    // Search all knowledge bases\n    searchStrategy: \"parallel\",\n\n    // Weight by source\n    sourceWeights: {\n      \"product-docs\": 1.0,\n      \"legal-docs\": 1.2      // Prioritize legal accuracy\n    }\n  }\n});\n</code></pre>"},{"location":"concepts/knowledge/#pattern-2-dynamic-knowledge-updates","title":"Pattern 2: Dynamic Knowledge Updates","text":"TypeScript<pre><code>// Knowledge base syncs with your CMS\nconst kb = await xians.createKnowledgeBase({\n  name: \"help-center\",\n\n  // Auto-sync from web\n  sources: [{\n    type: \"web\",\n    url: \"https://help.yourcompany.com\",\n    schedule: \"daily\",      // Refresh daily\n    crawlDepth: 3\n  }]\n});\n\n// Or trigger manual sync\nawait kb.sync();\n\n// Agents always have latest content\n</code></pre>"},{"location":"concepts/knowledge/#pattern-3-filtered-knowledge-retrieval","title":"Pattern 3: Filtered Knowledge Retrieval","text":"TypeScript<pre><code>// Different agents see different knowledge\nconst publicAgent = await xians.createAgent({\n  name: \"PublicSupportAgent\",\n  knowledgeBases: [\"public-docs\"],\n\n  ragConfig: {\n    filters: {\n      \"metadata.public\": true  // Only public docs\n    }\n  }\n});\n\nconst internalAgent = await xians.createAgent({\n  name: \"InternalAgent\",\n  knowledgeBases: [\"all-docs\"],\n\n  ragConfig: {\n    filters: {\n      \"metadata.department\": \"engineering\"  // Dept-specific\n    }\n  }\n});\n</code></pre>"},{"location":"concepts/knowledge/#real-world-examples","title":"Real-World Examples","text":""},{"location":"concepts/knowledge/#customer-support-with-product-knowledge","title":"Customer Support with Product Knowledge","text":"TypeScript<pre><code>// Build knowledge base from product docs\nconst productKB = await xians.createKnowledgeBase({\n  name: \"products\"\n});\n\n// Add product catalog\nconst products = await database.getProducts();\nfor (const product of products) {\n  await productKB.addDocument({\n    title: product.name,\n    content: `\n      ${product.name}\n      Price: $${product.price}\n      Description: ${product.description}\n      Features: ${product.features.join(\", \")}\n      Specifications: ${JSON.stringify(product.specs)}\n    `,\n    metadata: {\n      category: product.category,\n      sku: product.sku,\n      inStock: product.stock &gt; 0\n    }\n  });\n}\n\n// Support agent with product knowledge\nconst agent = await xians.createAgent({\n  name: \"ProductSupportAgent\",\n  knowledgeBases: [\"products\"],\n\n  systemPrompt: `You help customers with product questions.\n  Use the knowledge base to provide accurate information.\n  If a product is out of stock, mention it.`\n});\n\n// Agent knows your entire catalog\nawait agent.chat({\n  message: \"Do you have wireless headphones under $150?\"\n});\n</code></pre>"},{"location":"concepts/knowledge/#hr-assistant-with-company-policies","title":"HR Assistant with Company Policies","text":"TypeScript<pre><code>// Upload company handbook\nconst hrKB = await xians.createKnowledgeBase({\n  name: \"hr-policies\"\n});\n\nawait hrKB.uploadFile(\"./employee-handbook.pdf\");\nawait hrKB.uploadFile(\"./benefits-guide.pdf\");\nawait hrKB.uploadFile(\"./pto-policy.md\");\n\n// HR agent\nconst hrAgent = await xians.createAgent({\n  name: \"HRAssistant\",\n  knowledgeBases: [\"hr-policies\"],\n\n  ragConfig: {\n    retrievalCount: 3,\n    includeInPrompt: true\n  },\n\n  systemPrompt: `You're an HR assistant. Answer employee questions\n  about company policies accurately. Always cite the specific policy\n  section you're referencing.`\n});\n\n// Employees get instant, accurate answers\nawait hrAgent.chat({\n  message: \"How many vacation days do I get?\"\n});\n// Response includes: \"According to the PTO Policy section 3.1...\"\n</code></pre>"},{"location":"concepts/knowledge/#code-documentation-assistant","title":"Code Documentation Assistant","text":"TypeScript<pre><code>// Index your codebase documentation\nconst docsKB = await xians.createKnowledgeBase({\n  name: \"api-docs\"\n});\n\n// Add API documentation\nawait docsKB.uploadFile(\"./docs/api-reference.md\");\nawait docsKB.uploadFile(\"./docs/sdk-guide.md\");\nawait docsKB.uploadFile(\"./docs/examples.md\");\n\n// Developer assistant\nconst devAgent = await xians.createAgent({\n  name: \"DevAssistant\",\n  knowledgeBases: [\"api-docs\"],\n\n  systemPrompt: `You help developers use our API.\n  Provide code examples and link to relevant documentation.`\n});\n\nawait devAgent.chat({\n  message: \"How do I authenticate API requests?\"\n});\n</code></pre>"},{"location":"concepts/knowledge/#advanced-features","title":"Advanced Features","text":""},{"location":"concepts/knowledge/#hybrid-search","title":"Hybrid Search","text":"TypeScript<pre><code>// Combine semantic search + keyword matching\nconst results = await kb.hybridSearch({\n  query: \"return policy for electronics\",\n  keywords: [\"60 days\", \"warranty\"],\n  weights: {\n    semantic: 0.7,    // 70% semantic similarity\n    keyword: 0.3      // 30% keyword matching\n  }\n});\n</code></pre>"},{"location":"concepts/knowledge/#chunk-strategies","title":"Chunk Strategies","text":"TypeScript<pre><code>// Semantic chunking (smart)\nawait kb.updateConfig({\n  chunking: {\n    strategy: \"semantic\",     // AI understands context\n    maxChunkSize: 1000\n  }\n});\n\n// Fixed size chunking (simple)\nawait kb.updateConfig({\n  chunking: {\n    strategy: \"fixed\",\n    chunkSize: 512,\n    overlap: 50\n  }\n});\n</code></pre>"},{"location":"concepts/knowledge/#source-citations","title":"Source Citations","text":"TypeScript<pre><code>// See what knowledge was used\nconst response = await agent.chat({\n  message: \"What's your refund policy?\"\n});\n\nconsole.log(response.sources);\n// [\n//   { \n//     title: \"Return &amp; Refund Policy\",\n//     chunk: \"Customers may return items within 60 days...\",\n//     score: 0.92\n//   }\n// ]\n</code></pre>"},{"location":"concepts/knowledge/#knowledge-vs-document-db","title":"Knowledge vs Document DB","text":"Feature Knowledge Base Document DB Purpose Semantic search, RAG Structured data storage Search By meaning/similarity By exact fields Best for Documents, content, text Records, entities, state Example Product manuals, FAQs Customer records, orders Agent use \"What's the policy?\" \"Who is customer #123?\" <p>Use both together: TypeScript<pre><code>// Knowledge: Content search\nconst policyInfo = await kb.search(\"return policy\");\n\n// Document DB: Data lookup\nconst customer = await db.findOne(\"customers\", { id: \"123\" });\n\n// Agent combines both\nconst response = `Based on our policy: ${policyInfo}\nFor your order: ${customer.lastOrder}`;\n</code></pre></p>"},{"location":"concepts/knowledge/#best-practices","title":"Best Practices","text":"<p>\u2705 Chunk Documents Smartly TypeScript<pre><code>// Good chunk size: 512-1024 tokens\n// Include overlap to preserve context\nchunking: {\n  maxChunkSize: 512,\n  overlap: 50\n}\n</code></pre></p> <p>\u2705 Use Rich Metadata TypeScript<pre><code>await kb.addDocument({\n  title: \"Pro Plan Pricing\",\n  content: \"...\",\n  metadata: {\n    category: \"pricing\",\n    plan: \"pro\",\n    lastUpdated: \"2024-12-01\",\n    public: true\n  }\n});\n</code></pre></p> <p>\u2705 Monitor Search Quality TypeScript<pre><code>// Track what users search for\nconst analytics = await kb.getAnalytics();\nconsole.log(\"Top queries:\", analytics.topQueries);\nconsole.log(\"Coverage:\", analytics.coverageRate);\n\n// Identify gaps in knowledge\nconsole.log(\"Queries with poor results:\", analytics.lowScoreQueries);\n</code></pre></p> <p>\u274c Don't Dump Everything Only add relevant, well-structured content. Quality &gt; Quantity.</p> <p>\u274c Don't Forget to Update Stale knowledge = wrong answers. Keep docs current.</p>"},{"location":"concepts/knowledge/#integration-points","title":"Integration Points","text":"<p>Knowledge powers intelligent agents:</p> <ul> <li>Agents: Ground agents in your domain knowledge</li> <li>Workflows: Knowledge retrieval in workflow steps</li> <li>Document DB: Different use case - structured vs semantic</li> <li>Messages: Cite sources in conversation</li> </ul> <p>The Bottom Line: Knowledge bases transform generic LLMs into domain experts. They're the bridge between your content and your AI agents\u2014enabling accurate, grounded, trustworthy responses.</p>"},{"location":"concepts/messages/","title":"Messages","text":""},{"location":"concepts/messages/#the-communication-fabric","title":"The Communication Fabric","text":"<p>Think of messages as the nervous system of your AI application. They're not just text going back and forth\u2014they're the conversational memory that makes your agents intelligent, contextual, and truly helpful.</p>"},{"location":"concepts/messages/#the-context-problem","title":"The Context Problem","text":"<p>Here's what breaks most AI chatbots:</p> <p>Traditional Chatbots: Text Only<pre><code>User: \"I need help with my order\"\nBot: \"What order number?\"\nUser: \"The one from yesterday\"\nBot: \"I don't see any order\" \u2190 Forgot everything\n</code></pre></p> <p>With Message Threading: Text Only<pre><code>User: \"I need help with my order\"\nBot: \"I see you have order #12345 from yesterday. What do you need help with?\"\nUser: \"Change the shipping address\"\nBot: \"I'll update order #12345 for you\" \u2190 Remembers context\n</code></pre></p>"},{"location":"concepts/messages/#why-messages-transform-ai-development","title":"Why Messages Transform AI Development","text":""},{"location":"concepts/messages/#the-challenge-stateless-llms","title":"The Challenge: Stateless LLMs","text":"<p>LLMs don't remember conversations. Every interaction is isolated unless you manually manage context.</p>"},{"location":"concepts/messages/#the-solution-message-threads","title":"The Solution: Message Threads","text":"<p>Messages in Xians.ai provide: - Persistent Memory: Conversations survive across sessions - Contextual Understanding: Agents see the full history - Multi-Turn Dialogues: Complex conversations that build on previous exchanges - Rich Data Exchange: Not just text\u2014structured data, files, actions</p>"},{"location":"concepts/messages/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/messages/#message-structure","title":"Message Structure","text":"TypeScript<pre><code>{\n  id: \"msg_abc123\",\n  threadId: \"conv_xyz789\",        // Links messages together\n  role: \"user\" | \"agent\" | \"system\",\n  content: \"What's my account balance?\",\n  timestamp: \"2024-12-29T10:30:00Z\",\n  metadata: {\n    userId: \"user_456\",\n    agentId: \"support-agent\",\n    sentiment: \"neutral\"\n  }\n}\n</code></pre>"},{"location":"concepts/messages/#thread--conversation","title":"Thread = Conversation","text":"TypeScript<pre><code>// Same thread = shared context\nconst thread = await xians.createThread({\n  userId: \"user_123\",\n  metadata: { \n    channel: \"web-chat\",\n    priority: \"normal\"\n  }\n});\n\n// All messages share context\nawait agent.sendMessage({\n  threadId: thread.id,\n  content: \"What's my order status?\"  // Agent sees full history\n});\n</code></pre>"},{"location":"concepts/messages/#message-patterns-that-matter","title":"Message Patterns That Matter","text":""},{"location":"concepts/messages/#pattern-1-conversational-continuity","title":"Pattern 1: Conversational Continuity","text":"<p>Agents that remember.</p> TypeScript<pre><code>// Message 1\nawait supportAgent.chat({\n  threadId: \"thread_123\",\n  message: \"I can't log in\"\n});\n// Agent response: \"Let me help. What error do you see?\"\n\n// Message 2 - Agent remembers the login issue\nawait supportAgent.chat({\n  threadId: \"thread_123\",  // Same thread\n  message: \"It says invalid password\"\n});\n// Agent: \"I'll send you a password reset for your account ending in 4567\"\n</code></pre>"},{"location":"concepts/messages/#pattern-2-rich-structured-messages","title":"Pattern 2: Rich Structured Messages","text":"<p>Beyond plain text.</p> TypeScript<pre><code>// Agent sends structured data\n{\n  role: \"agent\",\n  content: {\n    type: \"order-summary\",\n    orderId: \"12345\",\n    items: [...],\n    total: 299.99,\n    actions: [\n      { label: \"Track Shipment\", action: \"track\" },\n      { label: \"Cancel Order\", action: \"cancel\" }\n    ]\n  }\n}\n</code></pre>"},{"location":"concepts/messages/#pattern-3-multi-modal-communication","title":"Pattern 3: Multi-Modal Communication","text":"<p>Text, files, images, data.</p> TypeScript<pre><code>await agent.sendMessage({\n  threadId: \"thread_123\",\n  content: \"Here's your monthly report\",\n  attachments: [\n    {\n      type: \"pdf\",\n      url: \"https://storage/report.pdf\",\n      name: \"December_Report.pdf\"\n    }\n  ],\n  metadata: {\n    generated: true,\n    reportPeriod: \"2024-12\"\n  }\n});\n</code></pre>"},{"location":"concepts/messages/#why-this-changes-ai-development","title":"Why This Changes AI Development","text":""},{"location":"concepts/messages/#without-message-management","title":"Without Message Management","text":"JavaScript<pre><code>// You manually track everything\nconst conversationHistory = [];\nconversationHistory.push({ role: \"user\", content: userInput });\n\nconst response = await openai.chat.completions.create({\n  messages: conversationHistory  // Hope this doesn't exceed context window\n});\n\nconversationHistory.push({ role: \"assistant\", content: response });\n// Manually store in database, handle pagination, prune old messages...\n</code></pre>"},{"location":"concepts/messages/#with-xians-messages","title":"With Xians Messages","text":"TypeScript<pre><code>// Just send. Threading and context handled automatically.\nconst response = await agent.chat({\n  message: userInput,\n  threadId: conversation.id  // That's it.\n});\n\n// Access full history anytime\nconst history = await thread.getMessages();\n</code></pre>"},{"location":"concepts/messages/#smart-context-management","title":"Smart Context Management","text":""},{"location":"concepts/messages/#automatic-context-windows","title":"Automatic Context Windows","text":"TypeScript<pre><code>const agent = await xians.createAgent({\n  name: \"SupportAgent\",\n  model: \"gpt-4\",\n  contextConfig: {\n    maxMessages: 50,           // Keep last 50 messages\n    maxTokens: 8000,            // Stay within token limits\n    strategy: \"sliding-window\"  // Auto-prune old messages\n  }\n});\n</code></pre>"},{"location":"concepts/messages/#selective-context","title":"Selective Context","text":"TypeScript<pre><code>// Include only relevant messages\nconst response = await agent.chat({\n  message: \"Summarize my orders\",\n  threadId: \"thread_123\",\n  contextFilter: {\n    includeRoles: [\"user\", \"agent\"],  // Skip system messages\n    sinceTimestamp: lastWeek,\n    relevanceScore: 0.7  // AI filters relevant messages\n  }\n});\n</code></pre>"},{"location":"concepts/messages/#message-metadata-the-secret-sauce","title":"Message Metadata: The Secret Sauce","text":""},{"location":"concepts/messages/#track-everything-that-matters","title":"Track Everything That Matters","text":"TypeScript<pre><code>await agent.sendMessage({\n  threadId: \"thread_123\",\n  content: \"Issue resolved!\",\n  metadata: {\n    // Routing\n    assignedTo: \"agent-456\",\n    priority: \"high\",\n\n    // Analytics\n    sentiment: \"positive\",\n    resolutionTime: 180,  // seconds\n    category: \"billing\",\n\n    // Business context\n    customerId: \"cust_789\",\n    ticketId: \"TKT-001\",\n\n    // Custom\n    aiConfidence: 0.95,\n    humanReview: false\n  }\n});\n</code></pre>"},{"location":"concepts/messages/#query-by-metadata","title":"Query by Metadata","text":"TypeScript<pre><code>// Find all high-priority unresolved conversations\nconst threads = await xians.findThreads({\n  metadata: {\n    priority: \"high\",\n    status: \"open\"\n  }\n});\n</code></pre>"},{"location":"concepts/messages/#real-world-example","title":"Real-World Example","text":""},{"location":"concepts/messages/#before-manual-context-hell","title":"Before: Manual Context Hell","text":"JavaScript<pre><code>// Store conversation manually\nconst sessionData = await redis.get(`session:${userId}`);\nlet history = JSON.parse(sessionData || '[]');\n\nhistory.push({ role: 'user', content: message });\n\n// Manually manage token limits\nif (estimateTokens(history) &gt; 6000) {\n  history = history.slice(-20);  // Drop old messages\n}\n\nconst response = await openai.chat.completions.create({\n  messages: history\n});\n\nhistory.push({ role: 'assistant', content: response.content });\nawait redis.set(`session:${userId}`, JSON.stringify(history));\n</code></pre>"},{"location":"concepts/messages/#after-let-xians-handle-it","title":"After: Let Xians Handle It","text":"TypeScript<pre><code>// Just chat. Context, storage, pruning handled automatically.\nconst response = await supportAgent.chat({\n  message: userMessage,\n  threadId: userSession.threadId\n});\n</code></pre>"},{"location":"concepts/messages/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"concepts/messages/#human-handoff","title":"Human Handoff","text":"TypeScript<pre><code>// Agent escalates to human\nawait agent.sendMessage({\n  threadId: \"thread_123\",\n  content: \"I'm transferring you to a specialist.\",\n  metadata: {\n    handoff: true,\n    handoffReason: \"complex-issue\",\n    assignTo: \"human-support-team\"\n  }\n});\n\n// Human sees full context\nconst context = await thread.getMessages();\n</code></pre>"},{"location":"concepts/messages/#multi-agent-conversations","title":"Multi-Agent Conversations","text":"TypeScript<pre><code>// Multiple agents in one thread\nawait agent1.chat({ \n  threadId: \"thread_123\",\n  message: \"Analyze this customer request\"\n});\n\nawait agent2.chat({\n  threadId: \"thread_123\",  // Same thread\n  message: \"Based on previous analysis, recommend solution\"\n});\n</code></pre>"},{"location":"concepts/messages/#branching-conversations","title":"Branching Conversations","text":"TypeScript<pre><code>// Create sub-thread for specific topic\nconst subThread = await thread.createBranch({\n  fromMessageId: \"msg_789\",\n  topic: \"technical-details\"\n});\n</code></pre>"},{"location":"concepts/messages/#integration-points","title":"Integration Points","text":"<p>Messages become powerful when combined with:</p> <ul> <li>Agents: Process messages intelligently</li> <li>Workflows: Route messages through complex processes</li> <li>Webhooks: Trigger external systems on message events</li> <li>Document DB: Store rich message context</li> </ul> <p>The Bottom Line: Messages turn one-off LLM calls into intelligent, contextual conversations. They're the difference between a bot that answers questions and an AI assistant that actually understands your users.</p>"},{"location":"concepts/scheduling-concepts/","title":"Scheduling Concepts","text":""},{"location":"concepts/scheduling-concepts/#what-are-schedules","title":"What Are Schedules?","text":"<p>Schedules are cron jobs for AI agents. They let your workflows execute on time-based triggers - daily reports at 9 AM, hourly health checks, weekly analytics, or any recurring task your agents need to handle.</p> <p>Unlike traditional cron jobs, Xians schedules are:</p> <ul> <li>Durable - Survive restarts and failures</li> <li>Multi-tenant aware - Automatic isolation per tenant</li> <li>Workflow-native - Fully deterministic when used inside workflows</li> <li>Production-ready - Built-in retries, timeouts, and overlap policies</li> </ul> <p>Powered by Temporal Schedules, wrapped in a fluent API that feels natural to use.</p>"},{"location":"concepts/scheduling-concepts/#why-scheduling","title":"Why Scheduling?","text":"<p>AI agents need to be proactive, not just reactive. Schedules let your agents:</p> <ul> <li>Run daily data syncs without manual triggers</li> <li>Generate morning briefings automatically</li> <li>Perform background research on a schedule</li> <li>Monitor systems at regular intervals</li> <li>Orchestrate recurring business processes</li> </ul> <p>The key insight: Workflows that schedule themselves are autonomous. They control their own timing, create follow-up work, and operate continuously without external coordination.</p>"},{"location":"concepts/scheduling-concepts/#quick-start","title":"Quick Start","text":"<p>Here's a workflow that schedules itself to run every day at 9 AM:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Temporalio.Workflows;\n\n[Workflow(\"Daily Report Workflow\")]\npublic class DailyReportWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string reportType)\n    {\n        // Do the work\n        await GenerateReport(reportType);\n\n        // Schedule next run\n        var schedule = await XiansContext.CurrentWorkflow.Schedules!\n            .Create(\"daily-report\")\n            .Daily(hour: 9, timezone: \"America/New_York\")\n            .WithInput(reportType)\n            .SkipIfRunning()\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 3,\n                InitialInterval = TimeSpan.FromSeconds(10),\n                BackoffCoefficient = 2.0\n            })\n            .StartAsync();\n    }\n}\n</code></pre> <p>That's it. The workflow runs, does its work, and schedules the next execution. Your agent is now autonomous.</p>"},{"location":"concepts/scheduling-concepts/#scheduling-options","title":"Scheduling Options","text":""},{"location":"concepts/scheduling-concepts/#time-based-schedules","title":"Time-Based Schedules","text":"C#<pre><code>// Daily at specific time (timezone-aware)\n.Daily(hour: 9, timezone: \"America/New_York\")\n\n// Weekdays only\n.Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n\n// Weekly on specific day\n.Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n\n// Monthly\n.Monthly(dayOfMonth: 1, hour: 8, timezone: \"Asia/Tokyo\")\n</code></pre>"},{"location":"concepts/scheduling-concepts/#interval-based-schedules","title":"Interval-Based Schedules","text":"C#<pre><code>// Fixed intervals (no timezone - duration-based)\n.EverySeconds(30)\n.EveryMinutes(15)\n.EveryHours(2)\n.EveryDays(3)\n</code></pre>"},{"location":"concepts/scheduling-concepts/#cron-expressions","title":"Cron Expressions","text":"C#<pre><code>// Every 2 hours\n.WithCronSchedule(\"0 */2 * * *\")\n\n// Weekdays at 9 AM ET\n.WithCronSchedule(\"0 9 * * 1-5\", timezone: \"America/New_York\")\n\n// First of month at midnight\n.WithCronSchedule(\"0 0 1 * *\", timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling-concepts/#one-time-execution","title":"One-Time Execution","text":"C#<pre><code>// Specific future date/time\nvar futureDate = new DateTime(2026, 12, 25, 9, 0, 0);\n.WithCalendarSchedule(futureDate, timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling-concepts/#overlap-policies","title":"Overlap Policies","text":"<p>What happens when a schedule triggers but the previous execution is still running?</p> C#<pre><code>.SkipIfRunning()      // Skip new run (recommended for most cases)\n.AllowOverlap()       // Allow concurrent executions\n.BufferOne()          // Queue one execution for after current\n.CancelOther()        // Cancel running, start new\n.TerminateOther()     // Force stop running (use with caution)\n</code></pre> <p>Recommendation: Use <code>.SkipIfRunning()</code> by default. It prevents execution pile-up when workflows take longer than the schedule interval.</p>"},{"location":"concepts/scheduling-concepts/#managing-schedules","title":"Managing Schedules","text":"<p>Full lifecycle control from within workflows:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Get existing schedule\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Pause/resume\nawait schedule.PauseAsync(\"System maintenance\");\nawait schedule.UnpauseAsync(\"Maintenance complete\");\n\n// Trigger immediate run (doesn't affect schedule)\nawait schedule.TriggerAsync();\n\n// Delete\nawait schedule.DeleteAsync();\n\n// List all schedules (tenant-filtered)\nvar allSchedules = await workflow.Schedules!.ListAsync();\n</code></pre>"},{"location":"concepts/scheduling-concepts/#multi-tenant-isolation","title":"Multi-Tenant Isolation","text":"<p>Schedules automatically respect tenant boundaries - zero configuration required:</p> C#<pre><code>[Workflow(\"Multi-Tenant Task\")]\npublic class TenantTaskWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Schedule automatically scoped to current tenant\n        await workflow.Schedules!\n            .Create(\"daily-task\")  // Internal ID: \"{tenantId}:daily-task\"\n            .Daily(hour: 9)\n            .StartAsync();\n    }\n}\n</code></pre> <p>What you get:</p> <ul> <li>Schedules prefixed with tenant ID internally</li> <li><code>ListAsync()</code> only returns current tenant's schedules</li> <li>Cross-tenant access blocked automatically</li> <li>No manual tenant filtering needed</li> </ul>"},{"location":"concepts/scheduling-concepts/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/scheduling-concepts/#self-scheduling-workflow-recommended","title":"Self-Scheduling Workflow (Recommended)","text":"<p>Workflows that create their own recurring schedules:</p> C#<pre><code>[Workflow(\"Content Crawler\")]\npublic class ContentCrawlerWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string url, int intervalHours)\n    {\n        // Do the work\n        var content = await CrawlContent(url);\n        await ProcessContent(content);\n\n        // Schedule next run\n        await XiansContext.CurrentWorkflow.Schedules!\n            .Create($\"crawler-{url}\")\n            .EveryHours(intervalHours)\n            .WithInput(url, intervalHours)\n            .SkipIfRunning()\n            .StartAsync();\n    }\n}\n</code></pre> <p>Why this works well:</p> <ul> <li>Workflow controls its own timing</li> <li>Automatic determinism (SDK uses activities internally)</li> <li>Tenant context always available</li> <li>Clean separation of concerns</li> </ul>"},{"location":"concepts/scheduling-concepts/#bulk-schedule-creation","title":"Bulk Schedule Creation","text":"<p>Set up schedules for multiple entities:</p> C#<pre><code>[Workflow(\"Research Setup\")]\npublic class ResearchSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string[] companies)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        foreach (var company in companies)\n        {\n            await workflow.Schedules!\n                .Create($\"research-{company.ToLower()}\")\n                .Weekdays(hour: 8, timezone: \"America/New_York\")\n                .WithInput(company)\n                .SkipIfRunning()\n                .StartAsync();\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/scheduling-concepts/#how-it-works-workflow-aware-api","title":"How It Works: Workflow-Aware API","text":"<p>The scheduling SDK is context-aware:</p> <p>Inside workflows:</p> <ul> <li>SDK detects <code>Workflow.InWorkflow == true</code></li> <li>Automatically uses pre-registered <code>ScheduleActivities</code></li> <li>Maintains determinism</li> <li>No manual activity registration needed</li> </ul> <p>Outside workflows:</p> <ul> <li>Direct Temporal client calls</li> <li>No workflow context required</li> </ul> <p>Important: <code>XiansContext.CurrentWorkflow</code> only works inside workflows/activities. Using it elsewhere throws <code>InvalidOperationException</code>.</p>"},{"location":"concepts/scheduling-concepts/#production-features","title":"Production Features","text":"<p>Every schedule can have:</p> C#<pre><code>await workflow.Schedules!\n    .Create(\"production-task\")\n    .Daily(hour: 9, timezone: \"America/New_York\")\n    .WithInput(params)\n\n    // Retry failed executions\n    .WithRetryPolicy(new RetryPolicy\n    {\n        MaximumAttempts = 3,\n        InitialInterval = TimeSpan.FromSeconds(10),\n        BackoffCoefficient = 2.0\n    })\n\n    // Timeout protection\n    .WithTimeout(TimeSpan.FromHours(2))\n\n    // Prevent pile-up\n    .SkipIfRunning()\n\n    // Custom metadata for tracking\n    .WithMemo(new Dictionary&lt;string, object&gt;\n    {\n        { \"team\", \"data-engineering\" },\n        { \"priority\", \"high\" }\n    })\n\n    .StartAsync();\n</code></pre>"},{"location":"concepts/scheduling-concepts/#best-practices","title":"Best Practices","text":"<p>Do:</p> <ul> <li>Use <code>.SkipIfRunning()</code> to prevent execution pile-up</li> <li>Add retry policies for production schedules</li> <li>Specify timezones for time-based schedules</li> <li>Use descriptive IDs: <code>daily-sync-{company}</code> not <code>schedule1</code></li> <li>Check <code>ExistsAsync()</code> before creating for idempotency</li> </ul> <p>Don't:</p> <ul> <li>Mix schedule creation with business logic</li> <li>Forget to handle timezone differences</li> <li>Create schedules without overlap policies</li> <li>Use generic schedule IDs</li> </ul>"},{"location":"concepts/scheduling-concepts/#quick-reference","title":"Quick Reference","text":"C#<pre><code>// Common schedule patterns\n.Daily(hour: 9, timezone: \"America/New_York\")\n.Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n.EveryMinutes(30)\n.EveryHours(2)\n.Monthly(dayOfMonth: 1, hour: 9, timezone: \"America/New_York\")\n.WithCronSchedule(\"0 */2 * * *\")  // Every 2 hours\n</code></pre>"},{"location":"concepts/scheduling-concepts/#whats-next","title":"What's Next?","text":"<ul> <li>Scheduling SDK - Complete API reference and advanced examples</li> <li>Workflows - Understanding workflow orchestration</li> <li>Agents - Agent architecture and patterns</li> <li>Tenants - Multi-tenant deployment</li> </ul> <p>Bottom line: Schedules turn reactive workflows into autonomous agents. They're the difference between \"run this when I tell you\" and \"run this every day at 9 AM until I tell you to stop.\"</p>"},{"location":"concepts/tenants/","title":"Tenants","text":""},{"location":"concepts/tenants/#multi-tenancy-made-simple","title":"Multi-Tenancy Made Simple","text":"<p>Building a SaaS AI application? You need to serve multiple customers on the same platform without their data, agents, or costs bleeding together. That's where tenants come in\u2014complete isolation for each customer, all on one infrastructure.</p>"},{"location":"concepts/tenants/#the-saas-challenge","title":"The SaaS Challenge","text":"<p>Without Multi-Tenancy: Text Only<pre><code>Deploy separate infrastructure for each customer\n\u2192 10 customers = 10 servers + 10 databases + 10 deployments\n\u2192 Operations nightmare + massive costs\n</code></pre></p> <p>With Tenants: Text Only<pre><code>One platform, perfect isolation\n\u2192 1,000 customers on shared infrastructure\n\u2192 Each sees only their data and agents\n\u2192 Cost efficiency + operational simplicity\n</code></pre></p>"},{"location":"concepts/tenants/#why-tenants-matter-for-ai-development","title":"Why Tenants Matter for AI Development","text":""},{"location":"concepts/tenants/#the-problem-shared-infrastructure-isolated-data","title":"The Problem: Shared Infrastructure, Isolated Data","text":"<p>When you're building AI agents as a service, you need: - Complete data isolation (Customer A never sees Customer B's data) - Resource boundaries (One customer can't exhaust resources) - Custom configurations (Different models, prompts, permissions per customer) - Cost tracking (Know exactly what each customer costs)</p>"},{"location":"concepts/tenants/#the-solution-tenant-architecture","title":"The Solution: Tenant Architecture","text":"<p>Tenants provide secure, isolated environments where each customer gets their own: - Agents and workflows - Knowledge bases and documents - Message threads and history - Usage metrics and billing - Custom configurations</p>"},{"location":"concepts/tenants/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/tenants/#whats-a-tenant","title":"What's a Tenant?","text":"TypeScript<pre><code>{\n  id: \"tenant_acme_corp\",\n  name: \"ACME Corporation\",\n\n  // Isolation\n  dataRegion: \"us-east-1\",\n  encryptionKey: \"tenant-specific-key\",\n\n  // Configuration\n  settings: {\n    defaultModel: \"gpt-4\",\n    allowedModels: [\"gpt-4\", \"gpt-4-turbo\"],\n    features: [\"workflows\", \"knowledge-base\", \"webhooks\"]\n  },\n\n  // Resource Limits\n  limits: {\n    maxAgents: 50,\n    maxUsers: 100,\n    maxAPICallsPerDay: 10000,\n    storageGB: 500\n  },\n\n  // Billing\n  billing: {\n    plan: \"enterprise\",\n    usageTracking: true\n  }\n}\n</code></pre>"},{"location":"concepts/tenants/#perfect-isolation","title":"Perfect Isolation","text":"Text Only<pre><code>Platform\n\u251c\u2500\u2500 Tenant: Acme Corp\n\u2502   \u251c\u2500\u2500 Agents: [Sales Agent, Support Agent]\n\u2502   \u251c\u2500\u2500 Knowledge: [Product Docs, Policies]\n\u2502   \u251c\u2500\u2500 Users: [john@acme.com, jane@acme.com]\n\u2502   \u2514\u2500\u2500 Data: Completely isolated\n\u2502\n\u251c\u2500\u2500 Tenant: StartupXYZ\n\u2502   \u251c\u2500\u2500 Agents: [AI Assistant]\n\u2502   \u251c\u2500\u2500 Knowledge: [Help Center]\n\u2502   \u251c\u2500\u2500 Users: [founder@startupxyz.com]\n\u2502   \u2514\u2500\u2500 Data: Completely isolated\n\u2502\n\u2514\u2500\u2500 Tenant: BigEnterprise\n    \u251c\u2500\u2500 Agents: [100+ specialized agents]\n    \u251c\u2500\u2500 Knowledge: [Massive knowledge bases]\n    \u251c\u2500\u2500 Users: [1000+ employees]\n    \u2514\u2500\u2500 Data: Completely isolated\n</code></pre>"},{"location":"concepts/tenants/#quick-start","title":"Quick Start","text":""},{"location":"concepts/tenants/#creating-a-tenant","title":"Creating a Tenant","text":"TypeScript<pre><code>const tenant = await xians.createTenant({\n  name: \"acme-corp\",\n  displayName: \"ACME Corporation\",\n\n  // Configuration\n  settings: {\n    region: \"us-east-1\",\n    defaultModel: \"gpt-4\",\n    features: [\"workflows\", \"knowledge-base\"]\n  },\n\n  // Resource boundaries\n  limits: {\n    maxAgents: 50,\n    maxAPICallsPerDay: 10000\n  }\n});\n</code></pre>"},{"location":"concepts/tenants/#working-in-tenant-context","title":"Working in Tenant Context","text":"TypeScript<pre><code>// Switch to tenant context\nconst acmeTenant = xians.tenant(\"acme-corp\");\n\n// Everything scoped to this tenant\nconst agent = await acmeTenant.createAgent({\n  name: \"SupportAgent\"\n});\n\nconst kb = await acmeTenant.createKnowledgeBase({\n  name: \"product-docs\"\n});\n\n// Another tenant - completely isolated\nconst xyzTenant = xians.tenant(\"startup-xyz\");\nconst xyzAgent = await xyzTenant.createAgent({\n  name: \"CustomerAgent\"\n});\n</code></pre>"},{"location":"concepts/tenants/#why-this-changes-ai-saas-development","title":"Why This Changes AI SaaS Development","text":""},{"location":"concepts/tenants/#traditional-approach-deploy-per-customer","title":"Traditional Approach: Deploy Per Customer","text":"Text Only<pre><code>Customer signs up\n\u2192 Provision new infrastructure\n\u2192 Deploy new instances\n\u2192 Configure databases\n\u2192 Set up monitoring\n\u2192 Days of work, high costs\n</code></pre>"},{"location":"concepts/tenants/#tenant-approach-instant-provisioning","title":"Tenant Approach: Instant Provisioning","text":"TypeScript<pre><code>// Customer signs up\nconst tenant = await xians.createTenant({\n  name: customer.slug,\n  settings: { plan: \"starter\" }\n});\n\n// Done. Ready to use.\n// They have a complete, isolated AI platform.\n</code></pre>"},{"location":"concepts/tenants/#tenant-isolation-guarantees","title":"Tenant Isolation Guarantees","text":""},{"location":"concepts/tenants/#data-isolation","title":"Data Isolation","text":"TypeScript<pre><code>// Queries automatically scoped to tenant\nconst acmeTenant = xians.tenant(\"acme-corp\");\n\n// This ONLY sees ACME's data\nconst conversations = await acmeTenant.getThreads();\nconst documents = await acmeTenant.documentDB.find(\"customers\");\n\n// Physically impossible to access other tenants' data\n</code></pre>"},{"location":"concepts/tenants/#resource-isolation","title":"Resource Isolation","text":"TypeScript<pre><code>// Limits enforced automatically\nconst tenant = await xians.createTenant({\n  name: \"startup\",\n  limits: {\n    maxAPICallsPerDay: 1000,\n    maxAgents: 5,\n    storageGB: 10\n  }\n});\n\n// If they exceed limits\nawait tenant.createAgent({ name: \"6th agent\" });\n// Error: Tenant limit reached. Max 5 agents allowed.\n</code></pre>"},{"location":"concepts/tenants/#cost-isolation","title":"Cost Isolation","text":"TypeScript<pre><code>// Track exactly what each tenant costs\nconst usage = await tenant.getUsage({\n  period: \"month\",\n  breakdown: true\n});\n\nconsole.log({\n  apiCalls: usage.apiCalls,           // 50,000\n  tokens: usage.totalTokens,          // 2,500,000\n  cost: usage.estimatedCost,          // $125.50\n  breakdown: {\n    gpt4: \"$100.00\",\n    embeddings: \"$15.50\",\n    storage: \"$10.00\"\n  }\n});\n</code></pre>"},{"location":"concepts/tenants/#tenant-patterns-that-matter","title":"Tenant Patterns That Matter","text":""},{"location":"concepts/tenants/#pattern-1-self-service-provisioning","title":"Pattern 1: Self-Service Provisioning","text":"<p>Customers sign up, get instant AI platform.</p> TypeScript<pre><code>// New customer signup\napp.post('/signup', async (req, res) =&gt; {\n  const { company, email, plan } = req.body;\n\n  // Create isolated tenant\n  const tenant = await xians.createTenant({\n    name: slugify(company),\n    settings: planConfigs[plan],\n    limits: planLimits[plan]\n  });\n\n  // Add first user\n  await tenant.addUser({\n    email,\n    role: \"admin\"\n  });\n\n  res.json({ tenantId: tenant.id });\n});\n</code></pre>"},{"location":"concepts/tenants/#pattern-2-custom-per-tenant-configuration","title":"Pattern 2: Custom Per-Tenant Configuration","text":"<p>Different AI models, features, branding per customer.</p> TypeScript<pre><code>// Enterprise customer gets GPT-4 + all features\nconst enterpriseTenant = await xians.createTenant({\n  name: \"big-enterprise\",\n  settings: {\n    defaultModel: \"gpt-4-turbo\",\n    features: [\"all\"],\n    customBranding: true\n  }\n});\n\n// Startup gets GPT-3.5 + basic features\nconst startupTenant = await xians.createTenant({\n  name: \"small-startup\",\n  settings: {\n    defaultModel: \"gpt-3.5-turbo\",\n    features: [\"agents\", \"basic-workflows\"]\n  }\n});\n</code></pre>"},{"location":"concepts/tenants/#pattern-3-resource-governance","title":"Pattern 3: Resource Governance","text":"<p>Prevent one customer from affecting others.</p> TypeScript<pre><code>// Set up tiered plans\nconst plans = {\n  starter: {\n    limits: {\n      maxAgents: 3,\n      maxAPICallsPerDay: 1000,\n      storageGB: 5\n    }\n  },\n  professional: {\n    limits: {\n      maxAgents: 25,\n      maxAPICallsPerDay: 50000,\n      storageGB: 100\n    }\n  },\n  enterprise: {\n    limits: {\n      maxAgents: 1000,\n      maxAPICallsPerDay: 1000000,\n      storageGB: 5000\n    }\n  }\n};\n</code></pre>"},{"location":"concepts/tenants/#real-world-example","title":"Real-World Example","text":""},{"location":"concepts/tenants/#building-ai-powered-customer-support-saas","title":"Building AI-Powered Customer Support SaaS","text":"TypeScript<pre><code>// Customer A: E-commerce company\nconst ecommerceTenant = await xians.createTenant({\n  name: \"ecommerce-co\",\n  settings: {\n    industry: \"retail\",\n    defaultModel: \"gpt-4\"\n  }\n});\n\n// Their agents only know about their products\nawait ecommerceTenant.createKnowledgeBase({\n  name: \"products\",\n  documents: ecommerceProductCatalog\n});\n\nawait ecommerceTenant.createAgent({\n  name: \"OrderSupportAgent\",\n  knowledgeBases: [\"products\"]\n});\n\n// Customer B: Healthcare startup  \nconst healthcareTenant = await xians.createTenant({\n  name: \"health-startup\",\n  settings: {\n    industry: \"healthcare\",\n    dataRegion: \"us-east-1\",  // HIPAA compliance\n    encryption: \"customer-managed-keys\"\n  }\n});\n\n// Their agents handle medical info (completely isolated)\nawait healthcareTenant.createAgent({\n  name: \"PatientSupportAgent\",\n  // Zero risk of accessing ecommerce data\n});\n</code></pre>"},{"location":"concepts/tenants/#tenant-management","title":"Tenant Management","text":""},{"location":"concepts/tenants/#user-management","title":"User Management","text":"TypeScript<pre><code>// Add users to tenant\nawait tenant.addUser({\n  email: \"engineer@acme.com\",\n  role: \"developer\",\n  permissions: [\"create:agents\", \"view:analytics\"]\n});\n\n// List tenant users\nconst users = await tenant.getUsers();\n\n// Remove user\nawait tenant.removeUser(\"user_id\");\n</code></pre>"},{"location":"concepts/tenants/#upgradedowngrade-plans","title":"Upgrade/Downgrade Plans","text":"TypeScript<pre><code>// Customer upgrades\nawait tenant.updateLimits({\n  maxAgents: 100,          // Was 50\n  maxAPICallsPerDay: 50000 // Was 10000\n});\n\n// Update features\nawait tenant.updateSettings({\n  features: [\"workflows\", \"knowledge-base\", \"webhooks\", \"custom-models\"]\n});\n</code></pre>"},{"location":"concepts/tenants/#best-practices","title":"Best Practices","text":"<p>\u2705 Design for Multi-Tenancy from Day 1 Even if you have one customer, architect with tenants. Easier than retrofitting later.</p> <p>\u2705 Enforce Limits Automatically Don't just track\u2014enforce. Prevents abuse and surprise bills.</p> <p>\u2705 Track Usage Per Tenant TypeScript<pre><code>// Know exactly what each customer costs\nconst usage = await tenant.getUsage({ period: \"month\" });\nif (usage.cost &gt; tenant.billing.budget) {\n  await tenant.notify(\"Budget exceeded\");\n}\n</code></pre></p> <p>\u2705 Test Isolation Regularly verify tenants can't access each other's data.</p> <p>\u274c Don't Share Tenants One customer = one tenant. Don't mix departments or projects.</p> <p>\u274c Don't Forget to Clean Up When tenant is deleted, purge all their data.</p>"},{"location":"concepts/tenants/#integration-points","title":"Integration Points","text":"<p>Tenants tie together your entire platform:</p> <ul> <li>Agents: Scoped to tenant</li> <li>Workflows: Isolated per tenant</li> <li>Messages: Tenant-specific threads</li> <li>Knowledge: Tenant knowledge bases</li> <li>Document DB: Automatic tenant isolation</li> </ul> <p>The Bottom Line: Tenants let you build one AI platform that serves thousands of customers safely, efficiently, and profitably. It's the architecture that makes AI SaaS possible.</p>"},{"location":"concepts/webhooks/","title":"Webhooks","text":""},{"location":"concepts/webhooks/#event-driven-ai-integration","title":"Event-Driven AI Integration","text":"<p>Your agents need to react to the real world. When a customer makes a purchase, when code gets pushed, when a support ticket arrives\u2014webhooks let your AI respond instantly to external events and notify other systems when work is done.</p>"},{"location":"concepts/webhooks/#the-integration-problem","title":"The Integration Problem","text":"<p>Polling (The Old Way): Text Only<pre><code>Every 5 minutes: \"Any new orders?\" \u2192 \ud83d\udd0d Check API\n\"Any new tickets?\" \u2192 \ud83d\udd0d Check API\n\"Any new payments?\" \u2192 \ud83d\udd0d Check API\n\nSlow. Inefficient. Delayed responses.\n</code></pre></p> <p>Webhooks (The Modern Way): Text Only<pre><code>Order created \u2192 Webhook fires \u2192 Agent processes immediately\nTicket opened \u2192 Webhook fires \u2192 Agent responds in seconds\nPayment received \u2192 Webhook fires \u2192 Workflow starts instantly\n\nFast. Efficient. Real-time.\n</code></pre></p>"},{"location":"concepts/webhooks/#why-webhooks-transform-ai-development","title":"Why Webhooks Transform AI Development","text":""},{"location":"concepts/webhooks/#the-challenge-ai-agents-living-in-a-vacuum","title":"The Challenge: AI Agents Living in a Vacuum","text":"<p>Agents are powerful, but they need to connect with the outside world: - React to events from other systems (Stripe, GitHub, Salesforce) - Notify external services when work completes - Integrate with existing tools and workflows</p>"},{"location":"concepts/webhooks/#the-solution-event-driven-architecture","title":"The Solution: Event-Driven Architecture","text":"<p>Webhooks provide: - Instant Reactions: Trigger agents the moment something happens - Bi-Directional Integration: Receive events AND send notifications - Loose Coupling: Integrate without tight API dependencies - Scalability: Handle thousands of events per second</p>"},{"location":"concepts/webhooks/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/webhooks/#inbound-webhooks-react-to-external-events","title":"Inbound Webhooks: React to External Events","text":"TypeScript<pre><code>// Listen for Stripe payment events\nconst webhook = await xians.createInboundWebhook({\n  name: \"stripe-payments\",\n  endpoint: \"/webhooks/stripe\",\n\n  // Secure it\n  secret: process.env.STRIPE_WEBHOOK_SECRET,\n\n  // Route to workflow\n  handler: \"PaymentProcessingWorkflow\"\n});\n\n// Now when Stripe sends payment.succeeded \u2192\n// Your workflow automatically processes the order\n</code></pre>"},{"location":"concepts/webhooks/#outbound-webhooks-notify-external-systems","title":"Outbound Webhooks: Notify External Systems","text":"TypeScript<pre><code>// Notify Slack when agent fails\nconst webhook = await xians.createOutboundWebhook({\n  name: \"slack-alerts\",\n  url: process.env.SLACK_WEBHOOK_URL,\n\n  // Which events trigger this\n  events: [\"agent.error\", \"workflow.failed\"],\n\n  // Transform for Slack format\n  transform: (event) =&gt; ({\n    text: `\ud83d\udea8 ${event.type}: ${event.message}`\n  })\n});\n</code></pre>"},{"location":"concepts/webhooks/#quick-start","title":"Quick Start","text":""},{"location":"concepts/webhooks/#receive-github-webhooks","title":"Receive GitHub Webhooks","text":"TypeScript<pre><code>const githubWebhook = await xians.createInboundWebhook({\n  name: \"github-events\",\n  endpoint: \"/webhooks/github\",\n\n  // GitHub signature verification\n  authentication: {\n    type: \"signature\",\n    header: \"X-Hub-Signature-256\",\n    secret: process.env.GITHUB_WEBHOOK_SECRET\n  },\n\n  // Process with AI agent\n  handler: async (event) =&gt; {\n    if (event.type === \"pull_request\") {\n      // AI reviews the PR\n      await codeReviewAgent.analyze({\n        repo: event.repository,\n        pr: event.pull_request\n      });\n    }\n\n    if (event.type === \"issue\") {\n      // AI triages the issue\n      await issueTriageAgent.process({\n        issue: event.issue\n      });\n    }\n  }\n});\n</code></pre>"},{"location":"concepts/webhooks/#send-to-external-system","title":"Send to External System","text":"TypeScript<pre><code>// Notify your CRM when lead is qualified\nconst crmWebhook = await xians.createOutboundWebhook({\n  name: \"crm-integration\",\n  url: \"https://api.yourcrm.com/leads\",\n\n  events: [\"agent.lead-qualified\"],\n\n  headers: {\n    \"Authorization\": `Bearer ${process.env.CRM_API_KEY}`,\n    \"Content-Type\": \"application/json\"\n  },\n\n  transform: (event) =&gt; ({\n    name: event.data.leadName,\n    email: event.data.leadEmail,\n    score: event.data.qualificationScore,\n    source: \"ai-agent\",\n    notes: event.data.agentNotes\n  })\n});\n</code></pre>"},{"location":"concepts/webhooks/#why-this-changes-ai-development","title":"Why This Changes AI Development","text":""},{"location":"concepts/webhooks/#before-webhooks-manual-polling","title":"Before Webhooks: Manual Polling","text":"JavaScript<pre><code>// Check for new orders every minute (expensive, slow)\nsetInterval(async () =&gt; {\n  const newOrders = await fetch('https://api.ecommerce.com/orders?new=true');\n\n  for (const order of newOrders) {\n    // Process each order\n    await processOrder(order);\n  }\n}, 60000);  // 60 API calls per hour, always running\n</code></pre>"},{"location":"concepts/webhooks/#with-webhooks-event-driven","title":"With Webhooks: Event-Driven","text":"TypeScript<pre><code>// Receive order immediately when created\nconst webhook = await xians.createInboundWebhook({\n  name: \"new-orders\",\n  endpoint: \"/webhooks/orders\",\n\n  handler: async (order) =&gt; {\n    // Process immediately, only when order exists\n    await orderProcessingAgent.handle(order);\n  }\n});\n\n// 0 API calls when idle, instant response when order arrives\n</code></pre>"},{"location":"concepts/webhooks/#webhook-patterns-that-matter","title":"Webhook Patterns That Matter","text":""},{"location":"concepts/webhooks/#pattern-1-trigger-workflows-from-external-events","title":"Pattern 1: Trigger Workflows from External Events","text":"TypeScript<pre><code>const webhook = await xians.createInboundWebhook({\n  name: \"customer-signup\",\n  endpoint: \"/webhooks/signup\",\n\n  handler: async (event) =&gt; {\n    // New signup triggers multi-step onboarding\n    await xians.startWorkflow({\n      name: \"CustomerOnboardingWorkflow\",\n      input: {\n        customerId: event.data.userId,\n        email: event.data.email,\n        plan: event.data.selectedPlan\n      }\n    });\n  }\n});\n</code></pre>"},{"location":"concepts/webhooks/#pattern-2-chain-systems-together","title":"Pattern 2: Chain Systems Together","text":"TypeScript<pre><code>// 1. Stripe payment received\nconst stripeWebhook = await xians.createInboundWebhook({\n  name: \"stripe-events\",\n  endpoint: \"/webhooks/stripe\",\n\n  handler: async (event) =&gt; {\n    if (event.type === \"payment.succeeded\") {\n      // 2. Provision account\n      await provisioningAgent.create({\n        customerId: event.data.customer\n      });\n\n      // 3. Send to CRM (outbound webhook)\n      await xians.emitWebhookEvent({\n        type: \"customer.provisioned\",\n        data: event.data\n      });\n    }\n  }\n});\n\n// 4. CRM receives update via outbound webhook\nconst crmWebhook = await xians.createOutboundWebhook({\n  name: \"crm-sync\",\n  url: \"https://crm.company.com/api/customers\",\n  events: [\"customer.provisioned\"]\n});\n</code></pre>"},{"location":"concepts/webhooks/#pattern-3-human-in-the-loop-via-webhooks","title":"Pattern 3: Human-in-the-Loop via Webhooks","text":"TypeScript<pre><code>const approvalWebhook = await xians.createInboundWebhook({\n  name: \"approvals\",\n  endpoint: \"/webhooks/approvals\",\n\n  handler: async (event) =&gt; {\n    if (event.action === \"approved\") {\n      // Resume waiting workflow\n      await xians.resumeWorkflow({\n        executionId: event.workflowId,\n        decision: \"approved\"\n      });\n    }\n  }\n});\n</code></pre>"},{"location":"concepts/webhooks/#real-world-examples","title":"Real-World Examples","text":""},{"location":"concepts/webhooks/#customer-support-automation","title":"Customer Support Automation","text":"TypeScript<pre><code>// Zendesk ticket created \u2192 AI agent responds\nconst supportWebhook = await xians.createInboundWebhook({\n  name: \"zendesk-tickets\",\n  endpoint: \"/webhooks/zendesk\",\n\n  handler: async (event) =&gt; {\n    const ticket = event.data.ticket;\n\n    // AI agent analyzes and responds\n    const response = await supportAgent.chat({\n      message: ticket.description,\n      context: {\n        customerId: ticket.requester_id,\n        priority: ticket.priority\n      }\n    });\n\n    // If AI can't handle it, escalate\n    if (response.confidence &lt; 0.8) {\n      await escalateToHuman(ticket);\n    } else {\n      // Post response back to Zendesk\n      await zendesk.updateTicket(ticket.id, {\n        comment: response.message,\n        status: response.resolved ? \"solved\" : \"pending\"\n      });\n    }\n  }\n});\n</code></pre>"},{"location":"concepts/webhooks/#e-commerce-order-processing","title":"E-Commerce Order Processing","text":"TypeScript<pre><code>// Shopify order \u2192 AI processes and fulfills\nconst orderWebhook = await xians.createInboundWebhook({\n  name: \"shopify-orders\",\n  endpoint: \"/webhooks/shopify/orders\",\n\n  authentication: {\n    type: \"signature\",\n    header: \"X-Shopify-Hmac-SHA256\",\n    secret: process.env.SHOPIFY_SECRET\n  },\n\n  handler: \"OrderFulfillmentWorkflow\"\n});\n\n// The workflow:\nconst workflow = await xians.createWorkflow({\n  name: \"OrderFulfillmentWorkflow\",\n  steps: [\n    { \n      id: \"validate\",\n      agent: \"FraudDetectionAgent\",\n      input: \"{{order}}\"\n    },\n    {\n      id: \"inventory\",\n      agent: \"InventoryAgent\",\n      condition: \"{{validate.approved}}\"\n    },\n    {\n      id: \"ship\",\n      agent: \"ShippingAgent\",\n      dependsOn: [\"inventory\"]\n    },\n    {\n      id: \"notify\",\n      agent: \"CustomerNotificationAgent\",\n      dependsOn: [\"ship\"]\n    }\n  ]\n});\n</code></pre>"},{"location":"concepts/webhooks/#webhook-security","title":"Webhook Security","text":""},{"location":"concepts/webhooks/#always-verify-signatures","title":"Always Verify Signatures","text":"TypeScript<pre><code>const webhook = await xians.createInboundWebhook({\n  name: \"secure-webhook\",\n  endpoint: \"/webhooks/secure\",\n\n  // Verify signature automatically\n  authentication: {\n    type: \"signature\",\n    algorithm: \"sha256\",\n    header: \"X-Webhook-Signature\",\n    secret: process.env.WEBHOOK_SECRET\n  }\n});\n\n// Xians verifies every request before calling handler\n// Invalid signatures are automatically rejected\n</code></pre>"},{"location":"concepts/webhooks/#use-https-always","title":"Use HTTPS Always","text":"TypeScript<pre><code>// Good\nurl: \"https://api.yourapp.com/webhooks\"\n\n// Bad - never use HTTP for webhooks\nurl: \"http://api.yourapp.com/webhooks\"  // \u274c Insecure\n</code></pre>"},{"location":"concepts/webhooks/#ip-allowlisting","title":"IP Allowlisting","text":"TypeScript<pre><code>const restrictedWebhook = await xians.createInboundWebhook({\n  name: \"internal-only\",\n  endpoint: \"/webhooks/internal\",\n\n  // Only accept from these IPs\n  ipAllowlist: [\n    \"192.168.1.0/24\",      // Internal network\n    \"203.0.113.0/24\"       // Partner network\n  ]\n});\n</code></pre>"},{"location":"concepts/webhooks/#webhook-reliability","title":"Webhook Reliability","text":""},{"location":"concepts/webhooks/#automatic-retries","title":"Automatic Retries","text":"TypeScript<pre><code>const webhook = await xians.createOutboundWebhook({\n  name: \"critical-notifications\",\n  url: \"https://api.partner.com/events\",\n  events: [\"order.completed\"],\n\n  // Retry on failure\n  retry: {\n    maxAttempts: 5,\n    backoff: \"exponential\",      // 1s, 2s, 4s, 8s, 16s\n    retryableStatuses: [408, 429, 500, 502, 503, 504]\n  }\n});\n</code></pre>"},{"location":"concepts/webhooks/#dead-letter-queue","title":"Dead Letter Queue","text":"TypeScript<pre><code>const webhook = await xians.createOutboundWebhook({\n  name: \"with-dlq\",\n  url: \"https://api.external.com/webhook\",\n\n  // After all retries fail\n  onFailure: {\n    action: \"dlq\",  // Send to dead letter queue\n    alert: [\"ops@company.com\"]\n  }\n});\n\n// Later, replay failed webhooks\nconst failed = await xians.getFailedWebhooks(\"with-dlq\");\nawait xians.replayWebhooks(failed);\n</code></pre>"},{"location":"concepts/webhooks/#monitoring-webhooks","title":"Monitoring Webhooks","text":""},{"location":"concepts/webhooks/#track-everything","title":"Track Everything","text":"TypeScript<pre><code>const metrics = await webhook.getMetrics({\n  period: \"24h\"\n});\n\nconsole.log({\n  totalRequests: metrics.count,\n  successRate: `${metrics.successRate}%`,\n  avgLatency: `${metrics.avgLatency}ms`,\n  failureRate: `${metrics.failureRate}%`,\n  lastError: metrics.lastError\n});\n</code></pre>"},{"location":"concepts/webhooks/#alert-on-failures","title":"Alert on Failures","text":"TypeScript<pre><code>const webhook = await xians.createOutboundWebhook({\n  name: \"monitored-webhook\",\n  url: \"https://api.critical-service.com/events\",\n\n  monitoring: {\n    alertOn: {\n      failureRate: \"&gt;5%\",      // Alert if &gt;5% fail\n      latency: \"&gt;2s\",           // Alert if slow\n      consecutive: 3            // Alert after 3 consecutive failures\n    },\n    notifyChannels: [\"email\", \"slack\"],\n    recipients: [\"oncall@company.com\"]\n  }\n});\n</code></pre>"},{"location":"concepts/webhooks/#best-practices","title":"Best Practices","text":"<p>\u2705 Idempotent Handlers TypeScript<pre><code>// Store webhook IDs to prevent duplicate processing\nhandler: async (event) =&gt; {\n  const alreadyProcessed = await db.exists(\"webhook_id\", event.id);\n  if (alreadyProcessed) return { status: \"duplicate\" };\n\n  await processEvent(event);\n  await db.save(\"webhook_id\", event.id);\n}\n</code></pre></p> <p>\u2705 Fast Response, Async Processing TypeScript<pre><code>handler: async (event) =&gt; {\n  // Queue for background processing\n  await queue.add(\"process-webhook\", event);\n\n  // Respond quickly (&lt; 3 seconds)\n  return { status: \"accepted\" };\n}\n</code></pre></p> <p>\u2705 Log Everything TypeScript<pre><code>handler: async (event) =&gt; {\n  console.log(\"Webhook received:\", {\n    id: event.id,\n    type: event.type,\n    timestamp: new Date()\n  });\n\n  try {\n    await processEvent(event);\n  } catch (error) {\n    console.error(\"Webhook processing failed:\", error);\n    throw error;  // Will trigger retry\n  }\n}\n</code></pre></p> <p>\u274c Don't Block Never do slow operations in webhook handler. Queue them.</p> <p>\u274c Don't Ignore Failures Always monitor and alert on webhook failures.</p>"},{"location":"concepts/webhooks/#integration-points","title":"Integration Points","text":"<p>Webhooks connect everything:</p> <ul> <li>Workflows: Trigger complex processes from external events</li> <li>Agents: Invoke agents based on real-world events</li> <li>Schedules: Use schedules for time-based, webhooks for event-based</li> <li>Messages: Create message threads from webhook events</li> </ul> <p>The Bottom Line: Webhooks make your AI agents reactive to the real world. They're the bridge between your intelligent agents and the events that should trigger them\u2014instantly, reliably, at scale.</p>"},{"location":"concepts/workflows/","title":"Workflows","text":""},{"location":"concepts/workflows/#orchestration-for-the-ai-age","title":"Orchestration for the AI Age","text":"<p>Imagine you need to onboard a new customer. Simple, right? Except it involves validating their data, creating accounts across three systems, sending personalized emails, scheduling follow-ups, and handling edge cases. Traditional automation breaks. Humans get overwhelmed. Workflows with AI agents adapt.</p>"},{"location":"concepts/workflows/#the-orchestration-problem","title":"The Orchestration Problem","text":"<p>Here's why most automation fails:</p> <p>Traditional Workflows: Text Only<pre><code>If X then Y \u2192 Rigid, brittle\nCan't handle exceptions \u2192 Requires human intervention\nNo learning \u2192 Same mistakes repeatedly\n</code></pre></p> <p>AI Agent Workflows: Text Only<pre><code>Agent analyzes situation \u2192 Adapts to context\nHandles ambiguity \u2192 Makes intelligent decisions\nLearns from patterns \u2192 Improves over time\n</code></pre></p>"},{"location":"concepts/workflows/#why-workflows-transform-ai-development","title":"Why Workflows Transform AI Development","text":""},{"location":"concepts/workflows/#challenge-individual-agents-are-powerful-but-limited","title":"Challenge: Individual agents are powerful but limited","text":"<p>A single agent is great at one task. But real business processes require coordination, sequencing, and conditional logic.</p>"},{"location":"concepts/workflows/#solution-workflow-orchestration","title":"Solution: Workflow orchestration","text":"<p>Workflows let you: - Chain agents into sophisticated processes - Branch based on outcomes, not just hardcoded rules - Handle failures gracefully with retries and fallbacks - Parallelize work for speed - Maintain state across complex, multi-step operations</p>"},{"location":"concepts/workflows/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/workflows/#workflows-are-process-blueprints","title":"Workflows Are Process Blueprints","text":"TypeScript<pre><code>const onboarding = await xians.createWorkflow({\n  name: \"CustomerOnboarding\",\n\n  steps: [\n    // Step 1: AI analyzes the application\n    {\n      id: \"review\",\n      agent: \"ApplicationReviewerAgent\",\n      input: \"{{application}}\"\n    },\n\n    // Step 2: If approved, create accounts (parallel)\n    {\n      id: \"provision\",\n      dependsOn: [\"review\"],\n      condition: \"{{review.status}} === 'approved'\",\n      parallel: [\n        { agent: \"CRMSetupAgent\" },\n        { agent: \"BillingSetupAgent\" },\n        { agent: \"AccessProvisioningAgent\" }\n      ]\n    },\n\n    // Step 3: Personalized welcome based on tier\n    {\n      id: \"welcome\",\n      dependsOn: [\"provision\"],\n      agent: \"WelcomeAgent\",\n      input: {\n        customerData: \"{{provision.result}}\",\n        template: \"{{review.recommendedTier}}\"\n      }\n    }\n  ]\n});\n</code></pre>"},{"location":"concepts/workflows/#execution-flow","title":"Execution Flow","text":"Text Only<pre><code>Start \u2192 Review (AI decides) \u2192 \n        \u2193 Approved?\n        \u251c\u2500 Yes \u2192 [Provision (3 agents in parallel)]  \u2192 Welcome \u2192 Done\n        \u2514\u2500 No  \u2192 Rejection Notice \u2192 Done\n</code></pre>"},{"location":"concepts/workflows/#workflow-patterns-that-matter","title":"Workflow Patterns That Matter","text":""},{"location":"concepts/workflows/#pattern-1-sequential-processing","title":"Pattern 1: Sequential Processing","text":"<p>When order matters.</p> TypeScript<pre><code>{\n  steps: [\n    { id: \"extract\", agent: \"DataExtractor\" },\n    { id: \"validate\", agent: \"Validator\", dependsOn: [\"extract\"] },\n    { id: \"enrich\", agent: \"Enricher\", dependsOn: [\"validate\"] },\n    { id: \"store\", agent: \"StorageAgent\", dependsOn: [\"enrich\"] }\n  ]\n}\n</code></pre> <p>Use case: Document processing pipeline where each step builds on the previous.</p>"},{"location":"concepts/workflows/#pattern-2-parallel-fan-out","title":"Pattern 2: Parallel Fan-Out","text":"<p>When speed matters.</p> TypeScript<pre><code>{\n  id: \"analyze-all\",\n  parallel: [\n    { agent: \"SentimentAnalyzer\" },\n    { agent: \"KeywordExtractor\" },\n    { agent: \"CategoryClassifier\" },\n    { agent: \"LanguageDetector\" }\n  ]\n}\n</code></pre> <p>Use case: Analyze content from multiple angles simultaneously.</p>"},{"location":"concepts/workflows/#pattern-3-conditional-branching","title":"Pattern 3: Conditional Branching","text":"<p>When context determines the path.</p> TypeScript<pre><code>{\n  steps: [\n    { id: \"assess\", agent: \"RiskAssessment\" },\n    {\n      id: \"route\",\n      condition: \"{{assess.risk}} === 'high'\",\n      onTrue: { agent: \"SeniorReviewAgent\" },\n      onFalse: { agent: \"AutoApprovalAgent\" }\n    }\n  ]\n}\n</code></pre> <p>Use case: Route work to appropriate handler based on complexity.</p>"},{"location":"concepts/workflows/#pattern-4-human-in-the-loop","title":"Pattern 4: Human-in-the-Loop","text":"<p>When judgment calls matter.</p> TypeScript<pre><code>{\n  steps: [\n    { id: \"initial-review\", agent: \"ContentModerationAgent\" },\n    {\n      id: \"human-check\",\n      condition: \"{{initial-review.confidence}} &lt; 0.8\",\n      type: \"human-approval\",\n      assignTo: \"moderation-team\"\n    },\n    { id: \"publish\", dependsOn: [\"human-check\"] }\n  ]\n}\n</code></pre> <p>Use case: AI does the heavy lifting, humans handle edge cases.</p>"},{"location":"concepts/workflows/#real-world-example","title":"Real-World Example","text":""},{"location":"concepts/workflows/#before-workflows-the-chaos","title":"Before Workflows: The Chaos","text":"JavaScript<pre><code>// Nightmare: Coordinating everything manually\ntry {\n  const analysis = await analyzeAgent.run(data);\n  if (analysis.score &gt; 70) {\n    const account = await createAccount(analysis.data);\n    await Promise.all([\n      sendWelcomeEmail(account),\n      setupBilling(account),\n      createCRMRecord(account)\n    ]);\n    await notifyTeam(account);\n  } else {\n    await rejectApplication(analysis.reason);\n  }\n  await logResult(success);\n} catch (e) {\n  // What failed? Where? What state are we in?\n  await cleanup(???);\n}\n</code></pre>"},{"location":"concepts/workflows/#with-workflows-the-clarity","title":"With Workflows: The Clarity","text":"TypeScript<pre><code>// Clean: Declarative, trackable, resilient\nconst execution = await customerOnboardingWorkflow.start({\n  application: applicationData\n});\n\n// Xians handles:\n// \u2713 Agent coordination\n// \u2713 State management\n// \u2713 Error recovery\n// \u2713 Progress tracking\n// \u2713 Retry logic\n\n// You monitor:\nconst status = await execution.getStatus();\nconsole.log(`Step ${status.currentStep}: ${status.progress}%`);\n</code></pre>"},{"location":"concepts/workflows/#workflow-intelligence","title":"Workflow Intelligence","text":"<p>What makes Xians workflows special? They're AI-native.</p>"},{"location":"concepts/workflows/#smart-transitions","title":"Smart Transitions","text":"TypeScript<pre><code>// Not just \"if status === 'approved'\"\n// But \"agent decides what happens next\"\n{\n  id: \"router\",\n  agent: \"WorkflowRouterAgent\",\n  systemPrompt: `Analyze the customer request and route to:\n    - FastTrackWorkflow for standard cases\n    - CustomSolutionWorkflow for complex cases\n    - EscalationWorkflow for urgent cases`\n}\n</code></pre>"},{"location":"concepts/workflows/#self-healing","title":"Self-Healing","text":"TypeScript<pre><code>{\n  retry: {\n    maxAttempts: 3,\n    backoff: \"exponential\",\n    onFailure: {\n      agent: \"ErrorAnalysisAgent\",  // AI figures out what went wrong\n      fallback: \"NotifyHumansWorkflow\"\n    }\n  }\n}\n</code></pre>"},{"location":"concepts/workflows/#adaptive-behavior","title":"Adaptive Behavior","text":"TypeScript<pre><code>// Workflow learns from outcomes\n{\n  monitoring: {\n    trackSuccess: true,\n    optimizeRouting: true,  // AI adjusts which paths work best\n    suggestImprovements: true\n  }\n}\n</code></pre>"},{"location":"concepts/workflows/#why-this-changes-ai-development","title":"Why This Changes AI Development","text":""},{"location":"concepts/workflows/#traditional-approach","title":"Traditional Approach","text":"<ul> <li>Workflows = rigid state machines</li> <li>Changes = rewrite everything</li> <li>Failures = mystery debugging</li> </ul>"},{"location":"concepts/workflows/#ai-workflow-approach","title":"AI Workflow Approach","text":"<ul> <li>Workflows = adaptive processes</li> <li>Changes = adjust prompts or add agents</li> <li>Failures = agents explain and recover</li> </ul>"},{"location":"concepts/workflows/#configuration-deep-dive","title":"Configuration Deep Dive","text":""},{"location":"concepts/workflows/#state-management","title":"State Management","text":"TypeScript<pre><code>// Share data across steps\n{\n  id: \"analyze\",\n  agent: \"DataAnalyzer\",\n  output: \"analysisResult\"  // Save to workflow state\n}\n{\n  id: \"act\",\n  agent: \"ActionAgent\",\n  input: \"{{analysisResult}}\"  // Reference previous output\n}\n</code></pre>"},{"location":"concepts/workflows/#timeouts--slas","title":"Timeouts &amp; SLAs","text":"TypeScript<pre><code>{\n  steps: [\n    {\n      id: \"urgent-review\",\n      agent: \"ReviewAgent\",\n      timeout: \"5m\",  // Must complete in 5 minutes\n      onTimeout: {\n        escalate: true,\n        notify: [\"ops@company.com\"]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"concepts/workflows/#monitoring--observability","title":"Monitoring &amp; Observability","text":"TypeScript<pre><code>// Track everything\nconst metrics = await workflow.getMetrics();\nconsole.log(`\n  Success rate: ${metrics.successRate}%\n  Avg duration: ${metrics.avgDuration}\n  Bottleneck: ${metrics.slowestStep}\n  Cost per run: $${metrics.avgCost}\n`);\n</code></pre>"},{"location":"concepts/workflows/#best-practices","title":"Best Practices","text":"<p>\u2705 Design for Observability TypeScript<pre><code>// Always track state and progress\n{\n  id: \"important-step\",\n  agent: \"CriticalAgent\",\n  monitoring: {\n    logInputs: true,\n    logOutputs: true,\n    trackDuration: true\n  }\n}\n</code></pre></p> <p>\u2705 Build Resilience TypeScript<pre><code>// Plan for failure\n{\n  retry: { maxAttempts: 3 },\n  fallback: \"alternative-workflow\",\n  timeout: \"10m\"\n}\n</code></pre></p> <p>\u2705 Keep Steps Atomic Each step should do ONE thing well. Better to have 10 simple steps than 3 complex ones.</p> <p>\u274c Don't Create Mega-Workflows Split complex processes into sub-workflows. Easier to test, debug, and reuse.</p> <p>\u274c Don't Ignore Context Windows Each step sees previous outputs. Long workflows = huge context. Plan accordingly.</p>"},{"location":"concepts/workflows/#integration-points","title":"Integration Points","text":"<p>Workflows become powerful when combined with:</p> <ul> <li>Agents: The workers that execute each step</li> <li>Messages: Human-to-workflow communication</li> <li>Schedules: Trigger workflows on a timeline</li> <li>Webhooks: Start workflows from external events</li> <li>Knowledge: Equip workflow agents with domain knowledge</li> </ul> <p>The Bottom Line: Workflows turn your collection of smart agents into coordinated, reliable business processes that adapt to complexity instead of breaking under it.</p>"},{"location":"contributing/how-to-contribute/","title":"How to Contribute","text":"<p>Thank you for your interest in contributing to Xians.ai! This guide will help you get started.</p>"},{"location":"contributing/how-to-contribute/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to Xians.ai:</p> <ul> <li>\ud83d\udcdd Documentation - Improve or add documentation</li> <li>\ud83d\udc1b Bug Reports - Report issues you encounter</li> <li>\u2728 Feature Requests - Suggest new features</li> <li>\ud83d\udcbb Code Contributions - Submit bug fixes or new features</li> <li>\ud83e\uddea Testing - Help test new features and releases</li> <li>\ud83d\udcac Community Support - Help others in discussions</li> </ul>"},{"location":"contributing/how-to-contribute/#getting-started","title":"Getting Started","text":""},{"location":"contributing/how-to-contribute/#1-fork-the-repository","title":"1. Fork the Repository","text":"<p>Fork the repository on GitHub and clone your fork:</p> Bash<pre><code>git clone https://github.com/YOUR_USERNAME/XiansAi.Docs.git\ncd XiansAi.Docs\n</code></pre>"},{"location":"contributing/how-to-contribute/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<p>Create a virtual environment and install dependencies:</p> Bash<pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre>"},{"location":"contributing/how-to-contribute/#3-create-a-branch","title":"3. Create a Branch","text":"<p>Create a new branch for your contribution:</p> Bash<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/how-to-contribute/#documentation-contributions","title":"Documentation Contributions","text":""},{"location":"contributing/how-to-contribute/#writing-documentation","title":"Writing Documentation","text":"<ol> <li>Follow the style guide - Use clear, concise language</li> <li>Include examples - Code examples help users understand</li> <li>Test your changes - Run <code>mkdocs serve</code> to preview locally</li> <li>Check for errors - Run <code>mkdocs build --strict</code></li> </ol>"},{"location":"contributing/how-to-contribute/#documentation-structure","title":"Documentation Structure","text":"Text Only<pre><code>docs/\n\u251c\u2500\u2500 getting-started/    # Installation and quick start guides\n\u251c\u2500\u2500 user-guide/         # User documentation\n\u251c\u2500\u2500 api-reference/      # API documentation\n\u2514\u2500\u2500 contributing/       # Contribution guidelines\n</code></pre>"},{"location":"contributing/how-to-contribute/#style-guide","title":"Style Guide","text":"<ul> <li>Use bold for UI elements and important terms</li> <li>Use <code>code formatting</code> for code, commands, and file names</li> <li>Use &gt; blockquotes for important notes</li> <li>Include code examples where applicable</li> </ul> <p>Example:</p> Markdown<pre><code>## Section Title\n\nBrief description of the section.\n\n### Subsection\n\nDetailed explanation with an example:\n\n\\`\\`\\`python\nfrom xians import Agent\n\nagent = Agent(name=\"MyAgent\")\n\\`\\`\\`\n\n!!! tip\n    This is a helpful tip for users.\n</code></pre>"},{"location":"contributing/how-to-contribute/#code-contributions","title":"Code Contributions","text":""},{"location":"contributing/how-to-contribute/#code-standards","title":"Code Standards","text":"<ul> <li>Follow PEP 8 for Python code</li> <li>Write clear, descriptive commit messages</li> <li>Add tests for new features</li> <li>Update documentation for API changes</li> </ul>"},{"location":"contributing/how-to-contribute/#testing","title":"Testing","text":"<p>Run tests before submitting:</p> Bash<pre><code>pytest\n</code></pre>"},{"location":"contributing/how-to-contribute/#commit-messages","title":"Commit Messages","text":"<p>Use clear commit messages following this format:</p> Text Only<pre><code>&lt;type&gt;: &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes - <code>refactor</code>: Code refactoring - <code>test</code>: Test updates - <code>chore</code>: Build/tooling changes</p> <p>Example:</p> Text Only<pre><code>docs: Add API reference for Agent class\n\n- Add detailed API documentation\n- Include usage examples\n- Add parameter descriptions\n\nCloses #123\n</code></pre>"},{"location":"contributing/how-to-contribute/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/how-to-contribute/#1-push-your-changes","title":"1. Push Your Changes","text":"Bash<pre><code>git add .\ngit commit -m \"docs: improve installation guide\"\ngit push origin feature/your-feature-name\n</code></pre>"},{"location":"contributing/how-to-contribute/#2-create-pull-request","title":"2. Create Pull Request","text":"<ol> <li>Go to the original repository on GitHub</li> <li>Click \"New Pull Request\"</li> <li>Select your branch</li> <li>Fill in the PR template</li> </ol>"},{"location":"contributing/how-to-contribute/#3-pr-template","title":"3. PR Template","text":"Markdown<pre><code>## Description\nBrief description of changes\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Breaking change\n\n## Checklist\n- [ ] Tests pass locally\n- [ ] Documentation updated\n- [ ] No new warnings\n- [ ] Follows code style\n\n## Related Issues\nCloses #123\n</code></pre>"},{"location":"contributing/how-to-contribute/#4-review-process","title":"4. Review Process","text":"<ul> <li>Maintainers will review your PR</li> <li>Address any requested changes</li> <li>Once approved, your PR will be merged</li> </ul>"},{"location":"contributing/how-to-contribute/#community-guidelines","title":"Community Guidelines","text":""},{"location":"contributing/how-to-contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>We expect all contributors to:</p> <ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Focus on what's best for the community</li> <li>Show empathy towards others</li> </ul>"},{"location":"contributing/how-to-contribute/#getting-help","title":"Getting Help","text":"<p>Need help? Here's where to ask:</p> <ul> <li>Discord Community - General questions</li> <li>GitHub Discussions - Technical discussions</li> <li>GitHub Issues - Bug reports</li> </ul>"},{"location":"contributing/how-to-contribute/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>The project's README</li> <li>Release notes</li> <li>Annual contributor list</li> </ul>"},{"location":"contributing/how-to-contribute/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as the project (MIT License).</p>"},{"location":"contributing/how-to-contribute/#questions","title":"Questions?","text":"<p>If you have questions about contributing, please:</p> <ol> <li>Check existing documentation</li> <li>Search GitHub Issues</li> <li>Ask in Discord</li> <li>Open a new Discussion</li> </ol> <p>Thank you for contributing to Xians.ai! \ud83c\udf89</p>"},{"location":"deep-dive/scheduling-deepdive/","title":"Scheduling Deep Dive","text":"<p>This guide provides comprehensive coverage of Xians scheduling capabilities, including advanced patterns, production configurations, error handling, and real-world examples.</p>"},{"location":"deep-dive/scheduling-deepdive/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Architecture Overview</li> <li>Complete Scheduling Patterns</li> <li>Production Configuration</li> <li>Lifecycle Management</li> <li>Error Handling</li> <li>Workflow-Aware Execution</li> <li>Multi-Tenant Security</li> <li>Real-World Examples</li> <li>API Reference</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#architecture-overview","title":"Architecture Overview","text":""},{"location":"deep-dive/scheduling-deepdive/#how-xians-scheduling-works","title":"How Xians Scheduling Works","text":"<p>Xians scheduling is built on Temporal's Schedule feature, which provides:</p> <ol> <li>Durable Storage - Schedules are persisted in Temporal's database</li> <li>Distributed Execution - No single point of failure; runs across cluster</li> <li>Event-Driven - Triggers workflow executions based on time rules</li> <li>Audit Trail - Complete history of schedule changes and executions</li> </ol>"},{"location":"deep-dive/scheduling-deepdive/#xians-enhancements","title":"Xians Enhancements","text":"<p>Xians adds several layers on top of Temporal:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Fluent API (ScheduleBuilder)           \u2502  \u2190 Developer-friendly interface\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Multi-Tenant Isolation                 \u2502  \u2190 Automatic tenant scoping\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Workflow-Aware Context Detection       \u2502  \u2190 Auto-determinism\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Schedule Activities (System)           \u2502  \u2190 Pre-registered activities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Temporal Schedule API                  \u2502  \u2190 Core scheduling engine\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#key-components","title":"Key Components","text":"<p>ScheduleCollection (<code>workflow.Schedules!</code>) - Factory for creating and managing schedules - Tenant-aware querying and filtering - Lifecycle operations (create, get, list, delete)</p> <p>ScheduleBuilder - Fluent API for schedule configuration - Type-safe scheduling options - Terminal <code>.StartAsync()</code> method</p> <p>XiansSchedule - Handle to individual schedule instance - Operations: pause, resume, trigger, update, delete - Information retrieval via <code>DescribeAsync()</code></p> <p>ScheduleActivities - System-registered activities for workflow context - Automatic usage when <code>Workflow.InWorkflow == true</code> - Maintains determinism in workflow executions</p>"},{"location":"deep-dive/scheduling-deepdive/#complete-scheduling-patterns","title":"Complete Scheduling Patterns","text":""},{"location":"deep-dive/scheduling-deepdive/#time-based-schedules-with-timezones","title":"Time-Based Schedules with Timezones","text":"<p>All time-based schedules support IANA timezone configuration:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Temporalio.Workflows;\n\n[Workflow(\"Schedule Setup Workflow\")]\npublic class ScheduleSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Daily at specific time\n        await workflow.Schedules!\n            .Create(\"daily-morning-report\")\n            .Daily(hour: 9, minute: 30, timezone: \"America/New_York\")\n            .WithInput(\"report-type\", \"daily\")\n            .StartAsync();\n\n        // Weekly on specific day\n        await workflow.Schedules!\n            .Create(\"weekly-monday-sync\")\n            .Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n            .WithInput(\"sync-config\")\n            .StartAsync();\n\n        // Monthly on specific day\n        await workflow.Schedules!\n            .Create(\"monthly-first-billing\")\n            .Monthly(dayOfMonth: 1, hour: 8, timezone: \"Asia/Tokyo\")\n            .WithInput(\"billing-params\")\n            .StartAsync();\n\n        // Weekdays only (Monday-Friday)\n        await workflow.Schedules!\n            .Create(\"weekday-check\")\n            .Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n            .WithInput(\"health-check\")\n            .StartAsync();\n\n        // Every hour at specific minute\n        await workflow.Schedules!\n            .Create(\"hourly-quarter-past\")\n            .Hourly(minute: 15)\n            .WithInput(\"monitoring-data\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"All schedules created successfully\");\n    }\n}\n</code></pre> <p>Timezone Behavior: - Default: UTC if timezone not specified - DST Handling: Temporal automatically adjusts for daylight saving time - IANA Names: Use standard names like <code>\"America/New_York\"</code>, not abbreviations like <code>\"EST\"</code></p>"},{"location":"deep-dive/scheduling-deepdive/#interval-based-schedules","title":"Interval-Based Schedules","text":"<p>Duration-based schedules that don't use timezones:</p> C#<pre><code>[Workflow(\"Interval Schedule Setup\")]\npublic class IntervalScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Simple intervals\n        await workflow.Schedules!\n            .Create(\"every-30-seconds\")\n            .EverySeconds(30)\n            .WithInput(\"fast-polling\")\n            .StartAsync();\n\n        await workflow.Schedules!\n            .Create(\"every-30-minutes\")\n            .EveryMinutes(30)\n            .WithInput(\"medium-polling\")\n            .StartAsync();\n\n        await workflow.Schedules!\n            .Create(\"every-2-hours\")\n            .EveryHours(2)\n            .WithInput(\"slow-polling\")\n            .StartAsync();\n\n        // Custom interval with offset\n        await workflow.Schedules!\n            .Create(\"custom-interval\")\n            .WithIntervalSchedule(\n                interval: TimeSpan.FromMinutes(5),\n                offset: TimeSpan.FromSeconds(30)  // Start 30 seconds into each 5-minute window\n            )\n            .WithInput(\"offset-task\")\n            .StartAsync();\n\n        // Every N days (uses Daily internally if days=1)\n        await workflow.Schedules!\n            .Create(\"every-3-days\")\n            .EveryDays(3, hour: 9, minute: 0, timezone: \"America/New_York\")\n            .WithInput(\"tri-daily-task\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Interval schedules created\");\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#cron-expression-schedules","title":"Cron Expression Schedules","text":"<p>Advanced scheduling patterns using 5-field cron expressions:</p> C#<pre><code>[Workflow(\"Cron Schedule Setup\")]\npublic class CronScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Every day at 9 AM UTC\n        await workflow.Schedules!\n            .Create(\"cron-daily\")\n            .WithCronSchedule(\"0 9 * * *\")\n            .WithInput(\"daily-cron\")\n            .StartAsync();\n\n        // Weekdays at 9 AM with timezone\n        await workflow.Schedules!\n            .Create(\"cron-weekdays\")\n            .WithCronSchedule(\"0 9 * * 1-5\", timezone: \"America/New_York\")\n            .WithInput(\"weekday-cron\")\n            .StartAsync();\n\n        // First of month at midnight\n        await workflow.Schedules!\n            .Create(\"cron-monthly\")\n            .WithCronSchedule(\"0 0 1 * *\", timezone: \"America/New_York\")\n            .WithInput(\"monthly-cron\")\n            .StartAsync();\n\n        // Every 30 minutes\n        await workflow.Schedules!\n            .Create(\"cron-30min\")\n            .WithCronSchedule(\"*/30 * * * *\")\n            .WithInput(\"half-hourly\")\n            .StartAsync();\n\n        // Every 2 hours\n        await workflow.Schedules!\n            .Create(\"cron-2hours\")\n            .WithCronSchedule(\"0 */2 * * *\")\n            .WithInput(\"bi-hourly\")\n            .StartAsync();\n\n        // Complex pattern: Every 15 minutes during business hours (9 AM - 5 PM) on weekdays\n        await workflow.Schedules!\n            .Create(\"cron-business-hours\")\n            .WithCronSchedule(\"*/15 9-17 * * 1-5\", timezone: \"America/New_York\")\n            .WithInput(\"business-hours-monitoring\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Cron schedules created\");\n    }\n}\n</code></pre> <p>Cron Format (5 fields): Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n\u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1 - 31)\n\u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n\u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of week (0 - 6) (Sunday=0)\n\u2502 \u2502 \u2502 \u2502 \u2502\n* * * * *\n</code></pre></p>"},{"location":"deep-dive/scheduling-deepdive/#calendar-based-one-time-schedules","title":"Calendar-Based (One-Time) Schedules","text":"<p>Execute at a specific date and time:</p> C#<pre><code>[Workflow(\"Calendar Schedule Setup\")]\npublic class CalendarScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Specific future date and time\n        var scheduledTime = new DateTime(2026, 12, 25, 9, 0, 0);\n\n        await workflow.Schedules!\n            .Create(\"christmas-morning\")\n            .WithCalendarSchedule(scheduledTime, timezone: \"America/New_York\")\n            .WithInput(\"holiday-greeting\")\n            .StartAsync();\n\n        // Relative to current time\n        var futureTime = DateTime.UtcNow.AddHours(24);\n\n        await workflow.Schedules!\n            .Create(\"delayed-start\")\n            .WithCalendarSchedule(futureTime)\n            .WithInput(\"delayed-task\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Calendar schedules created\");\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#production-configuration","title":"Production Configuration","text":""},{"location":"deep-dive/scheduling-deepdive/#complete-production-ready-schedule","title":"Complete Production-Ready Schedule","text":"<p>This example shows all recommended production features:</p> C#<pre><code>using Temporalio.Common;\nusing Temporalio.Workflows;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"Production Schedule Setup\")]\npublic class ProductionScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        var schedule = await workflow.Schedules!\n            .Create(\"production-daily-report\")\n\n            // Schedule timing\n            .Daily(hour: 9, timezone: \"America/New_York\")\n\n            // Workflow input\n            .WithInput(\"report-config\", \"additional-params\")\n\n            // Retry policy - handle transient failures\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 5,\n                InitialInterval = TimeSpan.FromSeconds(10),\n                BackoffCoefficient = 2.0,  // Exponential backoff: 10s, 20s, 40s, 80s, 160s\n                MaximumInterval = TimeSpan.FromMinutes(10)\n            })\n\n            // Timeout - prevent runaway workflows\n            .WithTimeout(TimeSpan.FromHours(2))\n\n            // Overlap policy - prevent execution pile-up\n            .SkipIfRunning()\n\n            // Metadata - tracking and debugging\n            .WithMemo(new Dictionary&lt;string, object&gt;\n            {\n                { \"environment\", \"production\" },\n                { \"owner\", \"data-team\" },\n                { \"priority\", \"high\" },\n                { \"version\", \"2.1.0\" },\n                { \"created_by\", workflow.GetType().Name }\n            })\n\n            // Start the schedule\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Production schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#overlap-policies-explained","title":"Overlap Policies Explained","text":"<p>Control behavior when new execution is triggered while previous is still running:</p> C#<pre><code>// RECOMMENDED: Skip if already running\n// Use case: Most scenarios - prevents pile-up\n.SkipIfRunning()\n\n// Allow concurrent executions\n// Use case: Independent, fast executions\n.AllowOverlap()\n\n// Queue one execution for after current completes\n// Use case: Must process at least once more after current\n.BufferOne()\n\n// Cancel currently running execution, start new one\n// Use case: Newer data supersedes current processing\n.CancelOther()\n\n// Terminate currently running execution (immediate stop)\n// Use case: Rare - forces stop without cleanup\n.TerminateOther()\n\n// Or use the policy method directly\n.WithOverlapPolicy(ScheduleOverlapPolicy.Skip)\n</code></pre> <p>Decision Matrix:</p> Scenario Recommended Policy Daily reports that take hours <code>SkipIfRunning()</code> Fast, independent health checks <code>AllowOverlap()</code> Data sync that must catch up <code>BufferOne()</code> Real-time data where latest matters <code>CancelOther()</code> Emergency shutdown required <code>TerminateOther()</code> (use with caution)"},{"location":"deep-dive/scheduling-deepdive/#retry-policies","title":"Retry Policies","text":"<p>Configure automatic retry behavior for failed executions:</p> C#<pre><code>.WithRetryPolicy(new RetryPolicy\n{\n    // Maximum number of retry attempts\n    MaximumAttempts = 5,\n\n    // Initial delay before first retry\n    InitialInterval = TimeSpan.FromSeconds(10),\n\n    // Multiplier for exponential backoff\n    BackoffCoefficient = 2.0,\n\n    // Cap for maximum delay between retries\n    MaximumInterval = TimeSpan.FromMinutes(10),\n\n    // Optional: Retry only specific exception types\n    // NonRetryableErrorTypes = new[] { \"BusinessLogicException\" }\n})\n</code></pre> <p>Example Retry Sequence: - Attempt 1 fails \u2192 wait 10s - Attempt 2 fails \u2192 wait 20s (10s \u00d7 2.0) - Attempt 3 fails \u2192 wait 40s (20s \u00d7 2.0) - Attempt 4 fails \u2192 wait 80s (40s \u00d7 2.0) - Attempt 5 fails \u2192 wait 160s, but capped at 600s (10 minutes)</p>"},{"location":"deep-dive/scheduling-deepdive/#workflow-timeouts","title":"Workflow Timeouts","text":"<p>Set execution time limits:</p> C#<pre><code>// Absolute timeout for workflow execution\n.WithTimeout(TimeSpan.FromHours(2))\n\n// Workflow will be terminated if it exceeds 2 hours\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#custom-metadata","title":"Custom Metadata","text":"<p>Add tracking information to scheduled workflows:</p> C#<pre><code>.WithMemo(new Dictionary&lt;string, object&gt;\n{\n    { \"environment\", \"production\" },\n    { \"team\", \"data-engineering\" },\n    { \"cost_center\", \"engineering-ops\" },\n    { \"sla\", \"99.9%\" },\n    { \"on_call\", \"team-alpha\" },\n    { \"documentation\", \"https://docs.example.com/workflows/daily-sync\" }\n})\n</code></pre> <p>Metadata is attached to each workflow execution and visible in Temporal UI.</p>"},{"location":"deep-dive/scheduling-deepdive/#start-paused","title":"Start Paused","text":"<p>Create schedule in paused state for later activation:</p> C#<pre><code>[Workflow(\"Approval-Based Schedule Setup\")]\npublic class ApprovalScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(bool approved)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Create paused schedule\n        await workflow.Schedules!\n            .Create(\"pending-approval-schedule\")\n            .Daily(hour: 9, timezone: \"America/New_York\")\n            .WithInput(\"data\")\n            .StartPaused(paused: true, note: \"Awaiting stakeholder approval\")\n            .StartAsync();\n\n        if (approved)\n        {\n            // Activate immediately if already approved\n            var schedule = await workflow.Schedules!.GetAsync(\"pending-approval-schedule\");\n            await schedule.UnpauseAsync(\"Approved by stakeholder on 2026-01-15\");\n\n            Workflow.Logger.LogInformation(\"Schedule approved and activated\");\n        }\n        else\n        {\n            Workflow.Logger.LogInformation(\"Schedule created in paused state, awaiting approval\");\n        }\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"deep-dive/scheduling-deepdive/#retrieve-and-inspect-schedules","title":"Retrieve and Inspect Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Get specific schedule\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Get detailed information\nvar description = await schedule.DescribeAsync();\n\n// Access schedule information\nvar nextRun = description.Info.NextActionTimes.FirstOrDefault();\nvar recentRuns = description.Info.RecentActions;\nvar isPaused = description.Schedule.State.Paused;\nvar pauseNote = description.Schedule.State.Note;\n\nConsole.WriteLine($\"Schedule ID: {schedule.Id}\");\nConsole.WriteLine($\"Next execution: {nextRun}\");\nConsole.WriteLine($\"Status: {(isPaused ? \"Paused\" : \"Active\")}\");\nif (!string.IsNullOrEmpty(pauseNote))\n{\n    Console.WriteLine($\"Note: {pauseNote}\");\n}\n\n// Recent execution history\nConsole.WriteLine(\"Recent executions:\");\nforeach (var action in recentRuns.Take(5))\n{\n    Console.WriteLine($\"  - {action.ActualTime}: {action.TakenAt}\");\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#pause-and-resume","title":"Pause and Resume","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Pause with descriptive note\nawait schedule.PauseAsync(\"System maintenance - database migration in progress\");\n\n// ... perform maintenance ...\n\n// Resume with completion note\nawait schedule.UnpauseAsync(\"Maintenance completed successfully at 2026-01-15 10:30 UTC\");\n\n// Or use collection methods\nawait workflow.Schedules!.PauseAsync(\"my-schedule\", \"Temporary pause for testing\");\nawait workflow.Schedules!.UnpauseAsync(\"my-schedule\", \"Testing complete\");\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#trigger-immediate-execution","title":"Trigger Immediate Execution","text":"<p>Execute schedule immediately without affecting its regular timing:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar schedule = await workflow.Schedules!.GetAsync(\"daily-report\");\n\n// Trigger now (doesn't change next scheduled execution)\nawait schedule.TriggerAsync();\n\nConsole.WriteLine(\"Manual execution triggered\");\n\n// Or via collection\nawait workflow.Schedules!.TriggerAsync(\"daily-report\");\n</code></pre> <p>Use Cases: - Manual report generation - Testing schedule configuration - Catch-up after fixing a bug - User-requested immediate execution</p>"},{"location":"deep-dive/scheduling-deepdive/#update-schedule-configuration","title":"Update Schedule Configuration","text":"<p>Modify existing schedule settings:</p> C#<pre><code>var schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\nawait schedule.UpdateAsync(input =&gt; \n{\n    var updatedSchedule = input.Description.Schedule;\n\n    // Change schedule time (e.g., from 9 AM to 10 AM)\n    updatedSchedule = new Schedule(\n        Action: updatedSchedule.Action,\n        Spec: new ScheduleSpec\n        {\n            CronExpressions = new List&lt;string&gt; \n            { \n                \"0 10 * * *\"  // 10 AM instead of 9 AM\n            },\n            TimeZoneName = \"America/New_York\"\n        })\n    {\n        Policy = updatedSchedule.Policy,\n        State = updatedSchedule.State\n    };\n\n    return new ScheduleUpdate(updatedSchedule);\n});\n\nConsole.WriteLine(\"Schedule updated to 10 AM\");\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#delete-schedules","title":"Delete Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Delete via schedule instance\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\nawait schedule.DeleteAsync();\n\n// Or via collection\nawait workflow.Schedules!.DeleteAsync(\"my-schedule\");\n\n// Check existence first (idempotent deletion)\nif (await workflow.Schedules!.ExistsAsync(\"my-schedule\"))\n{\n    await workflow.Schedules!.DeleteAsync(\"my-schedule\");\n    Console.WriteLine(\"Schedule deleted\");\n}\nelse\n{\n    Console.WriteLine(\"Schedule doesn't exist\");\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#list-all-schedules","title":"List All Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// List all schedules for this workflow (automatically filtered by tenant)\nvar schedules = await workflow.Schedules!.ListAsync();\n\nConsole.WriteLine(\"All schedules:\");\nawait foreach (var scheduleInfo in schedules)\n{\n    Console.WriteLine($\"\\nSchedule ID: {scheduleInfo.Id}\");\n\n    // Get full details\n    var schedule = await workflow.Schedules!.GetAsync(scheduleInfo.Id);\n    var description = await schedule.DescribeAsync();\n\n    var nextRun = description.Info.NextActionTimes.FirstOrDefault();\n    var isPaused = description.Schedule.State.Paused;\n    var memo = description.Memo;\n\n    Console.WriteLine($\"  Next run: {nextRun}\");\n    Console.WriteLine($\"  Status: {(isPaused ? \"Paused\" : \"Active\")}\");\n\n    if (memo?.Fields != null &amp;&amp; memo.Fields.ContainsKey(\"environment\"))\n    {\n        Console.WriteLine($\"  Environment: {memo.Fields[\"environment\"]}\");\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#backfill-missed-executions","title":"Backfill Missed Executions","text":"<p>Execute schedule for past time ranges (useful after system downtime):</p> C#<pre><code>var schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Run schedule for last week (e.g., after outage)\nvar backfills = new List&lt;ScheduleBackfill&gt;\n{\n    new(\n        StartAt: DateTime.UtcNow.AddDays(-7),\n        EndAt: DateTime.UtcNow,\n        Overlap: ScheduleOverlapPolicy.AllowAll  // Allow all backfill executions\n    )\n};\n\nawait schedule.BackfillAsync(backfills);\nConsole.WriteLine(\"Backfill started for past 7 days\");\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#error-handling","title":"Error Handling","text":""},{"location":"deep-dive/scheduling-deepdive/#exception-types","title":"Exception Types","text":"C#<pre><code>using Xians.Lib.Agents.Scheduling.Models;\n\nvar workflow = XiansContext.CurrentWorkflow;\n\ntry\n{\n    var schedule = await workflow.Schedules!\n        .Create(\"my-schedule\")\n        .Daily(hour: 9)\n        .WithInput(\"data\")\n        .StartAsync();\n\n    Console.WriteLine($\"Schedule created: {schedule.Id}\");\n}\ncatch (ScheduleAlreadyExistsException ex)\n{\n    // Schedule with this ID already exists\n    Console.WriteLine($\"Warning: Schedule '{ex.ScheduleId}' already exists\");\n\n    // Option 1: Get existing schedule\n    var existing = await workflow.Schedules!.GetAsync(ex.ScheduleId);\n    Console.WriteLine(\"Using existing schedule\");\n\n    // Option 2: Delete and recreate\n    // await workflow.Schedules!.DeleteAsync(ex.ScheduleId);\n    // var newSchedule = await workflow.Schedules!.Create(ex.ScheduleId)...StartAsync();\n}\ncatch (InvalidScheduleSpecException ex)\n{\n    // Invalid schedule configuration\n    Console.WriteLine($\"Error: Invalid schedule specification: {ex.Message}\");\n    // Examples: Missing spec, invalid cron, invalid parameters\n}\ncatch (ScheduleNotFoundException ex)\n{\n    // Trying to access non-existent schedule\n    Console.WriteLine($\"Error: Schedule '{ex.ScheduleId}' not found\");\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#idempotent-schedule-creation","title":"Idempotent Schedule Creation","text":"<p>Safe creation that handles existing schedules:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar scheduleId = \"my-recurring-task\";\n\n// Pattern 1: Check existence first\nif (!await workflow.Schedules!.ExistsAsync(scheduleId))\n{\n    await workflow.Schedules!\n        .Create(scheduleId)\n        .Daily(hour: 9, timezone: \"America/New_York\")\n        .WithInput(\"data\")\n        .StartAsync();\n\n    Console.WriteLine(\"Schedule created\");\n}\nelse\n{\n    Console.WriteLine(\"Schedule already exists\");\n}\n\n// Pattern 2: Try-catch approach\ntry\n{\n    await workflow.Schedules!\n        .Create(scheduleId)\n        .Daily(hour: 9)\n        .StartAsync();\n}\ncatch (ScheduleAlreadyExistsException)\n{\n    // Already exists - safe to continue\n    Console.WriteLine(\"Schedule already exists\");\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#graceful-degradation","title":"Graceful Degradation","text":"C#<pre><code>async Task&lt;XiansSchedule?&gt; CreateScheduleSafely(string scheduleId)\n{\n    try\n    {\n        return await workflow.Schedules!\n            .Create(scheduleId)\n            .Daily(hour: 9)\n            .WithInput(\"data\")\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 3,\n                InitialInterval = TimeSpan.FromSeconds(10)\n            })\n            .StartAsync();\n    }\n    catch (ScheduleAlreadyExistsException)\n    {\n        _logger.LogInformation(\"Schedule {ScheduleId} already exists\", scheduleId);\n        return await workflow.Schedules!.GetAsync(scheduleId);\n    }\n    catch (InvalidScheduleSpecException ex)\n    {\n        _logger.LogError(ex, \"Invalid schedule specification for {ScheduleId}\", scheduleId);\n        return null;\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError(ex, \"Unexpected error creating schedule {ScheduleId}\", scheduleId);\n        return null;\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#workflow-aware-execution","title":"Workflow-Aware Execution","text":"<p>\u2705 Recommended Pattern: Create schedules from within workflows for automatic determinism and tenant context.</p>"},{"location":"deep-dive/scheduling-deepdive/#inside-workflow-context-recommended","title":"Inside Workflow Context (Recommended)","text":"<p>Workflows create and manage schedules with automatic activity usage for determinism:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\n\n[Workflow(\"Self-Scheduling Workflow\")]\npublic class SelfSchedulingWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;SelfSchedulingWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string taskName, int intervalHours)\n    {\n        _logger.LogInformation(\"Creating recurring schedule for {TaskName}\", taskName);\n\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // SDK detects Workflow.InWorkflow == true\n        // Automatically uses ScheduleActivities for determinism!\n        var schedule = await workflow.Schedules!\n            .Create($\"recurring-{taskName}\")\n            .EveryHours(intervalHours)\n            .WithInput(taskName, intervalHours)\n            .SkipIfRunning()\n            .StartAsync();\n\n        _logger.LogInformation(\"Schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre> <p>How It Works:</p> <ol> <li>SDK checks <code>Workflow.InWorkflow</code> property</li> <li>If true: Automatically delegates to pre-registered <code>ScheduleActivities</code></li> <li>Maintains workflow determinism</li> <li>No manual activity registration needed!</li> </ol> <p>Benefits: - \u2705 Automatic determinism through activities - \u2705 Tenant context automatically available - \u2705 Clean workflow-centric design - \u2705 No external setup required</p>"},{"location":"deep-dive/scheduling-deepdive/#system-activities-auto-registered","title":"System Activities Auto-Registered","text":"<p>System activities are automatically registered - no configuration needed:</p> C#<pre><code>// You DON'T need to do this - activities auto-registered!\n// worker.AddActivity&lt;ScheduleActivities&gt;();\n\n// Just use the schedule API from within your workflow\n[WorkflowRun]\npublic async Task RunAsync()\n{\n    var workflow = XiansContext.CurrentWorkflow;\n\n    var schedule = await workflow.Schedules!\n        .Create(\"auto-schedule\")\n        .Daily(hour: 9)\n        .StartAsync();\n}\n</code></pre> <p>Important: <code>XiansContext.CurrentWorkflow</code> can only be used inside workflows or activities. It will throw <code>InvalidOperationException</code> if used outside workflow context.</p>"},{"location":"deep-dive/scheduling-deepdive/#multi-tenant-security","title":"Multi-Tenant Security","text":""},{"location":"deep-dive/scheduling-deepdive/#automatic-tenant-isolation","title":"Automatic Tenant Isolation","text":"<p>Schedules are automatically scoped to the current tenant when created from workflows:</p> C#<pre><code>[Workflow(\"Multi-Tenant Report Workflow\")]\npublic class MultiTenantReportWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context - automatically includes tenant context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // When this workflow runs for tenant \"acme-corp\"\n        await workflow.Schedules!\n            .Create(\"daily-report\")  // Internal ID: \"acme-corp:daily-report\"\n            .Daily(hour: 9)\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Schedule created for tenant: {TenantId}\", \n            XiansContext.TenantId);\n    }\n}\n\n// When the same workflow runs for tenant \"techco\"\n// It creates: \"techco:daily-report\" (completely separate schedule)\n\n// Both schedules exist independently - complete isolation!\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#tenant-scoped-queries","title":"Tenant-Scoped Queries","text":"<p>All schedule operations respect tenant boundaries:</p> C#<pre><code>// In workflow context for tenant \"acme-corp\"\nvar workflow = XiansContext.CurrentWorkflow;\n\n// List only returns schedules for \"acme-corp\"\nvar schedules = await workflow.Schedules!.ListAsync();\n\n// Get only works for \"acme-corp\" schedules\nvar schedule = await workflow.Schedules!.GetAsync(\"daily-report\");\n// This gets \"acme-corp:daily-report\", NOT \"techco:daily-report\"\n\n// Delete only affects \"acme-corp\" schedules\nawait workflow.Schedules!.DeleteAsync(\"daily-report\");\n// This deletes \"acme-corp:daily-report\", NOT \"techco:daily-report\"\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#security-guarantees","title":"Security Guarantees","text":"<p>Complete Isolation - Tenants cannot access each other's schedules - Schedule IDs automatically prefixed with tenant ID - All operations filtered by current tenant context</p> <p>No Cross-Tenant Leakage - List operations only return current tenant's schedules - Get operations fail for other tenants' schedules - Delete operations cannot affect other tenants</p> <p>Automatic Enforcement - No manual tenant filtering required - SDK enforces security transparently - Works in both workflow and non-workflow contexts</p>"},{"location":"deep-dive/scheduling-deepdive/#real-world-examples","title":"Real-World Examples","text":""},{"location":"deep-dive/scheduling-deepdive/#example-1-daily-report-generation","title":"Example 1: Daily Report Generation","text":"<p>Complete production setup for daily morning reports:</p> C#<pre><code>using Temporalio.Workflows;\nusing Temporalio.Common;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n// Define the report workflow\n[Workflow(\"Daily Report Workflow\")]\npublic class DailyReportWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;DailyReportWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string reportType, string recipients)\n    {\n        _logger.LogInformation(\"Generating {ReportType} report for {Recipients}\", \n            reportType, recipients);\n\n        // Report generation logic...\n        await GenerateReport(reportType);\n        await EmailReport(recipients);\n\n        _logger.LogInformation(\"Report generated and sent\");\n    }\n\n    private async Task GenerateReport(string reportType)\n    {\n        // Implementation...\n        await Task.CompletedTask;\n    }\n\n    private async Task EmailReport(string recipients)\n    {\n        // Implementation...\n        await Task.CompletedTask;\n    }\n}\n\n// Setup schedule (in Program.cs or agent initialization)\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"ReportingAgent\",\n    SystemScoped = true\n});\n\nvar workflow = await agent.Workflows.DefineCustom&lt;DailyReportWorkflow&gt;(workers: 1);\n\nvar schedule = await workflow.Schedules!\n    .Create(\"daily-morning-report\")\n    .Daily(hour: 9, timezone: \"America/New_York\")\n    .WithInput(\"sales-summary\", \"team@company.com\")\n    .WithRetryPolicy(new RetryPolicy\n    {\n        MaximumAttempts = 3,\n        InitialInterval = TimeSpan.FromSeconds(30),\n        BackoffCoefficient = 2.0\n    })\n    .WithTimeout(TimeSpan.FromHours(1))\n    .SkipIfRunning()\n    .WithMemo(new Dictionary&lt;string, object&gt;\n    {\n        { \"team\", \"sales\" },\n        { \"report_type\", \"daily_sales_summary\" },\n        { \"priority\", \"high\" }\n    })\n    .StartAsync();\n\nConsole.WriteLine($\"Daily report schedule created: {schedule.Id}\");\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#example-2-self-scheduling-content-discovery","title":"Example 2: Self-Scheduling Content Discovery","text":"<p>Workflow that creates its own recurring schedule:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"Content Discovery Workflow\")]\npublic class ContentDiscoveryWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;ContentDiscoveryWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string contentUrl, int checkIntervalHours)\n    {\n        _logger.LogInformation(\"Discovering content from {Url}\", contentUrl);\n\n        // Process content\n        var newContent = await DiscoverContent(contentUrl);\n\n        if (newContent != null)\n        {\n            await ProcessNewContent(newContent);\n        }\n\n        // Create recurring schedule for future checks\n        // SDK automatically uses ScheduleActivities for determinism!\n        try\n        {\n            var scheduleId = $\"content-discovery-{SanitizeUrl(contentUrl)}-{checkIntervalHours}h\";\n\n            var schedule = await XiansContext.CurrentWorkflow.Schedules!\n                .Create(scheduleId)\n                .EveryHours(checkIntervalHours)\n                .WithInput(contentUrl, checkIntervalHours)\n                .SkipIfRunning()\n                .WithRetryPolicy(new RetryPolicy\n                {\n                    MaximumAttempts = 3,\n                    InitialInterval = TimeSpan.FromSeconds(10)\n                })\n                .WithMemo(new Dictionary&lt;string, object&gt;\n                {\n                    { \"content_url\", contentUrl },\n                    { \"interval_hours\", checkIntervalHours }\n                })\n                .StartAsync();\n\n            _logger.LogInformation(\"Recurring schedule created: {ScheduleId}\", schedule.Id);\n        }\n        catch (ScheduleAlreadyExistsException ex)\n        {\n            _logger.LogInformation(\"Schedule {ScheduleId} already exists - content discovery will continue\", \n                ex.ScheduleId);\n        }\n        catch (InvalidScheduleSpecException ex)\n        {\n            _logger.LogError(\"Invalid schedule specification: {Message}\", ex.Message);\n            throw;\n        }\n    }\n\n    private async Task&lt;object?&gt; DiscoverContent(string url)\n    {\n        // Content discovery logic...\n        await Task.CompletedTask;\n        return new { Title = \"Sample Content\" };\n    }\n\n    private async Task ProcessNewContent(object content)\n    {\n        // Process discovered content...\n        await Task.CompletedTask;\n    }\n\n    private string SanitizeUrl(string url)\n    {\n        // Convert URL to safe schedule ID component\n        return url.Replace(\"https://\", \"\")\n                  .Replace(\"http://\", \"\")\n                  .Replace(\"/\", \"-\")\n                  .Replace(\".\", \"-\");\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#example-3-multi-entity-scheduling","title":"Example 3: Multi-Entity Scheduling","text":"<p>Create schedules for multiple entities dynamically within a workflow:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\nusing Temporalio.Common;\nusing Temporalio.Workflows;\n\n[Workflow(\"Company Research Setup Workflow\")]\npublic class CompanyResearchSetupWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;CompanyResearchSetupWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Create schedules for multiple companies\n        var companies = new[] \n        { \n            new { Name = \"ACME Corp\", Ticker = \"ACME\" },\n            new { Name = \"TechCo\", Ticker = \"TECH\" },\n            new { Name = \"GlobalInc\", Ticker = \"GLOB\" }\n        };\n\n        foreach (var company in companies)\n        {\n            var scheduleId = $\"research-{company.Ticker.ToLower()}\";\n\n            try\n            {\n                var schedule = await workflow.Schedules!\n                    .Create(scheduleId)\n                    .Weekdays(hour: 8, minute: 30, timezone: \"America/New_York\")\n                    .WithInput(company.Name, company.Ticker)\n                    .WithRetryPolicy(new RetryPolicy\n                    {\n                        MaximumAttempts = 3,\n                        InitialInterval = TimeSpan.FromSeconds(15),\n                        BackoffCoefficient = 2.0\n                    })\n                    .SkipIfRunning()\n                    .WithMemo(new Dictionary&lt;string, object&gt;\n                    {\n                        { \"company_name\", company.Name },\n                        { \"ticker\", company.Ticker },\n                        { \"research_type\", \"daily_market_analysis\" }\n                    })\n                    .StartAsync();\n\n                _logger.LogInformation(\"Schedule created for {Company} ({ScheduleId})\", \n                    company.Name, schedule.Id);\n            }\n            catch (ScheduleAlreadyExistsException)\n            {\n                _logger.LogWarning(\"Schedule for {Company} already exists\", company.Name);\n            }\n        }\n\n        _logger.LogInformation(\"Created {Count} research schedules\", companies.Length);\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#example-4-scheduled-monitoring-with-alerts","title":"Example 4: Scheduled Monitoring with Alerts","text":"<p>Health monitoring that runs every 5 minutes:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\n\n[Workflow(\"System Health Check\")]\npublic class HealthCheckWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;HealthCheckWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string[] services)\n    {\n        _logger.LogInformation(\"Running health check for {ServiceCount} services\", services.Length);\n\n        var unhealthyServices = new List&lt;string&gt;();\n\n        foreach (var service in services)\n        {\n            var isHealthy = await CheckServiceHealth(service);\n\n            if (!isHealthy)\n            {\n                unhealthyServices.Add(service);\n                _logger.LogWarning(\"Service {Service} is unhealthy\", service);\n            }\n        }\n\n        if (unhealthyServices.Any())\n        {\n            await SendAlert(unhealthyServices);\n        }\n\n        _logger.LogInformation(\"Health check complete\");\n    }\n\n    private async Task&lt;bool&gt; CheckServiceHealth(string service)\n    {\n        // Health check logic...\n        await Task.CompletedTask;\n        return true;\n    }\n\n    private async Task SendAlert(List&lt;string&gt; unhealthyServices)\n    {\n        // Alert logic...\n        await Task.CompletedTask;\n    }\n}\n\n// Setup within a workflow\n[Workflow(\"Health Check Setup Workflow\")]\npublic class HealthCheckSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string[] services)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        var schedule = await workflow.Schedules!\n            .Create(\"health-check-5min\")\n            .EveryMinutes(5)\n            .WithInput(services)\n            .AllowOverlap()  // Health checks are independent and fast\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 2,  // Fail fast for health checks\n                InitialInterval = TimeSpan.FromSeconds(5)\n            })\n            .WithTimeout(TimeSpan.FromMinutes(2))\n            .WithMemo(new Dictionary&lt;string, object&gt;\n            {\n                { \"monitor_type\", \"health_check\" },\n                { \"alert_channel\", \"ops-alerts\" }\n            })\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Health check schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#example-5-schedule-management-dashboard","title":"Example 5: Schedule Management Dashboard","text":"<p>List and manage all schedules:</p> C#<pre><code>using Xians.Lib.Agents;\n\npublic class ScheduleManager\n{\n    private readonly XiansWorkflowContext _workflow;\n\n    public ScheduleManager(XiansWorkflowContext workflow)\n    {\n        _workflow = workflow;\n    }\n\n    public async Task DisplayAllSchedules()\n    {\n        Console.WriteLine(\"=== All Schedules ===\\n\");\n\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            var description = await schedule.DescribeAsync();\n\n            var nextRun = description.Info.NextActionTimes.FirstOrDefault();\n            var isPaused = description.Schedule.State.Paused;\n            var pauseNote = description.Schedule.State.Note;\n\n            Console.WriteLine($\"Schedule: {schedule.Id}\");\n            Console.WriteLine($\"   Status: {(isPaused ? \"Paused\" : \"Active\")}\");\n            Console.WriteLine($\"   Next run: {nextRun?.ToString() ?? \"N/A\"}\");\n\n            if (!string.IsNullOrEmpty(pauseNote))\n            {\n                Console.WriteLine($\"   Note: {pauseNote}\");\n            }\n\n            // Display memo if available\n            if (description.Memo?.Fields != null)\n            {\n                Console.WriteLine(\"   Metadata:\");\n                foreach (var kvp in description.Memo.Fields)\n                {\n                    Console.WriteLine($\"     - {kvp.Key}: {kvp.Value}\");\n                }\n            }\n\n            // Recent execution history\n            if (description.Info.RecentActions.Any())\n            {\n                Console.WriteLine(\"   Recent executions:\");\n                foreach (var action in description.Info.RecentActions.Take(3))\n                {\n                    Console.WriteLine($\"     - {action.ActualTime}\");\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n\n    public async Task PauseAllSchedules(string reason)\n    {\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            await schedule.PauseAsync(reason);\n            Console.WriteLine($\"Paused: {scheduleInfo.Id}\");\n        }\n    }\n\n    public async Task ResumeAllSchedules(string reason)\n    {\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            await schedule.UnpauseAsync(reason);\n            Console.WriteLine($\"Resumed: {scheduleInfo.Id}\");\n        }\n    }\n}\n\n// Usage\nvar workflow = XiansContext.CurrentWorkflow;\nvar manager = new ScheduleManager(workflow);\n\nawait manager.DisplayAllSchedules();\n\n// Pause all for maintenance\nawait manager.PauseAllSchedules(\"Database migration in progress\");\n\n// Resume after maintenance\nawait manager.ResumeAllSchedules(\"Migration completed successfully\");\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#api-reference","title":"API Reference","text":""},{"location":"deep-dive/scheduling-deepdive/#schedulecollection","title":"ScheduleCollection","text":"<p>Access: <code>workflow.Schedules!</code> or <code>XiansContext.CurrentWorkflow.Schedules!</code></p>"},{"location":"deep-dive/scheduling-deepdive/#creation","title":"Creation","text":"<ul> <li><code>Create(scheduleId)</code> \u2192 <code>ScheduleBuilder</code> - Start building new schedule</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#retrieval","title":"Retrieval","text":"<ul> <li><code>GetAsync(scheduleId)</code> \u2192 <code>Task&lt;XiansSchedule&gt;</code> - Get schedule (async)</li> <li><code>Get(scheduleId)</code> \u2192 <code>XiansSchedule</code> - Get schedule (sync)</li> <li><code>ListAsync()</code> \u2192 <code>Task&lt;IAsyncEnumerable&lt;ScheduleListDescription&gt;&gt;</code> - List all schedules</li> <li><code>ExistsAsync(scheduleId)</code> \u2192 <code>Task&lt;bool&gt;</code> - Check existence</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#management","title":"Management","text":"<ul> <li><code>PauseAsync(scheduleId, note?)</code> \u2192 <code>Task</code> - Pause schedule</li> <li><code>UnpauseAsync(scheduleId, note?)</code> \u2192 <code>Task</code> - Resume schedule</li> <li><code>TriggerAsync(scheduleId)</code> \u2192 <code>Task</code> - Trigger immediate execution</li> <li><code>DeleteAsync(scheduleId)</code> \u2192 <code>Task</code> - Delete schedule</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#schedulebuilder","title":"ScheduleBuilder","text":""},{"location":"deep-dive/scheduling-deepdive/#schedule-timing-methods-choose-one","title":"Schedule Timing Methods (choose one)","text":"<p>Convenience Extensions: - <code>.Daily(hour, minute = 0, timezone?)</code> - Daily at specific time - <code>.Weekly(dayOfWeek, hour, minute = 0, timezone?)</code> - Weekly on day - <code>.Monthly(dayOfMonth, hour, minute = 0, timezone?)</code> - Monthly on day - <code>.Hourly(minute = 0)</code> - Every hour at minute - <code>.Weekdays(hour, minute = 0, timezone?)</code> - Monday-Friday - <code>.EverySeconds(seconds)</code> - Interval in seconds - <code>.EveryMinutes(minutes)</code> - Interval in minutes - <code>.EveryHours(hours)</code> - Interval in hours - <code>.EveryDays(days, hour = 0, minute = 0, timezone?)</code> - Interval in days</p> <p>Core Methods: - <code>.WithCronSchedule(expression, timezone?)</code> - Cron expression - <code>.WithIntervalSchedule(interval, offset?)</code> - Duration interval - <code>.WithCalendarSchedule(dateTime, timezone?)</code> - Specific date/time - <code>.WithScheduleSpec(spec)</code> - Custom Temporal spec</p>"},{"location":"deep-dive/scheduling-deepdive/#workflow-configuration","title":"Workflow Configuration","text":"<ul> <li><code>.WithInput(params object[] args)</code> - Workflow input arguments</li> <li><code>.WithMemo(Dictionary&lt;string, object&gt;)</code> - Custom metadata</li> <li><code>.WithRetryPolicy(RetryPolicy)</code> - Retry policy</li> <li><code>.WithTimeout(TimeSpan)</code> - Execution timeout</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#overlap-policies","title":"Overlap Policies","text":"<ul> <li><code>.SkipIfRunning()</code> - Skip if running (recommended)</li> <li><code>.AllowOverlap()</code> - Allow concurrent executions</li> <li><code>.BufferOne()</code> - Queue one execution</li> <li><code>.CancelOther()</code> - Cancel running, start new</li> <li><code>.TerminateOther()</code> - Terminate running (caution)</li> <li><code>.WithOverlapPolicy(ScheduleOverlapPolicy)</code> - Set policy</li> <li><code>.WithSchedulePolicy(SchedulePolicy)</code> - Advanced policy</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#schedule-state","title":"Schedule State","text":"<ul> <li><code>.StartPaused(paused = true, note?)</code> - Create paused</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#execution","title":"Execution","text":"<ul> <li><code>.StartAsync()</code> - Create and start schedule (required)</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#xiansschedule","title":"XiansSchedule","text":""},{"location":"deep-dive/scheduling-deepdive/#properties","title":"Properties","text":"<ul> <li><code>Id</code> \u2192 <code>string</code> - Schedule identifier</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#information","title":"Information","text":"<ul> <li><code>DescribeAsync()</code> \u2192 <code>Task&lt;ScheduleDescription&gt;</code> - Get details</li> <li><code>Info.NextActionTimes</code> - Upcoming executions</li> <li><code>Info.RecentActions</code> - Execution history</li> <li><code>Schedule.State.Paused</code> - Paused status</li> <li><code>Schedule.State.Note</code> - State note</li> <li><code>Schedule.Spec</code> - Schedule specification</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#operations","title":"Operations","text":"<ul> <li><code>PauseAsync(note?)</code> \u2192 <code>Task</code> - Pause</li> <li><code>UnpauseAsync(note?)</code> \u2192 <code>Task</code> - Resume</li> <li><code>TriggerAsync()</code> \u2192 <code>Task</code> - Trigger now</li> <li><code>UpdateAsync(updater)</code> \u2192 <code>Task</code> - Modify config</li> <li><code>DeleteAsync()</code> \u2192 <code>Task</code> - Delete</li> <li><code>BackfillAsync(backfills)</code> \u2192 <code>Task</code> - Execute for past ranges</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#advanced","title":"Advanced","text":"<ul> <li><code>GetHandle()</code> \u2192 <code>ScheduleHandle</code> - Temporal handle</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#exceptions","title":"Exceptions","text":"<p>Namespace: <code>Xians.Lib.Agents.Scheduling.Models</code></p> <ul> <li><code>ScheduleAlreadyExistsException</code> - Schedule ID exists</li> <li><code>ScheduleNotFoundException</code> - Schedule not found</li> <li><code>InvalidScheduleSpecException</code> - Invalid configuration</li> </ul>"},{"location":"deep-dive/scheduling-deepdive/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"deep-dive/scheduling-deepdive/#1-always-configure-overlap-policies","title":"1. Always Configure Overlap Policies","text":"C#<pre><code>.SkipIfRunning()  // Recommended for most cases\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#2-add-retry-policies-for-production","title":"2. Add Retry Policies for Production","text":"C#<pre><code>.WithRetryPolicy(new RetryPolicy\n{\n    MaximumAttempts = 3,\n    InitialInterval = TimeSpan.FromSeconds(10),\n    BackoffCoefficient = 2.0\n})\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#3-use-timezones-for-user-facing-schedules","title":"3. Use Timezones for User-Facing Schedules","text":"C#<pre><code>.Daily(hour: 9, timezone: \"America/New_York\")\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#4-check-existence-for-idempotency","title":"4. Check Existence for Idempotency","text":"C#<pre><code>if (!await workflow.Schedules!.ExistsAsync(\"my-schedule\"))\n{\n    await workflow.Schedules!.Create(\"my-schedule\")...StartAsync();\n}\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#5-use-meaningful-schedule-ids","title":"5. Use Meaningful Schedule IDs","text":"C#<pre><code>.Create($\"daily-sync-{companyId}\")  // Good\n.Create(\"schedule1\")                // Bad\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#6-add-metadata-with-memo","title":"6. Add Metadata with Memo","text":"C#<pre><code>.WithMemo(new Dictionary&lt;string, object&gt;\n{\n    { \"owner\", \"team-name\" },\n    { \"purpose\", \"data-sync\" }\n})\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#7-set-appropriate-timeouts","title":"7. Set Appropriate Timeouts","text":"C#<pre><code>.WithTimeout(TimeSpan.FromHours(2))\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#8-use-descriptive-pause-notes","title":"8. Use Descriptive Pause Notes","text":"C#<pre><code>await schedule.PauseAsync(\"Database migration - ETA 2 hours\");\n</code></pre>"},{"location":"deep-dive/scheduling-deepdive/#conclusion","title":"Conclusion","text":"<p>Xians scheduling provides production-grade time-based automation for AI agents with:</p> <ul> <li>Flexible scheduling - Cron, intervals, calendars, convenience methods</li> <li>Production features - Retries, timeouts, overlap policies</li> <li>Multi-tenant security - Automatic isolation and filtering</li> <li>Developer experience - Fluent API, auto-determinism, zero config</li> <li>Enterprise reliability - Built on Temporal's proven scheduling engine</li> </ul> <p>Use schedules to transform reactive agents into autonomous, proactive systems that operate on your timeline.</p> <p>Next Steps:</p> <ul> <li>Scheduling Concepts - Quick start guide</li> <li>Workflows - Workflow orchestration</li> <li>Agents - Agent architecture</li> <li>Tenants - Multi-tenant patterns</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get started with Xians.ai by choosing the installation path that best fits your needs.</p>"},{"location":"getting-started/installation/#choose-your-path","title":"Choose Your Path","text":"<p>Xians.ai offers two deployment options:</p> <ol> <li>SaaS Platform - Quick start with hosted infrastructure (Recommended for 99x employees and customers)</li> <li>Community Edition - Self-hosted deployment for development and testing</li> </ol>"},{"location":"getting-started/installation/#option-1-saas-platform","title":"Option 1: SaaS Platform","text":"<p>If you already have an account, the fastest way to get started is using our hosted SaaS platform at agentri.ai.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Active account at agentri.ai</li> <li>API key for authentication</li> </ul>"},{"location":"getting-started/installation/#getting-started","title":"Getting Started","text":"<ol> <li>Sign in at agentri.ai</li> <li>Obtain your API key from the tenant settings page</li> <li>Start building - You're ready to create your first agent! Follow Quick Start.</li> </ol>"},{"location":"getting-started/installation/#option-2-community-edition-self-hosted","title":"Option 2: Community Edition (Self-Hosted)","text":"<p>For local development, testing, or self-hosted deployments, use the Community Edition.</p>"},{"location":"getting-started/installation/#prerequisites_1","title":"Prerequisites","text":"<p>Before setting up the Community Edition, ensure you have:</p> <ul> <li>Operating System: Windows, macOS, or Linux</li> <li>Docker &amp; Docker Compose: Latest versions installed</li> <li>System Resources: Minimum 8GB RAM recommended</li> <li>OpenAI API Key: Required for LLM capabilities (optional)</li> </ul>"},{"location":"getting-started/installation/#quick-setup-with-docker-compose","title":"Quick Setup with Docker Compose","text":"<p>The Community Edition provides a one-command setup that includes all essential components:</p> <ul> <li>Xians Server - Core platform API and orchestration</li> <li>Xians UI - Web-based management interface</li> <li>Temporal - Workflow orchestration engine</li> <li>Keycloak - Authentication and authorization</li> <li>Database Components - Data persistence layer</li> </ul>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":"<p>For detailed setup instructions, configuration options, and troubleshooting, visit:</p> <p>\ud83d\udcda XiansAi Platform - Community Edition</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once your platform is running locally, proceed to the Quick Start guide to create your first agent.</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues:</p> <ul> <li>Community Edition: See the Git Repo</li> <li>Issues: Open an issue on GitHub</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with your first Xians agent in minutes. This guide walks you through creating a simple conversational agent and connecting it to the Xians platform.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>.NET 9 SDK - Download here</li> <li>OpenAI API Key - Get one from OpenAI Platform</li> </ul>"},{"location":"getting-started/quick-start/#step-1-create-your-project","title":"Step 1: Create Your Project","text":"<p>Xians agents run as standard .NET applications that can be executed locally or deployed to any server environment. Start by creating a new console project:</p> Bash<pre><code>dotnet new console -n MyAgent\ncd MyAgent\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-build-a-simple-agent-with-maf","title":"Step 2: Build a Simple Agent with MAF","text":"<p>You can use any framework that supports .NET Core to create your agent. In this guide, we'll use the Microsoft Agent Framework (MAF).</p>"},{"location":"getting-started/quick-start/#install-required-packages","title":"Install Required Packages","text":"Bash<pre><code>dotnet add package Azure.AI.OpenAI --prerelease\ndotnet add package Azure.Identity\ndotnet add package Microsoft.Agents.AI.OpenAI --prerelease\n</code></pre>"},{"location":"getting-started/quick-start/#create-the-agent-class","title":"Create the Agent Class","text":"<p>Create a new file called <code>MafAgent.cs</code>:</p> Bash<pre><code>touch MafAgent.cs\n</code></pre> <p>Add the following code to <code>MafAgent.cs</code>:</p> C#<pre><code>using Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing OpenAI;\nusing OpenAI.Chat;\n\nnamespace Xians.SimpleAgent;\n\npublic class MafAgent\n{\n    private readonly AIAgent _agent;\n\n    public MafAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        var chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n\n        _agent = chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = \"You are a helpful assistant.\"\n            }\n        });\n    }\n\n    public async Task&lt;string&gt; RunAsync(string message)\n    {\n        var response = await _agent.RunAsync(message);\n        return response.Text;\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#update-programcs","title":"Update Program.cs","text":"<p>Replace the contents of <code>Program.cs</code> with:</p> C#<pre><code>using Xians.SimpleAgent;\n\n// Get OpenAI API key (replace with your actual key)\nvar apiKey = \"your-openai-api-key\";\n\n// Create the agent\nvar agent = new MafAgent(apiKey);\n\n// Process a user message\nvar response = await agent.RunAsync(\"Hello! Can you write a one sentence story about a cat?\");\nConsole.WriteLine($\"Agent: {response}\");\n</code></pre>"},{"location":"getting-started/quick-start/#test-your-agent","title":"Test Your Agent","text":"<p>Build and run your agent to verify it works:</p> Bash<pre><code>dotnet build\ndotnet run\n</code></pre> <p>You should see a creative response from your agent!</p> <p>Note: At this point, we've built a simple agent using MAF without any Xians SDK constructs. This demonstrates the core principle of Xians: work with your existing agent frameworks. Next, we'll enhance this agent with the power of the Xians platform.</p>"},{"location":"getting-started/quick-start/#step-3-connect-your-agent-to-xians","title":"Step 3: Connect Your Agent to Xians","text":"<p>While a standalone agent is great for demos, production systems require multi-tenancy, user management, conversation threading, and more. Building this infrastructure from scratch is time-consuming, but Xians provides all of this out of the box.</p>"},{"location":"getting-started/quick-start/#install-the-xians-sdk","title":"Install the Xians SDK","text":"Bash<pre><code>dotnet add package Xians.Lib\n</code></pre> <p>Note: Xians.Lib version 3+ is published under <code>Xians.Lib</code>, not <code>XiansAi.Lib</code> like previous versions.</p>"},{"location":"getting-started/quick-start/#get-your-xians-api-key","title":"Get Your Xians API Key","text":"<p>Before proceeding, you need to:</p> <ol> <li>Set up your Xians platform instance</li> <li>Navigate to Tenant Settings in the platform UI</li> <li>Copy your Agent API Key and Server URL</li> </ol> <p></p>"},{"location":"getting-started/quick-start/#update-programcs_1","title":"Update Program.cs","text":"<p>Replace the entire contents of <code>Program.cs</code> with the following:</p> C#<pre><code>using Xians.Lib.Agents.Core;\nusing Xians.SimpleAgent;\n\n// Configuration - replace with your actual values\nvar openAiApiKey = \"your-openai-api-key\";\nvar serverUrl = \"https://your-xians-server.com\";\nvar xiansApiKey = \"your-xians-api-key\";\n\n// Initialize Xians Platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new ()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey\n});\n\n// Register a new agent with Xians\nvar xiansAgent = xiansPlatform.Agents.Register(new ()\n{\n    Name = \"My Conversational Agent\",\n    SystemScoped = true  // See important notes below\n});\n\n// Define a built-in conversational workflow\nvar conversationalWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Conversational\");\n\n// Create your MAF agent instance\nvar mafAgent = new MafAgent(openAiApiKey);\n\n// Handle incoming user messages\nconversationalWorkflow.OnUserMessage(async (context) =&gt;\n{\n    var response = await mafAgent.RunAsync(context.Message.Text);\n    await context.ReplyAsync(response);\n});\n\n// Start the agent and all workflows\nawait xiansAgent.RunAllAsync();\n</code></pre>"},{"location":"getting-started/quick-start/#important-configuration-notes","title":"Important Configuration Notes","text":"<p>SystemScoped Setting:</p> <ul> <li> <p><code>SystemScoped = true</code>: Adds the agent to the global Agent Templates library, making it available for any tenant admin to deploy. This option is only available if you're a system administrator.</p> </li> <li> <p><code>SystemScoped = false</code> (default): Immediately deploys the agent to your current tenant. Use this if you only have tenant-level permissions.</p> </li> </ul> <p>Understanding Workflows:</p> <ul> <li>A Xians agent is a definition that represents your agent in the platform</li> <li>The actual AI logic runs in your MAF agent (or any other framework you choose)</li> <li>Built-in workflows connect Xians' conversation handling capabilities to your agent logic</li> <li>One Xians agent can contain multiple built-in workflows, each connected to different AI agent implementations</li> </ul>"},{"location":"getting-started/quick-start/#step-4-deploy-your-agent","title":"Step 4: Deploy Your Agent","text":""},{"location":"getting-started/quick-start/#for-system-scoped-agents","title":"For System-Scoped Agents","text":"<p>If you registered your agent with <code>SystemScoped = true</code>, you'll find it in the Agent Templates section:</p> <p></p> <p>Tenant administrators can then deploy instances of this template to their tenants.</p>"},{"location":"getting-started/quick-start/#for-tenant-scoped-agents","title":"For Tenant-Scoped Agents","text":"<p>If you used <code>SystemScoped = false</code>, or after deploying a system template, your agent appears under Deployed Agents:</p> <p></p> <p>What You've Achieved: Xians has transformed your simple MAF agent into a multi-tenant, enterprise-ready solution. You can now manage agent lifecycles across different tenant scopes through the platform UI.</p>"},{"location":"getting-started/quick-start/#step-5-start-a-conversation","title":"Step 5: Start a Conversation","text":"<p>Now for the exciting part - talking to your agent!</p> <ol> <li>Navigate to Conversations in the platform UI</li> <li>Select your deployed agent from the list</li> <li>Click the + button to create a new conversation</li> <li>Start chatting with your agent!</li> </ol> <p></p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've successfully created and deployed your first Xians agent. Here's what you can explore next:</p> <ul> <li>Add Tools &amp; Functions - Extend your agent with custom capabilities</li> <li>Implement Chat History - Connect chat history for context-aware responses</li> </ul> <p>Ready to dive deeper? Check out our Core Concepts or explore Advanced Workflows.</p>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":""},{"location":"introduction/features/","title":"Features","text":"<p>Xians is a control plane for AI agents. It sits alongside your agent framework - not replacing it. It handles everything that becomes painful once agents graduate from demos to production.</p> <p>When you register an agent (say, one built with Azure AI Projects) with Xians and it gets following capabilities:</p> <ul> <li>Agent Registry - Framework-agnostic registration and identity management</li> <li>Multi-tenancy - Complete isolation across customers</li> <li>Agent-User Collaboration - Rich messaging and conversations</li> <li>Agent-Agent Collaboration - Coordinated multi-agent systems</li> <li>Human-in-the-Loop - Workflow pauses for human review</li> <li>Long-Running Workflows - Processes that span days or months</li> <li>Scheduling - Time-based agent activation</li> <li>Webhooks - Event-driven triggers and integrations</li> <li>Document DB - Flexible storage for structured data</li> <li>Prompt Management - Centralized prompt versioning and optimization</li> <li>Sub-Workflows - Composable, reusable workflow components</li> <li>Observability - Complete visibility into agent operations</li> </ul> <p>No changes to your agent's code. Because Xians is framework-agnostic, you can mix agents built on different stacks in the same system.</p>"},{"location":"introduction/features/#agent-registry","title":"Agent Registry","text":"<p>Your agents, regardless of framework, register with Xians to get identity, authentication, and operational infrastructure.</p> <p>Build with any framework - Microsoft Agent Framework, LangChain, Semantic Kernel, or raw OpenAI SDK - and register it with Xians. Each agent gets a unique identity, authentication credentials, and seamless integration with the platform's workflows, messaging, and scheduling infrastructure.</p> <p>Key capabilities:</p> <ul> <li>Framework-agnostic: Bring your own agent implementation</li> <li>Unique identity: Each agent gets a distinct ID and permission management</li> <li>Deployment models: Publish agents as templates and rollout to tenants</li> <li>Lifecycle management: Publish, deploy, version control, delete agents</li> </ul>"},{"location":"introduction/features/#multi-tenancy","title":"Multi-Tenancy","text":"<p>Complete isolation of agents, workflows, data, and conversations - while sharing infrastructure. Two flavors:</p> Deployment Model What It Means When to Use System-Scoped One runtime serves all tenants Common agents that will be rolled out to tenants Tenant-Scoped Dedicated runtime per tenant Custom logic, sensitive data, specific agents <p>Key capabilities:</p> <ul> <li>Data isolation: Each tenant's workflows and data is completely separated</li> <li>Resource boundaries: Possible to implement per-tenant quotas and rate limits</li> <li>Custom configurations: Same agent using different prompts or configurations per tenant</li> </ul> <p>Deploy system agents for the common, create tenant-scoped agents for the advanced deployment models.</p>"},{"location":"introduction/features/#agent-user-collaboration","title":"Agent-User Collaboration","text":"<p>Async message passing from users to agents with persistent conversation history and context management.</p> <p>Messages aren't just text - they're the conversational memory that makes agents intelligent and contextual. Each message thread maintains state across sessions, enabling multi-turn dialogues where agents remember context, preferences, and history.</p> <p>Xians provides a sophisticated message hierarchy with complete isolation at every level, allowing agents and users to scope conversations for their specific work:</p> <pre><code>graph TD\n    T[Tenant] --&gt;|has many| A[Agents]\n    A --&gt;|has many| W[Workflows]\n    W --&gt;|has many| TH[Conversation Threads]\n    TH --&gt;|has many| S[Topics/Scopes]\n    S --&gt;|has many| M[Messages]\n\n    style T fill:#eea52d,stroke:#333,stroke-width:2px,color:#1b1f2f\n    style A fill:#538cfc,stroke:#333,stroke-width:2px,color:#fff\n    style W fill:#41c18a,stroke:#333,stroke-width:2px,color:#fff\n    style TH fill:#9b59b6,stroke:#333,stroke-width:2px,color:#fff\n    style S fill:#e74c3c,stroke:#333,stroke-width:2px,color:#fff\n    style M fill:#95a5a6,stroke:#333,stroke-width:2px,color:#fff</code></pre> <p>This hierarchy enables powerful conversation organization: a single tenant can have multiple agents, each with different workflows handling various interactions. Within each workflow, users can maintain separate conversation threads, and even within a thread, organize messages by topic for cleaner context management</p> <p>Key capabilities:</p> <ul> <li>Conversation hierachy: Automatic context preservation across sessions</li> <li>Multiple transports: WebSocket, Server-Sent Events (SSE), REST APIs</li> <li>Rich messages: Text, structured data, and HITL Tasks</li> <li>Security: Message encryption, EU AI Act compliant</li> <li>Authentication: API keys or OIDC/OAuth 2.0 integration</li> </ul> <p>Users can interact with agents across different conversation threads, with full history and context automatically managed.</p>"},{"location":"introduction/features/#agent-agent-collaboration","title":"Agent-Agent Collaboration","text":"<p>Orchestrate multiple agents working together to solve complex problems through message passing and workflow coordination.</p> <p>Complex agentic systems often require multiple specialized agents collaborating as a team - one agent conversing with users, another analyzing data, one searching and reading the web, another making decisions. Xians enables sophisticated multi-agent architectures through two key mechanisms:</p> <p>Multi-Workflow Agents: A single agent can contain multiple specialized workflows, each handling a specific responsibility (conversation, research, analysis, decision-making). These workflows operate as a coordinated team behind a unified agent interface.</p> <p>Agent-to-Agent Protocol (A2A): Agents communicate with each other using Xians' A2A protocol SDK, which provides in-process communication for speed and resource optimization. Messages are routed, context is shared, and results are aggregated automatically.</p> <pre><code>graph TB\n    U[User] --&gt;|Message| A1[Customer Support Agent]\n\n    subgraph A1_Team[Customer Support Agent - Multi-Workflow]\n        A1W1[Conversation Workflow]\n        A1W2[Analysis Workflow]\n        A1W3[Action Workflow]\n    end\n\n    A1 --&gt; A1W1\n    A1W1 --&gt;|A2A Protocol| A1W2\n    A1W2 --&gt;|A2A Protocol| A1W3\n\n    A1W3 --&gt;|A2A Protocol| A2[Knowledge Agent]\n    A1W3 --&gt;|A2A Protocol| A3[Data Agent]\n\n    subgraph A2_Team[Knowledge Agent - Multi-Workflow]\n        A2W1[Search Workflow]\n        A2W2[RAG Workflow]\n    end\n\n    A2 --&gt; A2W1\n    A2W1 --&gt; A2W2\n    A2W2 --&gt;|Results| A1W3\n    A3 --&gt;|Results| A1W3\n\n    A1W3 --&gt; A1W1\n    A1W1 --&gt;|Response| U\n\n    style A1 fill:#538cfc,stroke:#333,stroke-width:3px,color:#fff\n    style A2 fill:#41c18a,stroke:#333,stroke-width:3px,color:#fff\n    style A3 fill:#e74c3c,stroke:#333,stroke-width:3px,color:#fff\n    style A1W1 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A1W2 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A1W3 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A2W1 fill:#6dd5a5,stroke:#333,stroke-width:1px,color:#000\n    style A2W2 fill:#6dd5a5,stroke:#333,stroke-width:1px,color:#000</code></pre> <p>This architecture enables building sophisticated agent teams where each agent specializes in a domain (customer support, data analysis, web research) and each workflow within an agent handles a specific task type.</p>"},{"location":"introduction/features/#human-in-the-loop","title":"Human-in-the-Loop","text":"<p>Workflows can pause for hours, days, or weeks waiting for human input, then automatically resume.</p> <pre><code>sequenceDiagram\n    participant W as Agent Workflow\n    participant T as Task\n    participant H as Human Reviewer\n\n    W-&gt;&gt;T: Create Task with Draft\n    T-&gt;&gt;H: Assigned To\n    Note over W: Workflow pauses&lt;br/&gt;(can wait hours/days/weeks)\n    H-&gt;&gt;T: Review &amp; Edit Draft in Task\n    H-&gt;&gt;T: Approve/Reject Decision\n    T-&gt;&gt;W: Resume with Feedback\n    Note over W: Workflow continues\n    W-&gt;&gt;W: Process Next Steps</code></pre> <p>Key capabilities:</p> <ul> <li>Task creation: Agents create tasks requiring human judgment</li> <li>Draft review: Human reviewers edit and approve agent outputs</li> <li>Flexible timing: Workflows can wait indefinitely for human input</li> <li>Approval chains: Multi-step review processes with multiple tasks</li> <li>Audit trails: Complete history of reviews and decisions</li> </ul> <p>Agents create tasks, attach drafts, and wait for approval. Humans review, edit, approve, or reject. Workflow continues with the feedback. Everything tracked in the audit trail.</p>"},{"location":"introduction/features/#long-running-workflows","title":"Long-Running Workflows","text":"<p>Built on Temporal, so your workflows can run for days, months, or years with automatic state management and recovery.</p> <p>Traditional automation breaks on long-running processes. Xians workflows are durable, maintaining state across restarts, failures, and deployments. A customer onboarding workflow can span weeks; an annual compliance workflow runs for months - all reliably managed.</p> <p>Key capabilities:</p> <ul> <li>Durable execution: Workflows survive failures and infrastructure restarts</li> <li>State persistence: Maintain context across distributed operations</li> <li>Auto-retry: Automatic recovery from transient failures</li> <li>Composition: Orchestrate complex multi-step processes</li> </ul> <p>Each agent can have multiple workflows for conversations, events, or custom business processes. The \"Default Workflow\" gives you all platform functions out-of-the-box.</p>"},{"location":"introduction/features/#scheduling","title":"Scheduling","text":"<p>Create time-based workflow automation with a modern, fluent API that works the same everywhere - in regular code, agent tools, and even inside workflows themselves.</p> <p>Time-based automation lets agents work autonomously - generating reports at 9 AM, processing overnight data, sending weekly summaries - without manual triggers.</p> <p>Key capabilities:</p> <ul> <li>Flexible scheduling: Cron expressions, intervals, daily/weekly/monthly helpers, or one-time calendar schedules</li> <li>Timezone support: Schedule in any timezone using IANA timezone database</li> <li>Workflow-aware: Same API works both inside and outside workflows with automatic determinism</li> <li>Full lifecycle management: Create, pause, resume, trigger, update, and delete schedules</li> <li>Dynamic creation: Agents create schedules based on conversations</li> <li>Multi-tenant isolation: Automatic tenant security and isolation</li> </ul> <p>Built on Temporal's durable execution, so schedules survive restarts and system failures. Manage everything programmatically via SDK or through the UI.</p>"},{"location":"introduction/features/#webhooks","title":"Webhooks","text":"<p>TBD.</p>"},{"location":"introduction/features/#document-storage","title":"Document Storage","text":"<p>Persist and query structured data with a tenant-scoped JSON document store. Save user preferences, conversation memory, session state, analytics - any data your agent needs to remember.</p> <p>Agents need structured memory beyond conversations. Document storage provides flexible JSON persistence with semantic keys, metadata filtering, and automatic cleanup - without database complexity.</p> <p>Key capabilities:</p> <ul> <li>JSON storage: Store any JSON-serializable object with no schema constraints</li> <li>Semantic keys: Use meaningful identifiers like \"user-123-preferences\" instead of random IDs</li> <li>Metadata filtering: Query by type, metadata fields, and date ranges</li> <li>TTL support: Auto-delete documents after expiration (sessions, caches, temporary data)</li> <li>Dual access: Available at agent-level and from within workflow contexts</li> <li>Tenant isolation: Automatic data separation per customer</li> </ul> <p>Common use cases: conversation memory, user preferences, session state, analytics tracking, API response caching. Simple, fast, and purpose-built for agent workflows.</p>"},{"location":"introduction/features/#knowledge-management","title":"Knowledge Management","text":"<p>Shared storage for agent configuration, prompts, instructions, and reference data. Both agents (via code) and humans (via UI) can read and write the same knowledge.</p> <p>Agents need more than just code - they need prompts, instructions, configs, and reference data that can be updated without redeployment. Knowledge provides a shared filing cabinet accessible to both code and humans.</p> <p>Key capabilities:</p> <ul> <li>Dual access: Agents use SDK methods, humans use UI portal - same data</li> <li>Automatic scoping: Per-agent and per-tenant isolation</li> <li>Multiple content types: Prompts, instructions, JSON configs, markdown docs, preferences</li> <li>Simple CRUD: Get, update, delete, and list operations</li> <li>Fast retrieval: Automatic caching for performance</li> <li>Flexible storage: Any text content - no schema constraints</li> </ul> <p>Common uses: AI prompts editable via UI, user preferences, feature flags, instructions, API configurations, templates, FAQ content. Update agent behavior without code changes.</p>"},{"location":"introduction/features/#sub-workflows","title":"Sub-Workflows","text":"<p>Composable workflow components that can be reused across different parent workflows.</p> <p>Complex workflows benefit from modularity. Sub-workflows are reusable building blocks - a \"send email\" sub-workflow, a \"verify identity\" sub-workflow - that compose into larger processes.</p> <p>Key capabilities:</p> <ul> <li>Reusability: Define once, use across multiple parent workflows</li> <li>Composition: Nest workflows for clean architecture</li> <li>Independent scaling: Sub-workflows can have different worker pools</li> <li>Isolated testing: Test sub-workflows independently</li> <li>Failure isolation: Sub-workflow failures don't cascade</li> </ul> <p>Build a library of workflow components. Compose them into sophisticated business processes. Maintain and test each piece separately.</p>"},{"location":"introduction/features/#observability","title":"Observability","text":"<p>Built-in logging, metrics, and audit trails so you can actually see what your agents are doing.</p>"},{"location":"introduction/features/#logs--exceptions","title":"Logs &amp; Exceptions","text":"<p>Auto-captured with stack traces. View in the UI, search by agent/tenant/workflow/time. Real-time alerts when things explode.</p>"},{"location":"introduction/features/#metrics","title":"Metrics","text":"What We Track Why Response times, latency Find bottlenecks Token usage, API calls Control costs Job counts, message volumes Monitor load Success/failure rates Catch issues"},{"location":"introduction/features/#opentelemetry-support","title":"OpenTelemetry Support","text":"<p>Distributed tracing, structured logs, correlation IDs. Works with Datadog, New Relic, Grafana, and friends.</p>"},{"location":"introduction/features/#audit-trails","title":"Audit Trails","text":"<p>Immutable execution history for compliance. Every workflow, every action, every decision - timestamped and logged.</p>"},{"location":"introduction/features/#in-short","title":"In Short","text":"<p>Xians is the infrastructure layer for agents. Keep your agent code focused on AI logic. Let Xians handle the production plumbing: agent registration, multi-tenancy, collaboration, workflows, scheduling, data storage, observability, and human oversight.</p> <p>Not another agent framework. The control plane that makes your agents production-ready.</p>"},{"location":"introduction/where-does-it-fit/","title":"Where Does it Fit?","text":"<p>Xians is designed to integrate seamlessly into your existing architecture as a dedicated Agent Microservice. It sits between your web server and your AI agents, handling all agent management, orchestration, and communication.</p>"},{"location":"introduction/where-does-it-fit/#systems-architecture","title":"Systems Architecture","text":"<p>The diagram above illustrates how Xians fits into a typical microservices architecture:</p> <ol> <li>Your Product UI - Your frontend application where users interact with your product</li> <li>Your Web Server - Your backend/BFF (Backend for Frontend) layer that handles UI logic</li> <li>Agent Microservice (Xians Server) - The dedicated service for managing AI agents</li> <li>Your Agents - The AI agents that perform tasks and interact with users</li> </ol>"},{"location":"introduction/where-does-it-fit/#direct-integration-option","title":"Direct Integration Option","text":"<p>Alternatively, the Xians Server can use OIDC to connect directly with your web UI in scenarios where a BFF/Web Server layer is not mediating the communication. Developers may use the Xians TypeScript SDK (Optional) to easily integrate with the server's APIs.</p>"},{"location":"introduction/where-does-it-fit/#subcomponents","title":"Subcomponents","text":"<p>Xians is built with a modular architecture comprising the following major components:</p> <p></p> <ol> <li>Xians Server - The core orchestration engine that provides APIs for agents and external applications to interact with the platform</li> <li>Xians UI - A comprehensive web interface for managing and controlling all aspects of your agents (serves as an alternative to direct API integration)</li> <li>Xians Lib - A .NET Core class library that agents use to establish connections and communicate with the Xians server</li> </ol>"},{"location":"sdk-reference/scheduling-sdk/","title":"Scheduling Deep Dive","text":"<p>This guide provides comprehensive coverage of Xians scheduling capabilities, including advanced patterns, production configurations, error handling, and real-world examples.</p>"},{"location":"sdk-reference/scheduling-sdk/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Architecture Overview</li> <li>Complete Scheduling Patterns</li> <li>Production Configuration</li> <li>Lifecycle Management</li> <li>Error Handling</li> <li>Workflow-Aware Execution</li> <li>Multi-Tenant Security</li> <li>Real-World Examples</li> <li>API Reference</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#architecture-overview","title":"Architecture Overview","text":""},{"location":"sdk-reference/scheduling-sdk/#how-xians-scheduling-works","title":"How Xians Scheduling Works","text":"<p>Xians scheduling is built on Temporal's Schedule feature, which provides:</p> <ol> <li>Durable Storage - Schedules are persisted in Temporal's database</li> <li>Distributed Execution - No single point of failure; runs across cluster</li> <li>Event-Driven - Triggers workflow executions based on time rules</li> <li>Audit Trail - Complete history of schedule changes and executions</li> </ol>"},{"location":"sdk-reference/scheduling-sdk/#xians-enhancements","title":"Xians Enhancements","text":"<p>Xians adds several layers on top of Temporal:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Fluent API (ScheduleBuilder)           \u2502  \u2190 Developer-friendly interface\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Multi-Tenant Isolation                 \u2502  \u2190 Automatic tenant scoping\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Workflow-Aware Context Detection       \u2502  \u2190 Auto-determinism\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Schedule Activities (System)           \u2502  \u2190 Pre-registered activities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Temporal Schedule API                  \u2502  \u2190 Core scheduling engine\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#key-components","title":"Key Components","text":"<p>ScheduleCollection (<code>workflow.Schedules!</code>) - Factory for creating and managing schedules - Tenant-aware querying and filtering - Lifecycle operations (create, get, list, delete)</p> <p>ScheduleBuilder - Fluent API for schedule configuration - Type-safe scheduling options - Terminal <code>.StartAsync()</code> method</p> <p>XiansSchedule - Handle to individual schedule instance - Operations: pause, resume, trigger, update, delete - Information retrieval via <code>DescribeAsync()</code></p> <p>ScheduleActivities - System-registered activities for workflow context - Automatic usage when <code>Workflow.InWorkflow == true</code> - Maintains determinism in workflow executions</p>"},{"location":"sdk-reference/scheduling-sdk/#complete-scheduling-patterns","title":"Complete Scheduling Patterns","text":""},{"location":"sdk-reference/scheduling-sdk/#time-based-schedules-with-timezones","title":"Time-Based Schedules with Timezones","text":"<p>All time-based schedules support IANA timezone configuration:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Temporalio.Workflows;\n\n[Workflow(\"Schedule Setup Workflow\")]\npublic class ScheduleSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Daily at specific time\n        await workflow.Schedules!\n            .Create(\"daily-morning-report\")\n            .Daily(hour: 9, minute: 30, timezone: \"America/New_York\")\n            .WithInput(\"report-type\", \"daily\")\n            .StartAsync();\n\n        // Weekly on specific day\n        await workflow.Schedules!\n            .Create(\"weekly-monday-sync\")\n            .Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n            .WithInput(\"sync-config\")\n            .StartAsync();\n\n        // Monthly on specific day\n        await workflow.Schedules!\n            .Create(\"monthly-first-billing\")\n            .Monthly(dayOfMonth: 1, hour: 8, timezone: \"Asia/Tokyo\")\n            .WithInput(\"billing-params\")\n            .StartAsync();\n\n        // Weekdays only (Monday-Friday)\n        await workflow.Schedules!\n            .Create(\"weekday-check\")\n            .Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n            .WithInput(\"health-check\")\n            .StartAsync();\n\n        // Every hour at specific minute\n        await workflow.Schedules!\n            .Create(\"hourly-quarter-past\")\n            .Hourly(minute: 15)\n            .WithInput(\"monitoring-data\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"All schedules created successfully\");\n    }\n}\n</code></pre> <p>Timezone Behavior: - Default: UTC if timezone not specified - DST Handling: Temporal automatically adjusts for daylight saving time - IANA Names: Use standard names like <code>\"America/New_York\"</code>, not abbreviations like <code>\"EST\"</code></p>"},{"location":"sdk-reference/scheduling-sdk/#interval-based-schedules","title":"Interval-Based Schedules","text":"<p>Duration-based schedules that don't use timezones:</p> C#<pre><code>[Workflow(\"Interval Schedule Setup\")]\npublic class IntervalScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Simple intervals\n        await workflow.Schedules!\n            .Create(\"every-30-seconds\")\n            .EverySeconds(30)\n            .WithInput(\"fast-polling\")\n            .StartAsync();\n\n        await workflow.Schedules!\n            .Create(\"every-30-minutes\")\n            .EveryMinutes(30)\n            .WithInput(\"medium-polling\")\n            .StartAsync();\n\n        await workflow.Schedules!\n            .Create(\"every-2-hours\")\n            .EveryHours(2)\n            .WithInput(\"slow-polling\")\n            .StartAsync();\n\n        // Custom interval with offset\n        await workflow.Schedules!\n            .Create(\"custom-interval\")\n            .WithIntervalSchedule(\n                interval: TimeSpan.FromMinutes(5),\n                offset: TimeSpan.FromSeconds(30)  // Start 30 seconds into each 5-minute window\n            )\n            .WithInput(\"offset-task\")\n            .StartAsync();\n\n        // Every N days (uses Daily internally if days=1)\n        await workflow.Schedules!\n            .Create(\"every-3-days\")\n            .EveryDays(3, hour: 9, minute: 0, timezone: \"America/New_York\")\n            .WithInput(\"tri-daily-task\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Interval schedules created\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#cron-expression-schedules","title":"Cron Expression Schedules","text":"<p>Advanced scheduling patterns using 5-field cron expressions:</p> C#<pre><code>[Workflow(\"Cron Schedule Setup\")]\npublic class CronScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Every day at 9 AM UTC\n        await workflow.Schedules!\n            .Create(\"cron-daily\")\n            .WithCronSchedule(\"0 9 * * *\")\n            .WithInput(\"daily-cron\")\n            .StartAsync();\n\n        // Weekdays at 9 AM with timezone\n        await workflow.Schedules!\n            .Create(\"cron-weekdays\")\n            .WithCronSchedule(\"0 9 * * 1-5\", timezone: \"America/New_York\")\n            .WithInput(\"weekday-cron\")\n            .StartAsync();\n\n        // First of month at midnight\n        await workflow.Schedules!\n            .Create(\"cron-monthly\")\n            .WithCronSchedule(\"0 0 1 * *\", timezone: \"America/New_York\")\n            .WithInput(\"monthly-cron\")\n            .StartAsync();\n\n        // Every 30 minutes\n        await workflow.Schedules!\n            .Create(\"cron-30min\")\n            .WithCronSchedule(\"*/30 * * * *\")\n            .WithInput(\"half-hourly\")\n            .StartAsync();\n\n        // Every 2 hours\n        await workflow.Schedules!\n            .Create(\"cron-2hours\")\n            .WithCronSchedule(\"0 */2 * * *\")\n            .WithInput(\"bi-hourly\")\n            .StartAsync();\n\n        // Complex pattern: Every 15 minutes during business hours (9 AM - 5 PM) on weekdays\n        await workflow.Schedules!\n            .Create(\"cron-business-hours\")\n            .WithCronSchedule(\"*/15 9-17 * * 1-5\", timezone: \"America/New_York\")\n            .WithInput(\"business-hours-monitoring\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Cron schedules created\");\n    }\n}\n</code></pre> <p>Cron Format (5 fields): Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n\u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1 - 31)\n\u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n\u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of week (0 - 6) (Sunday=0)\n\u2502 \u2502 \u2502 \u2502 \u2502\n* * * * *\n</code></pre></p>"},{"location":"sdk-reference/scheduling-sdk/#calendar-based-one-time-schedules","title":"Calendar-Based (One-Time) Schedules","text":"<p>Execute at a specific date and time:</p> C#<pre><code>[Workflow(\"Calendar Schedule Setup\")]\npublic class CalendarScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Specific future date and time\n        var scheduledTime = new DateTime(2026, 12, 25, 9, 0, 0);\n\n        await workflow.Schedules!\n            .Create(\"christmas-morning\")\n            .WithCalendarSchedule(scheduledTime, timezone: \"America/New_York\")\n            .WithInput(\"holiday-greeting\")\n            .StartAsync();\n\n        // Relative to current time\n        var futureTime = DateTime.UtcNow.AddHours(24);\n\n        await workflow.Schedules!\n            .Create(\"delayed-start\")\n            .WithCalendarSchedule(futureTime)\n            .WithInput(\"delayed-task\")\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Calendar schedules created\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#production-configuration","title":"Production Configuration","text":""},{"location":"sdk-reference/scheduling-sdk/#complete-production-ready-schedule","title":"Complete Production-Ready Schedule","text":"<p>This example shows all recommended production features:</p> C#<pre><code>using Temporalio.Common;\nusing Temporalio.Workflows;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"Production Schedule Setup\")]\npublic class ProductionScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        var schedule = await workflow.Schedules!\n            .Create(\"production-daily-report\")\n\n            // Schedule timing\n            .Daily(hour: 9, timezone: \"America/New_York\")\n\n            // Workflow input\n            .WithInput(\"report-config\", \"additional-params\")\n\n            // Retry policy - handle transient failures\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 5,\n                InitialInterval = TimeSpan.FromSeconds(10),\n                BackoffCoefficient = 2.0,  // Exponential backoff: 10s, 20s, 40s, 80s, 160s\n                MaximumInterval = TimeSpan.FromMinutes(10)\n            })\n\n            // Timeout - prevent runaway workflows\n            .WithTimeout(TimeSpan.FromHours(2))\n\n            // Overlap policy - prevent execution pile-up\n            .SkipIfRunning()\n\n            // Metadata - tracking and debugging\n            .WithMemo(new Dictionary&lt;string, object&gt;\n            {\n                { \"environment\", \"production\" },\n                { \"owner\", \"data-team\" },\n                { \"priority\", \"high\" },\n                { \"version\", \"2.1.0\" },\n                { \"created_by\", workflow.GetType().Name }\n            })\n\n            // Start the schedule\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Production schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#overlap-policies-explained","title":"Overlap Policies Explained","text":"<p>Control behavior when new execution is triggered while previous is still running:</p> C#<pre><code>// RECOMMENDED: Skip if already running\n// Use case: Most scenarios - prevents pile-up\n.SkipIfRunning()\n\n// Allow concurrent executions\n// Use case: Independent, fast executions\n.AllowOverlap()\n\n// Queue one execution for after current completes\n// Use case: Must process at least once more after current\n.BufferOne()\n\n// Cancel currently running execution, start new one\n// Use case: Newer data supersedes current processing\n.CancelOther()\n\n// Terminate currently running execution (immediate stop)\n// Use case: Rare - forces stop without cleanup\n.TerminateOther()\n\n// Or use the policy method directly\n.WithOverlapPolicy(ScheduleOverlapPolicy.Skip)\n</code></pre> <p>Decision Matrix:</p> Scenario Recommended Policy Daily reports that take hours <code>SkipIfRunning()</code> Fast, independent health checks <code>AllowOverlap()</code> Data sync that must catch up <code>BufferOne()</code> Real-time data where latest matters <code>CancelOther()</code> Emergency shutdown required <code>TerminateOther()</code> (use with caution)"},{"location":"sdk-reference/scheduling-sdk/#retry-policies","title":"Retry Policies","text":"<p>Configure automatic retry behavior for failed executions:</p> C#<pre><code>.WithRetryPolicy(new RetryPolicy\n{\n    // Maximum number of retry attempts\n    MaximumAttempts = 5,\n\n    // Initial delay before first retry\n    InitialInterval = TimeSpan.FromSeconds(10),\n\n    // Multiplier for exponential backoff\n    BackoffCoefficient = 2.0,\n\n    // Cap for maximum delay between retries\n    MaximumInterval = TimeSpan.FromMinutes(10),\n\n    // Optional: Retry only specific exception types\n    // NonRetryableErrorTypes = new[] { \"BusinessLogicException\" }\n})\n</code></pre> <p>Example Retry Sequence: - Attempt 1 fails \u2192 wait 10s - Attempt 2 fails \u2192 wait 20s (10s \u00d7 2.0) - Attempt 3 fails \u2192 wait 40s (20s \u00d7 2.0) - Attempt 4 fails \u2192 wait 80s (40s \u00d7 2.0) - Attempt 5 fails \u2192 wait 160s, but capped at 600s (10 minutes)</p>"},{"location":"sdk-reference/scheduling-sdk/#workflow-timeouts","title":"Workflow Timeouts","text":"<p>Set execution time limits:</p> C#<pre><code>// Absolute timeout for workflow execution\n.WithTimeout(TimeSpan.FromHours(2))\n\n// Workflow will be terminated if it exceeds 2 hours\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#custom-metadata","title":"Custom Metadata","text":"<p>Add tracking information to scheduled workflows:</p> C#<pre><code>.WithMemo(new Dictionary&lt;string, object&gt;\n{\n    { \"environment\", \"production\" },\n    { \"team\", \"data-engineering\" },\n    { \"cost_center\", \"engineering-ops\" },\n    { \"sla\", \"99.9%\" },\n    { \"on_call\", \"team-alpha\" },\n    { \"documentation\", \"https://docs.example.com/workflows/daily-sync\" }\n})\n</code></pre> <p>Metadata is attached to each workflow execution and visible in Temporal UI.</p>"},{"location":"sdk-reference/scheduling-sdk/#start-paused","title":"Start Paused","text":"<p>Create schedule in paused state for later activation:</p> C#<pre><code>[Workflow(\"Approval-Based Schedule Setup\")]\npublic class ApprovalScheduleWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(bool approved)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Create paused schedule\n        await workflow.Schedules!\n            .Create(\"pending-approval-schedule\")\n            .Daily(hour: 9, timezone: \"America/New_York\")\n            .WithInput(\"data\")\n            .StartPaused(paused: true, note: \"Awaiting stakeholder approval\")\n            .StartAsync();\n\n        if (approved)\n        {\n            // Activate immediately if already approved\n            var schedule = await workflow.Schedules!.GetAsync(\"pending-approval-schedule\");\n            await schedule.UnpauseAsync(\"Approved by stakeholder on 2026-01-15\");\n\n            Workflow.Logger.LogInformation(\"Schedule approved and activated\");\n        }\n        else\n        {\n            Workflow.Logger.LogInformation(\"Schedule created in paused state, awaiting approval\");\n        }\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"sdk-reference/scheduling-sdk/#retrieve-and-inspect-schedules","title":"Retrieve and Inspect Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Get specific schedule\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Get detailed information\nvar description = await schedule.DescribeAsync();\n\n// Access schedule information\nvar nextRun = description.Info.NextActionTimes.FirstOrDefault();\nvar recentRuns = description.Info.RecentActions;\nvar isPaused = description.Schedule.State.Paused;\nvar pauseNote = description.Schedule.State.Note;\n\nConsole.WriteLine($\"Schedule ID: {schedule.Id}\");\nConsole.WriteLine($\"Next execution: {nextRun}\");\nConsole.WriteLine($\"Status: {(isPaused ? \"Paused\" : \"Active\")}\");\nif (!string.IsNullOrEmpty(pauseNote))\n{\n    Console.WriteLine($\"Note: {pauseNote}\");\n}\n\n// Recent execution history\nConsole.WriteLine(\"Recent executions:\");\nforeach (var action in recentRuns.Take(5))\n{\n    Console.WriteLine($\"  - {action.ActualTime}: {action.TakenAt}\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#pause-and-resume","title":"Pause and Resume","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Pause with descriptive note\nawait schedule.PauseAsync(\"System maintenance - database migration in progress\");\n\n// ... perform maintenance ...\n\n// Resume with completion note\nawait schedule.UnpauseAsync(\"Maintenance completed successfully at 2026-01-15 10:30 UTC\");\n\n// Or use collection methods\nawait workflow.Schedules!.PauseAsync(\"my-schedule\", \"Temporary pause for testing\");\nawait workflow.Schedules!.UnpauseAsync(\"my-schedule\", \"Testing complete\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#trigger-immediate-execution","title":"Trigger Immediate Execution","text":"<p>Execute schedule immediately without affecting its regular timing:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar schedule = await workflow.Schedules!.GetAsync(\"daily-report\");\n\n// Trigger now (doesn't change next scheduled execution)\nawait schedule.TriggerAsync();\n\nConsole.WriteLine(\"Manual execution triggered\");\n\n// Or via collection\nawait workflow.Schedules!.TriggerAsync(\"daily-report\");\n</code></pre> <p>Use Cases: - Manual report generation - Testing schedule configuration - Catch-up after fixing a bug - User-requested immediate execution</p>"},{"location":"sdk-reference/scheduling-sdk/#update-schedule-configuration","title":"Update Schedule Configuration","text":"<p>Modify existing schedule settings:</p> C#<pre><code>var schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\nawait schedule.UpdateAsync(input =&gt; \n{\n    var updatedSchedule = input.Description.Schedule;\n\n    // Change schedule time (e.g., from 9 AM to 10 AM)\n    updatedSchedule = new Schedule(\n        Action: updatedSchedule.Action,\n        Spec: new ScheduleSpec\n        {\n            CronExpressions = new List&lt;string&gt; \n            { \n                \"0 10 * * *\"  // 10 AM instead of 9 AM\n            },\n            TimeZoneName = \"America/New_York\"\n        })\n    {\n        Policy = updatedSchedule.Policy,\n        State = updatedSchedule.State\n    };\n\n    return new ScheduleUpdate(updatedSchedule);\n});\n\nConsole.WriteLine(\"Schedule updated to 10 AM\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#delete-schedules","title":"Delete Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Delete via schedule instance\nvar schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\nawait schedule.DeleteAsync();\n\n// Or via collection\nawait workflow.Schedules!.DeleteAsync(\"my-schedule\");\n\n// Check existence first (idempotent deletion)\nif (await workflow.Schedules!.ExistsAsync(\"my-schedule\"))\n{\n    await workflow.Schedules!.DeleteAsync(\"my-schedule\");\n    Console.WriteLine(\"Schedule deleted\");\n}\nelse\n{\n    Console.WriteLine(\"Schedule doesn't exist\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#list-all-schedules","title":"List All Schedules","text":"C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// List all schedules for this workflow (automatically filtered by tenant)\nvar schedules = await workflow.Schedules!.ListAsync();\n\nConsole.WriteLine(\"All schedules:\");\nawait foreach (var scheduleInfo in schedules)\n{\n    Console.WriteLine($\"\\nSchedule ID: {scheduleInfo.Id}\");\n\n    // Get full details\n    var schedule = await workflow.Schedules!.GetAsync(scheduleInfo.Id);\n    var description = await schedule.DescribeAsync();\n\n    var nextRun = description.Info.NextActionTimes.FirstOrDefault();\n    var isPaused = description.Schedule.State.Paused;\n    var memo = description.Memo;\n\n    Console.WriteLine($\"  Next run: {nextRun}\");\n    Console.WriteLine($\"  Status: {(isPaused ? \"Paused\" : \"Active\")}\");\n\n    if (memo?.Fields != null &amp;&amp; memo.Fields.ContainsKey(\"environment\"))\n    {\n        Console.WriteLine($\"  Environment: {memo.Fields[\"environment\"]}\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#backfill-missed-executions","title":"Backfill Missed Executions","text":"<p>Execute schedule for past time ranges (useful after system downtime):</p> C#<pre><code>var schedule = await workflow.Schedules!.GetAsync(\"my-schedule\");\n\n// Run schedule for last week (e.g., after outage)\nvar backfills = new List&lt;ScheduleBackfill&gt;\n{\n    new(\n        StartAt: DateTime.UtcNow.AddDays(-7),\n        EndAt: DateTime.UtcNow,\n        Overlap: ScheduleOverlapPolicy.AllowAll  // Allow all backfill executions\n    )\n};\n\nawait schedule.BackfillAsync(backfills);\nConsole.WriteLine(\"Backfill started for past 7 days\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#error-handling","title":"Error Handling","text":""},{"location":"sdk-reference/scheduling-sdk/#exception-types","title":"Exception Types","text":"C#<pre><code>using Xians.Lib.Agents.Scheduling.Models;\n\nvar workflow = XiansContext.CurrentWorkflow;\n\ntry\n{\n    var schedule = await workflow.Schedules!\n        .Create(\"my-schedule\")\n        .Daily(hour: 9)\n        .WithInput(\"data\")\n        .StartAsync();\n\n    Console.WriteLine($\"Schedule created: {schedule.Id}\");\n}\ncatch (ScheduleAlreadyExistsException ex)\n{\n    // Schedule with this ID already exists\n    Console.WriteLine($\"Warning: Schedule '{ex.ScheduleId}' already exists\");\n\n    // Option 1: Get existing schedule\n    var existing = await workflow.Schedules!.GetAsync(ex.ScheduleId);\n    Console.WriteLine(\"Using existing schedule\");\n\n    // Option 2: Delete and recreate\n    // await workflow.Schedules!.DeleteAsync(ex.ScheduleId);\n    // var newSchedule = await workflow.Schedules!.Create(ex.ScheduleId)...StartAsync();\n}\ncatch (InvalidScheduleSpecException ex)\n{\n    // Invalid schedule configuration\n    Console.WriteLine($\"Error: Invalid schedule specification: {ex.Message}\");\n    // Examples: Missing spec, invalid cron, invalid parameters\n}\ncatch (ScheduleNotFoundException ex)\n{\n    // Trying to access non-existent schedule\n    Console.WriteLine($\"Error: Schedule '{ex.ScheduleId}' not found\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#idempotent-schedule-creation","title":"Idempotent Schedule Creation","text":"<p>Safe creation that handles existing schedules:</p> C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\nvar scheduleId = \"my-recurring-task\";\n\n// Pattern 1: Check existence first\nif (!await workflow.Schedules!.ExistsAsync(scheduleId))\n{\n    await workflow.Schedules!\n        .Create(scheduleId)\n        .Daily(hour: 9, timezone: \"America/New_York\")\n        .WithInput(\"data\")\n        .StartAsync();\n\n    Console.WriteLine(\"Schedule created\");\n}\nelse\n{\n    Console.WriteLine(\"Schedule already exists\");\n}\n\n// Pattern 2: Try-catch approach\ntry\n{\n    await workflow.Schedules!\n        .Create(scheduleId)\n        .Daily(hour: 9)\n        .StartAsync();\n}\ncatch (ScheduleAlreadyExistsException)\n{\n    // Already exists - safe to continue\n    Console.WriteLine(\"Schedule already exists\");\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#graceful-degradation","title":"Graceful Degradation","text":"C#<pre><code>async Task&lt;XiansSchedule?&gt; CreateScheduleSafely(string scheduleId)\n{\n    try\n    {\n        return await workflow.Schedules!\n            .Create(scheduleId)\n            .Daily(hour: 9)\n            .WithInput(\"data\")\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 3,\n                InitialInterval = TimeSpan.FromSeconds(10)\n            })\n            .StartAsync();\n    }\n    catch (ScheduleAlreadyExistsException)\n    {\n        _logger.LogInformation(\"Schedule {ScheduleId} already exists\", scheduleId);\n        return await workflow.Schedules!.GetAsync(scheduleId);\n    }\n    catch (InvalidScheduleSpecException ex)\n    {\n        _logger.LogError(ex, \"Invalid schedule specification for {ScheduleId}\", scheduleId);\n        return null;\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError(ex, \"Unexpected error creating schedule {ScheduleId}\", scheduleId);\n        return null;\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#workflow-aware-execution","title":"Workflow-Aware Execution","text":"<p>** Recommended Pattern**: Create schedules from within workflows for automatic determinism and tenant context.</p>"},{"location":"sdk-reference/scheduling-sdk/#inside-workflow-context-recommended","title":"Inside Workflow Context (Recommended)","text":"<p>Workflows create and manage schedules with automatic activity usage for determinism:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\n\n[Workflow(\"Self-Scheduling Workflow\")]\npublic class SelfSchedulingWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;SelfSchedulingWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string taskName, int intervalHours)\n    {\n        _logger.LogInformation(\"Creating recurring schedule for {TaskName}\", taskName);\n\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // SDK detects Workflow.InWorkflow == true\n        // Automatically uses ScheduleActivities for determinism!\n        var schedule = await workflow.Schedules!\n            .Create($\"recurring-{taskName}\")\n            .EveryHours(intervalHours)\n            .WithInput(taskName, intervalHours)\n            .SkipIfRunning()\n            .StartAsync();\n\n        _logger.LogInformation(\"Schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre> <p>How It Works:</p> <ol> <li>SDK checks <code>Workflow.InWorkflow</code> property</li> <li>If true: Automatically delegates to pre-registered <code>ScheduleActivities</code></li> <li>Maintains workflow determinism</li> <li>No manual activity registration needed!</li> </ol> <p>Benefits: -  Automatic determinism through activities -  Tenant context automatically available -  Clean workflow-centric design -  No external setup required</p>"},{"location":"sdk-reference/scheduling-sdk/#system-activities-auto-registered","title":"System Activities Auto-Registered","text":"<p>System activities are automatically registered - no configuration needed:</p> C#<pre><code>// You DON'T need to do this - activities auto-registered!\n// worker.AddActivity&lt;ScheduleActivities&gt;();\n\n// Just use the schedule API from within your workflow\n[WorkflowRun]\npublic async Task RunAsync()\n{\n    var workflow = XiansContext.CurrentWorkflow;\n\n    var schedule = await workflow.Schedules!\n        .Create(\"auto-schedule\")\n        .Daily(hour: 9)\n        .StartAsync();\n}\n</code></pre> <p>Important: <code>XiansContext.CurrentWorkflow</code> can only be used inside workflows or activities. It will throw <code>InvalidOperationException</code> if used outside workflow context.</p>"},{"location":"sdk-reference/scheduling-sdk/#multi-tenant-security","title":"Multi-Tenant Security","text":""},{"location":"sdk-reference/scheduling-sdk/#automatic-tenant-isolation","title":"Automatic Tenant Isolation","text":"<p>Schedules are automatically scoped to the current tenant when created from workflows:</p> C#<pre><code>[Workflow(\"Multi-Tenant Report Workflow\")]\npublic class MultiTenantReportWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context - automatically includes tenant context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // When this workflow runs for tenant \"acme-corp\"\n        await workflow.Schedules!\n            .Create(\"daily-report\")  // Internal ID: \"acme-corp:daily-report\"\n            .Daily(hour: 9)\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Schedule created for tenant: {TenantId}\", \n            XiansContext.TenantId);\n    }\n}\n\n// When the same workflow runs for tenant \"techco\"\n// It creates: \"techco:daily-report\" (completely separate schedule)\n\n// Both schedules exist independently - complete isolation!\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#tenant-scoped-queries","title":"Tenant-Scoped Queries","text":"<p>All schedule operations respect tenant boundaries:</p> C#<pre><code>// In workflow context for tenant \"acme-corp\"\nvar workflow = XiansContext.CurrentWorkflow;\n\n// List only returns schedules for \"acme-corp\"\nvar schedules = await workflow.Schedules!.ListAsync();\n\n// Get only works for \"acme-corp\" schedules\nvar schedule = await workflow.Schedules!.GetAsync(\"daily-report\");\n// This gets \"acme-corp:daily-report\", NOT \"techco:daily-report\"\n\n// Delete only affects \"acme-corp\" schedules\nawait workflow.Schedules!.DeleteAsync(\"daily-report\");\n// This deletes \"acme-corp:daily-report\", NOT \"techco:daily-report\"\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#security-guarantees","title":"Security Guarantees","text":"<p>Complete Isolation - Tenants cannot access each other's schedules - Schedule IDs automatically prefixed with tenant ID - All operations filtered by current tenant context</p> <p>No Cross-Tenant Leakage - List operations only return current tenant's schedules - Get operations fail for other tenants' schedules - Delete operations cannot affect other tenants</p> <p>Automatic Enforcement - No manual tenant filtering required - SDK enforces security transparently - Works in both workflow and non-workflow contexts</p>"},{"location":"sdk-reference/scheduling-sdk/#real-world-examples","title":"Real-World Examples","text":""},{"location":"sdk-reference/scheduling-sdk/#example-1-daily-report-generation","title":"Example 1: Daily Report Generation","text":"<p>Complete production setup for daily morning reports:</p> C#<pre><code>using Temporalio.Workflows;\nusing Temporalio.Common;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n// Define the report workflow\n[Workflow(\"Daily Report Workflow\")]\npublic class DailyReportWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;DailyReportWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string reportType, string recipients)\n    {\n        _logger.LogInformation(\"Generating {ReportType} report for {Recipients}\", \n            reportType, recipients);\n\n        // Report generation logic...\n        await GenerateReport(reportType);\n        await EmailReport(recipients);\n\n        _logger.LogInformation(\"Report generated and sent\");\n    }\n\n    private async Task GenerateReport(string reportType)\n    {\n        // Implementation...\n        await Task.CompletedTask;\n    }\n\n    private async Task EmailReport(string recipients)\n    {\n        // Implementation...\n        await Task.CompletedTask;\n    }\n}\n\n// Setup schedule (in Program.cs or agent initialization)\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"ReportingAgent\",\n    SystemScoped = true\n});\n\nvar workflow = await agent.Workflows.DefineCustom&lt;DailyReportWorkflow&gt;(workers: 1);\n\nvar schedule = await workflow.Schedules!\n    .Create(\"daily-morning-report\")\n    .Daily(hour: 9, timezone: \"America/New_York\")\n    .WithInput(\"sales-summary\", \"team@company.com\")\n    .WithRetryPolicy(new RetryPolicy\n    {\n        MaximumAttempts = 3,\n        InitialInterval = TimeSpan.FromSeconds(30),\n        BackoffCoefficient = 2.0\n    })\n    .WithTimeout(TimeSpan.FromHours(1))\n    .SkipIfRunning()\n    .WithMemo(new Dictionary&lt;string, object&gt;\n    {\n        { \"team\", \"sales\" },\n        { \"report_type\", \"daily_sales_summary\" },\n        { \"priority\", \"high\" }\n    })\n    .StartAsync();\n\nConsole.WriteLine($\"Daily report schedule created: {schedule.Id}\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-2-self-scheduling-content-discovery","title":"Example 2: Self-Scheduling Content Discovery","text":"<p>Workflow that creates its own recurring schedule:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"Content Discovery Workflow\")]\npublic class ContentDiscoveryWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;ContentDiscoveryWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string contentUrl, int checkIntervalHours)\n    {\n        _logger.LogInformation(\"Discovering content from {Url}\", contentUrl);\n\n        // Process content\n        var newContent = await DiscoverContent(contentUrl);\n\n        if (newContent != null)\n        {\n            await ProcessNewContent(newContent);\n        }\n\n        // Create recurring schedule for future checks\n        // SDK automatically uses ScheduleActivities for determinism!\n        try\n        {\n            var scheduleId = $\"content-discovery-{SanitizeUrl(contentUrl)}-{checkIntervalHours}h\";\n\n            var schedule = await XiansContext.CurrentWorkflow.Schedules!\n                .Create(scheduleId)\n                .EveryHours(checkIntervalHours)\n                .WithInput(contentUrl, checkIntervalHours)\n                .SkipIfRunning()\n                .WithRetryPolicy(new RetryPolicy\n                {\n                    MaximumAttempts = 3,\n                    InitialInterval = TimeSpan.FromSeconds(10)\n                })\n                .WithMemo(new Dictionary&lt;string, object&gt;\n                {\n                    { \"content_url\", contentUrl },\n                    { \"interval_hours\", checkIntervalHours }\n                })\n                .StartAsync();\n\n            _logger.LogInformation(\"Recurring schedule created: {ScheduleId}\", schedule.Id);\n        }\n        catch (ScheduleAlreadyExistsException ex)\n        {\n            _logger.LogInformation(\"Schedule {ScheduleId} already exists - content discovery will continue\", \n                ex.ScheduleId);\n        }\n        catch (InvalidScheduleSpecException ex)\n        {\n            _logger.LogError(\"Invalid schedule specification: {Message}\", ex.Message);\n            throw;\n        }\n    }\n\n    private async Task&lt;object?&gt; DiscoverContent(string url)\n    {\n        // Content discovery logic...\n        await Task.CompletedTask;\n        return new { Title = \"Sample Content\" };\n    }\n\n    private async Task ProcessNewContent(object content)\n    {\n        // Process discovered content...\n        await Task.CompletedTask;\n    }\n\n    private string SanitizeUrl(string url)\n    {\n        // Convert URL to safe schedule ID component\n        return url.Replace(\"https://\", \"\")\n                  .Replace(\"http://\", \"\")\n                  .Replace(\"/\", \"-\")\n                  .Replace(\".\", \"-\");\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-3-multi-entity-scheduling","title":"Example 3: Multi-Entity Scheduling","text":"<p>Create schedules for multiple entities dynamically within a workflow:</p> C#<pre><code>using Xians.Lib.Agents;\nusing Xians.Lib.Agents.Scheduling;\nusing Xians.Lib.Agents.Scheduling.Models;\nusing Temporalio.Common;\nusing Temporalio.Workflows;\n\n[Workflow(\"Company Research Setup Workflow\")]\npublic class CompanyResearchSetupWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;CompanyResearchSetupWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Get current workflow context\n        var workflow = XiansContext.CurrentWorkflow;\n\n        // Create schedules for multiple companies\n        var companies = new[] \n        { \n            new { Name = \"ACME Corp\", Ticker = \"ACME\" },\n            new { Name = \"TechCo\", Ticker = \"TECH\" },\n            new { Name = \"GlobalInc\", Ticker = \"GLOB\" }\n        };\n\n        foreach (var company in companies)\n        {\n            var scheduleId = $\"research-{company.Ticker.ToLower()}\";\n\n            try\n            {\n                var schedule = await workflow.Schedules!\n                    .Create(scheduleId)\n                    .Weekdays(hour: 8, minute: 30, timezone: \"America/New_York\")\n                    .WithInput(company.Name, company.Ticker)\n                    .WithRetryPolicy(new RetryPolicy\n                    {\n                        MaximumAttempts = 3,\n                        InitialInterval = TimeSpan.FromSeconds(15),\n                        BackoffCoefficient = 2.0\n                    })\n                    .SkipIfRunning()\n                    .WithMemo(new Dictionary&lt;string, object&gt;\n                    {\n                        { \"company_name\", company.Name },\n                        { \"ticker\", company.Ticker },\n                        { \"research_type\", \"daily_market_analysis\" }\n                    })\n                    .StartAsync();\n\n                _logger.LogInformation(\"Schedule created for {Company} ({ScheduleId})\", \n                    company.Name, schedule.Id);\n            }\n            catch (ScheduleAlreadyExistsException)\n            {\n                _logger.LogWarning(\"Schedule for {Company} already exists\", company.Name);\n            }\n        }\n\n        _logger.LogInformation(\"Created {Count} research schedules\", companies.Length);\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-4-scheduled-monitoring-with-alerts","title":"Example 4: Scheduled Monitoring with Alerts","text":"<p>Health monitoring that runs every 5 minutes:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents;\n\n[Workflow(\"System Health Check\")]\npublic class HealthCheckWorkflow\n{\n    private readonly ILogger _logger = Workflow.CreateLogger&lt;HealthCheckWorkflow&gt;();\n\n    [WorkflowRun]\n    public async Task RunAsync(string[] services)\n    {\n        _logger.LogInformation(\"Running health check for {ServiceCount} services\", services.Length);\n\n        var unhealthyServices = new List&lt;string&gt;();\n\n        foreach (var service in services)\n        {\n            var isHealthy = await CheckServiceHealth(service);\n\n            if (!isHealthy)\n            {\n                unhealthyServices.Add(service);\n                _logger.LogWarning(\"Service {Service} is unhealthy\", service);\n            }\n        }\n\n        if (unhealthyServices.Any())\n        {\n            await SendAlert(unhealthyServices);\n        }\n\n        _logger.LogInformation(\"Health check complete\");\n    }\n\n    private async Task&lt;bool&gt; CheckServiceHealth(string service)\n    {\n        // Health check logic...\n        await Task.CompletedTask;\n        return true;\n    }\n\n    private async Task SendAlert(List&lt;string&gt; unhealthyServices)\n    {\n        // Alert logic...\n        await Task.CompletedTask;\n    }\n}\n\n// Setup within a workflow\n[Workflow(\"Health Check Setup Workflow\")]\npublic class HealthCheckSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string[] services)\n    {\n        var workflow = XiansContext.CurrentWorkflow;\n\n        var schedule = await workflow.Schedules!\n            .Create(\"health-check-5min\")\n            .EveryMinutes(5)\n            .WithInput(services)\n            .AllowOverlap()  // Health checks are independent and fast\n            .WithRetryPolicy(new RetryPolicy\n            {\n                MaximumAttempts = 2,  // Fail fast for health checks\n                InitialInterval = TimeSpan.FromSeconds(5)\n            })\n            .WithTimeout(TimeSpan.FromMinutes(2))\n            .WithMemo(new Dictionary&lt;string, object&gt;\n            {\n                { \"monitor_type\", \"health_check\" },\n                { \"alert_channel\", \"ops-alerts\" }\n            })\n            .StartAsync();\n\n        Workflow.Logger.LogInformation(\"Health check schedule created: {ScheduleId}\", schedule.Id);\n    }\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#example-5-schedule-management-dashboard","title":"Example 5: Schedule Management Dashboard","text":"<p>List and manage all schedules:</p> C#<pre><code>using Xians.Lib.Agents;\n\npublic class ScheduleManager\n{\n    private readonly XiansWorkflowContext _workflow;\n\n    public ScheduleManager(XiansWorkflowContext workflow)\n    {\n        _workflow = workflow;\n    }\n\n    public async Task DisplayAllSchedules()\n    {\n        Console.WriteLine(\"=== All Schedules ===\\n\");\n\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            var description = await schedule.DescribeAsync();\n\n            var nextRun = description.Info.NextActionTimes.FirstOrDefault();\n            var isPaused = description.Schedule.State.Paused;\n            var pauseNote = description.Schedule.State.Note;\n\n            Console.WriteLine($\"Schedule: {schedule.Id}\");\n            Console.WriteLine($\"   Status: {(isPaused ? \"Paused\" : \"Active\")}\");\n            Console.WriteLine($\"   Next run: {nextRun?.ToString() ?? \"N/A\"}\");\n\n            if (!string.IsNullOrEmpty(pauseNote))\n            {\n                Console.WriteLine($\"   Note: {pauseNote}\");\n            }\n\n            // Display memo if available\n            if (description.Memo?.Fields != null)\n            {\n                Console.WriteLine(\"   Metadata:\");\n                foreach (var kvp in description.Memo.Fields)\n                {\n                    Console.WriteLine($\"     - {kvp.Key}: {kvp.Value}\");\n                }\n            }\n\n            // Recent execution history\n            if (description.Info.RecentActions.Any())\n            {\n                Console.WriteLine(\"   Recent executions:\");\n                foreach (var action in description.Info.RecentActions.Take(3))\n                {\n                    Console.WriteLine($\"     - {action.ActualTime}\");\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n\n    public async Task PauseAllSchedules(string reason)\n    {\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            await schedule.PauseAsync(reason);\n            Console.WriteLine($\"Paused: {scheduleInfo.Id}\");\n        }\n    }\n\n    public async Task ResumeAllSchedules(string reason)\n    {\n        var schedules = await _workflow.Schedules!.ListAsync();\n\n        await foreach (var scheduleInfo in schedules)\n        {\n            var schedule = await _workflow.Schedules!.GetAsync(scheduleInfo.Id);\n            await schedule.UnpauseAsync(reason);\n            Console.WriteLine($\"Resumed: {scheduleInfo.Id}\");\n        }\n    }\n}\n\n// Usage\nvar workflow = XiansContext.CurrentWorkflow;\nvar manager = new ScheduleManager(workflow);\n\nawait manager.DisplayAllSchedules();\n\n// Pause all for maintenance\nawait manager.PauseAllSchedules(\"Database migration in progress\");\n\n// Resume after maintenance\nawait manager.ResumeAllSchedules(\"Migration completed successfully\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#api-reference","title":"API Reference","text":""},{"location":"sdk-reference/scheduling-sdk/#schedulecollection","title":"ScheduleCollection","text":"<p>Access: <code>workflow.Schedules!</code> or <code>XiansContext.CurrentWorkflow.Schedules!</code></p>"},{"location":"sdk-reference/scheduling-sdk/#creation","title":"Creation","text":"<ul> <li><code>Create(scheduleId)</code> \u2192 <code>ScheduleBuilder</code> - Start building new schedule</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#retrieval","title":"Retrieval","text":"<ul> <li><code>GetAsync(scheduleId)</code> \u2192 <code>Task&lt;XiansSchedule&gt;</code> - Get schedule (async)</li> <li><code>Get(scheduleId)</code> \u2192 <code>XiansSchedule</code> - Get schedule (sync)</li> <li><code>ListAsync()</code> \u2192 <code>Task&lt;IAsyncEnumerable&lt;ScheduleListDescription&gt;&gt;</code> - List all schedules</li> <li><code>ExistsAsync(scheduleId)</code> \u2192 <code>Task&lt;bool&gt;</code> - Check existence</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#management","title":"Management","text":"<ul> <li><code>PauseAsync(scheduleId, note?)</code> \u2192 <code>Task</code> - Pause schedule</li> <li><code>UnpauseAsync(scheduleId, note?)</code> \u2192 <code>Task</code> - Resume schedule</li> <li><code>TriggerAsync(scheduleId)</code> \u2192 <code>Task</code> - Trigger immediate execution</li> <li><code>DeleteAsync(scheduleId)</code> \u2192 <code>Task</code> - Delete schedule</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#schedulebuilder","title":"ScheduleBuilder","text":""},{"location":"sdk-reference/scheduling-sdk/#schedule-timing-methods-choose-one","title":"Schedule Timing Methods (choose one)","text":"<p>Convenience Extensions: - <code>.Daily(hour, minute = 0, timezone?)</code> - Daily at specific time - <code>.Weekly(dayOfWeek, hour, minute = 0, timezone?)</code> - Weekly on day - <code>.Monthly(dayOfMonth, hour, minute = 0, timezone?)</code> - Monthly on day - <code>.Hourly(minute = 0)</code> - Every hour at minute - <code>.Weekdays(hour, minute = 0, timezone?)</code> - Monday-Friday - <code>.EverySeconds(seconds)</code> - Interval in seconds - <code>.EveryMinutes(minutes)</code> - Interval in minutes - <code>.EveryHours(hours)</code> - Interval in hours - <code>.EveryDays(days, hour = 0, minute = 0, timezone?)</code> - Interval in days</p> <p>Core Methods: - <code>.WithCronSchedule(expression, timezone?)</code> - Cron expression - <code>.WithIntervalSchedule(interval, offset?)</code> - Duration interval - <code>.WithCalendarSchedule(dateTime, timezone?)</code> - Specific date/time - <code>.WithScheduleSpec(spec)</code> - Custom Temporal spec</p>"},{"location":"sdk-reference/scheduling-sdk/#workflow-configuration","title":"Workflow Configuration","text":"<ul> <li><code>.WithInput(params object[] args)</code> - Workflow input arguments</li> <li><code>.WithMemo(Dictionary&lt;string, object&gt;)</code> - Custom metadata</li> <li><code>.WithRetryPolicy(RetryPolicy)</code> - Retry policy</li> <li><code>.WithTimeout(TimeSpan)</code> - Execution timeout</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#overlap-policies","title":"Overlap Policies","text":"<ul> <li><code>.SkipIfRunning()</code> - Skip if running (recommended)</li> <li><code>.AllowOverlap()</code> - Allow concurrent executions</li> <li><code>.BufferOne()</code> - Queue one execution</li> <li><code>.CancelOther()</code> - Cancel running, start new</li> <li><code>.TerminateOther()</code> - Terminate running (caution)</li> <li><code>.WithOverlapPolicy(ScheduleOverlapPolicy)</code> - Set policy</li> <li><code>.WithSchedulePolicy(SchedulePolicy)</code> - Advanced policy</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#schedule-state","title":"Schedule State","text":"<ul> <li><code>.StartPaused(paused = true, note?)</code> - Create paused</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#execution","title":"Execution","text":"<ul> <li><code>.StartAsync()</code> - Create and start schedule (required)</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#xiansschedule","title":"XiansSchedule","text":""},{"location":"sdk-reference/scheduling-sdk/#properties","title":"Properties","text":"<ul> <li><code>Id</code> \u2192 <code>string</code> - Schedule identifier</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#information","title":"Information","text":"<ul> <li><code>DescribeAsync()</code> \u2192 <code>Task&lt;ScheduleDescription&gt;</code> - Get details</li> <li><code>Info.NextActionTimes</code> - Upcoming executions</li> <li><code>Info.RecentActions</code> - Execution history</li> <li><code>Schedule.State.Paused</code> - Paused status</li> <li><code>Schedule.State.Note</code> - State note</li> <li><code>Schedule.Spec</code> - Schedule specification</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#operations","title":"Operations","text":"<ul> <li><code>PauseAsync(note?)</code> \u2192 <code>Task</code> - Pause</li> <li><code>UnpauseAsync(note?)</code> \u2192 <code>Task</code> - Resume</li> <li><code>TriggerAsync()</code> \u2192 <code>Task</code> - Trigger now</li> <li><code>UpdateAsync(updater)</code> \u2192 <code>Task</code> - Modify config</li> <li><code>DeleteAsync()</code> \u2192 <code>Task</code> - Delete</li> <li><code>BackfillAsync(backfills)</code> \u2192 <code>Task</code> - Execute for past ranges</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#advanced","title":"Advanced","text":"<ul> <li><code>GetHandle()</code> \u2192 <code>ScheduleHandle</code> - Temporal handle</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#exceptions","title":"Exceptions","text":"<p>Namespace: <code>Xians.Lib.Agents.Scheduling.Models</code></p> <ul> <li><code>ScheduleAlreadyExistsException</code> - Schedule ID exists</li> <li><code>ScheduleNotFoundException</code> - Schedule not found</li> <li><code>InvalidScheduleSpecException</code> - Invalid configuration</li> </ul>"},{"location":"sdk-reference/scheduling-sdk/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"sdk-reference/scheduling-sdk/#1-always-configure-overlap-policies","title":"1. Always Configure Overlap Policies","text":"C#<pre><code>.SkipIfRunning()  // Recommended for most cases\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#2-add-retry-policies-for-production","title":"2. Add Retry Policies for Production","text":"C#<pre><code>.WithRetryPolicy(new RetryPolicy\n{\n    MaximumAttempts = 3,\n    InitialInterval = TimeSpan.FromSeconds(10),\n    BackoffCoefficient = 2.0\n})\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#3-use-timezones-for-user-facing-schedules","title":"3. Use Timezones for User-Facing Schedules","text":"C#<pre><code>.Daily(hour: 9, timezone: \"America/New_York\")\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#4-check-existence-for-idempotency","title":"4. Check Existence for Idempotency","text":"C#<pre><code>if (!await workflow.Schedules!.ExistsAsync(\"my-schedule\"))\n{\n    await workflow.Schedules!.Create(\"my-schedule\")...StartAsync();\n}\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#5-use-meaningful-schedule-ids","title":"5. Use Meaningful Schedule IDs","text":"C#<pre><code>.Create($\"daily-sync-{companyId}\")  // Good\n.Create(\"schedule1\")                // Bad\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#6-add-metadata-with-memo","title":"6. Add Metadata with Memo","text":"C#<pre><code>.WithMemo(new Dictionary&lt;string, object&gt;\n{\n    { \"owner\", \"team-name\" },\n    { \"purpose\", \"data-sync\" }\n})\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#7-set-appropriate-timeouts","title":"7. Set Appropriate Timeouts","text":"C#<pre><code>.WithTimeout(TimeSpan.FromHours(2))\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#8-use-descriptive-pause-notes","title":"8. Use Descriptive Pause Notes","text":"C#<pre><code>await schedule.PauseAsync(\"Database migration - ETA 2 hours\");\n</code></pre>"},{"location":"sdk-reference/scheduling-sdk/#conclusion","title":"Conclusion","text":"<p>Xians scheduling provides production-grade time-based automation for AI agents with:</p> <ul> <li>Flexible scheduling - Cron, intervals, calendars, convenience methods</li> <li>Production features - Retries, timeouts, overlap policies</li> <li>Multi-tenant security - Automatic isolation and filtering</li> <li>Developer experience - Fluent API, auto-determinism, zero config</li> <li>Enterprise reliability - Built on Temporal's proven scheduling engine</li> </ul> <p>Use schedules to transform reactive agents into autonomous, proactive systems that operate on your timeline.</p> <p>Next Steps:</p> <ul> <li>Scheduling Concepts - Quick start guide</li> <li>Workflows - Workflow orchestration</li> <li>Agents - Agent architecture</li> <li>Tenants - Multi-tenant patterns</li> </ul>"},{"location":"user-guide/overview/","title":"User Guide Overview","text":"<p>Welcome to the Xians.ai User Guide. This comprehensive guide will help you master agent development with Xians.ai.</p>"},{"location":"user-guide/overview/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers everything you need to know to build production-ready AI agents:</p> <ul> <li>Agent Architecture - Understanding how agents work</li> <li>Development Workflow - Best practices for agent development</li> <li>Deployment - Taking your agents to production</li> <li>Monitoring &amp; Debugging - Keeping your agents healthy</li> <li>Advanced Topics - Multi-agent systems, workflows, and more</li> </ul>"},{"location":"user-guide/overview/#getting-started","title":"Getting Started","text":"<p>If you're new to Xians.ai, we recommend following this learning path:</p> <ol> <li>Installation - Set up your environment</li> <li>Quick Start - Create your first agent</li> <li>Configuration - Learn about configuration options</li> </ol>"},{"location":"user-guide/overview/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/overview/#agents","title":"Agents","text":"<p>Agents are autonomous AI systems that can:</p> <ul> <li>Understand natural language</li> <li>Execute tasks and workflows</li> <li>Learn from interactions</li> <li>Collaborate with other agents</li> </ul>"},{"location":"user-guide/overview/#capabilities","title":"Capabilities","text":"<p>Capabilities are specific skills or functions that agents can perform:</p> Python<pre><code>@capability(description=\"Send email to user\")\ndef send_email(self, to: str, subject: str, body: str) -&gt; bool:\n    # Implementation\n    return True\n</code></pre>"},{"location":"user-guide/overview/#workflows","title":"Workflows","text":"<p>Workflows orchestrate multiple agent capabilities into complex processes:</p> Python<pre><code>workflow = Workflow(\"customer_onboarding\")\nworkflow.add_step(\"verify_email\")\nworkflow.add_step(\"create_account\")\nworkflow.add_step(\"send_welcome\")\n</code></pre>"},{"location":"user-guide/overview/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD\n    A[User] --&gt;|Request| B[Agent]\n    B --&gt;|Process| C[LLM]\n    C --&gt;|Response| B\n    B --&gt;|Execute| D[Capabilities]\n    D --&gt;|Result| B\n    B --&gt;|Reply| A</code></pre>"},{"location":"user-guide/overview/#development-workflow","title":"Development Workflow","text":""},{"location":"user-guide/overview/#1-design","title":"1. Design","text":"<ul> <li>Define agent purpose and capabilities</li> <li>Identify required integrations</li> <li>Plan conversation flows</li> </ul>"},{"location":"user-guide/overview/#2-implement","title":"2. Implement","text":"<ul> <li>Create agent class</li> <li>Define capabilities</li> <li>Configure LLM and settings</li> </ul>"},{"location":"user-guide/overview/#3-test","title":"3. Test","text":"<ul> <li>Unit test capabilities</li> <li>Integration testing</li> <li>User acceptance testing</li> </ul>"},{"location":"user-guide/overview/#4-deploy","title":"4. Deploy","text":"<ul> <li>Production configuration</li> <li>Monitoring setup</li> <li>Gradual rollout</li> </ul>"},{"location":"user-guide/overview/#best-practices","title":"Best Practices","text":"<p>Development Best Practices</p> <ul> <li>Start simple and iterate</li> <li>Test thoroughly before deployment</li> <li>Monitor agent performance</li> <li>Keep capabilities focused and modular</li> <li>Document your agent's behavior</li> </ul> <p>Common Pitfalls</p> <ul> <li>Overly complex initial implementations</li> <li>Insufficient error handling</li> <li>Poor testing coverage</li> <li>Inadequate monitoring</li> </ul>"},{"location":"user-guide/overview/#next-steps","title":"Next Steps","text":"<p>Explore specific topics:</p> <ul> <li>Agent Development - Detailed agent development guide</li> <li>Capabilities - Creating custom capabilities</li> <li>Workflows - Building complex workflows</li> <li>Deployment - Production deployment guide</li> <li>Monitoring - Observability and debugging</li> </ul>"},{"location":"user-guide/overview/#community--support","title":"Community &amp; Support","text":"<ul> <li>Discord Community - Get help and share ideas</li> <li>GitHub Discussions - Ask questions</li> <li>Examples - Sample projects</li> <li>Blog - Latest updates and tutorials</li> </ul>"}]}