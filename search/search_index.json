{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Open Source Agent Control Plane","text":"<p>  Build agents with the framework of your choice - Azure AI, Bedrock, Semantic Kernel, LangGraph, or your own custom runtime. Xians doesn't dictate how your agents think - it provides centralized governance, orchestration, and monitoring for your entire agent fleet. Multi-tenant governance with centralized control. Fault-tolerant durable workflows for business process automation. Horizontal scalability with workers in private subnets (no incoming ports). Centralized prompt and knowledge management. Real-time monitoring with distributed tracing. The complete control plane you need but would never want to build yourself.   </p> Get Started Introduction    Image: Xians developer portal to manage and monitor all agent operations.     Image: Xians (optional) end user portal where end users can collaborate with agents.  <p>Looking to integrate your custom UI with Xians? Explore the comprehensive Server API documentation here: Server API Docs</p>"},{"location":"#other-useful-resources","title":"Other Useful Resources","text":"<ul> <li>GitHub Organization</li> <li>Official Website</li> </ul>"},{"location":"concepts/A2A/","title":"Agent-to-Agent (A2A) Communication","text":"<p>A2A enables workflows to communicate with each other\u2014whether sending chat messages, data payloads, or invoking Temporal operations like signals, queries, and updates.</p>"},{"location":"concepts/A2A/#overview","title":"Overview","text":"Source Target Communication Method Any workflow Built-in workflow <code>SendChatAsync</code>, <code>SendDataAsync</code> Any workflow Custom workflow <code>SendSignalAsync</code>, <code>QueryAsync</code>, <code>UpdateAsync</code> <p>All A2A operations are accessed via <code>XiansContext.A2A</code> within workflow or activity contexts.</p>"},{"location":"concepts/A2A/#communicating-with-built-in-workflows","title":"Communicating with Built-in Workflows","text":"<p>Built-in workflows handle A2A messages through message listener methods (<code>OnUserChatMessage</code>, <code>OnUserDataMessage</code>).</p>"},{"location":"concepts/A2A/#sending-chat-messages","title":"Sending Chat Messages","text":"C#<pre><code>// Send to a specific workflow instance\nvar response = await XiansContext.A2A.SendChatAsync(targetWorkflow, new A2AMessage \n{ \n    Text = \"Hello\" \n});\n\n// Send to a built-in workflow by name\nvar response = await XiansContext.A2A.SendChatToBuiltInAsync(\"WebWorkflow\", new A2AMessage \n{ \n    Text = \"Process this request\" \n});\n\n// Shorthand for text-only messages\nvar response = await XiansContext.A2A.SendTextAsync(\"WebWorkflow\", \"Hello\");\n</code></pre>"},{"location":"concepts/A2A/#sending-data-messages","title":"Sending Data Messages","text":"C#<pre><code>var message = new A2AMessage\n{\n    Text = \"Process order\",\n    Data = new { orderId = \"12345\", items = new[] { \"item1\", \"item2\" } }\n};\n\nvar response = await XiansContext.A2A.SendDataToBuiltInAsync(\"OrderProcessor\", message);\n</code></pre>"},{"location":"concepts/A2A/#receiving-messages-target-workflow","title":"Receiving Messages (Target Workflow)","text":"C#<pre><code>var workflow = agent.Workflows.DefineBuiltIn(name: \"OrderProcessor\");\n\n// Handle chat messages\nworkflow.OnUserChatMessage(async context =&gt;\n{\n    var incomingText = context.Message.Text;\n    await context.ReplyAsync($\"Processed: {incomingText}\");\n});\n\n// Handle data messages\nworkflow.OnUserDataMessage(async context =&gt;\n{\n    var orderData = context.Message.Data;\n    await context.ReplyAsync(\"Order received\", new { status = \"confirmed\" });\n});\n</code></pre>"},{"location":"concepts/A2A/#communicating-with-custom-workflows","title":"Communicating with Custom Workflows","text":"<p>Custom workflows use Temporal's native signal, query, and update mechanisms. These are ideal for structured, typed communication.</p>"},{"location":"concepts/A2A/#sending-signals-fire-and-forget","title":"Sending Signals (Fire-and-Forget)","text":"C#<pre><code>await XiansContext.A2A.SendSignalAsync(\n    workflowId: \"order-workflow-123\",\n    signalName: \"ProcessOrder\",\n    new { orderId = \"12345\", priority = \"high\" }\n);\n</code></pre>"},{"location":"concepts/A2A/#querying-state-read-only","title":"Querying State (Read-Only)","text":"C#<pre><code>var state = await XiansContext.A2A.QueryAsync&lt;OrderState&gt;(\n    workflowId: \"order-workflow-123\",\n    queryName: \"GetOrderStatus\",\n    \"12345\"  // query arguments\n);\n</code></pre>"},{"location":"concepts/A2A/#sending-updates-request-response","title":"Sending Updates (Request-Response)","text":"<p>Updates are synchronous operations that modify state and return a result. Requires Temporal Server 1.20+.</p> C#<pre><code>var result = await XiansContext.A2A.UpdateAsync&lt;ProcessResult&gt;(\n    workflowId: \"order-workflow-123\",\n    updateName: \"UpdateOrderStatus\",\n    new { orderId = \"12345\", status = \"shipped\" }\n);\n</code></pre>"},{"location":"concepts/A2A/#receiving-in-custom-workflows","title":"Receiving in Custom Workflows","text":"C#<pre><code>[Workflow(\"MyAgent:OrderWorkflow\")]\npublic class OrderWorkflow\n{\n    private readonly Queue&lt;object&gt; _requests = new();\n    private int _processedCount = 0;\n\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        while (true)\n        {\n            await Workflow.WaitConditionAsync(() =&gt; _requests.Count &gt; 0);\n            var request = _requests.Dequeue();\n            // Process request...\n        }\n    }\n\n    [WorkflowSignal(\"ProcessOrder\")]\n    public Task ProcessOrder(object request)\n    {\n        _requests.Enqueue(request);\n        return Task.CompletedTask;\n    }\n\n    [WorkflowQuery(\"GetOrderStatus\")]\n    public OrderState GetOrderStatus(string orderId)\n    {\n        return new OrderState { OrderId = orderId, Count = _processedCount };\n    }\n\n    [WorkflowUpdate(\"UpdateOrderStatus\")]\n    public Task&lt;ProcessResult&gt; UpdateOrderStatus(object request)\n    {\n        _processedCount++;\n        return Task.FromResult(new ProcessResult { Status = \"Updated\" });\n    }\n}\n</code></pre>"},{"location":"concepts/A2A/#a2amessage-properties","title":"A2AMessage Properties","text":"Property Description <code>Text</code> Primary text content <code>Data</code> Structured data payload (any serializable object) <code>Metadata</code> Key-value pairs for custom metadata <code>Authorization</code> Auth token passed to target context <code>ThreadId</code> Conversation/correlation tracking <code>ParticipantId</code> Original user/caller identifier <code>Scope</code> Defaults to <code>\"A2A\"</code> <code>Hint</code> Processing hint for the target"},{"location":"concepts/A2A/#preserving-context","title":"Preserving Context","text":"<p>Use <code>A2AMessage.FromContext()</code> to forward context fields when chaining A2A calls:</p> C#<pre><code>workflow.OnUserChatMessage(async context =&gt;\n{\n    // Preserve original context when forwarding\n    var message = A2AMessage.FromContext(context, text: \"Forward this\");\n    message.Metadata = new Dictionary&lt;string, string&gt; { [\"source\"] = \"forwarder\" };\n\n    var response = await XiansContext.A2A.SendChatToBuiltInAsync(\"TargetWorkflow\", message);\n});\n</code></pre>"},{"location":"concepts/A2A/#error-handling","title":"Error Handling","text":"<p>Use <code>Try*</code> variants for non-throwing error handling:</p> C#<pre><code>var (success, response, error) = await XiansContext.A2A.TrySendChatToBuiltInAsync(\n    \"WebWorkflow\", \n    new A2AMessage { Text = \"Hello\" }\n);\n\nif (!success)\n{\n    logger.LogWarning(\"A2A failed: {Error}\", error);\n}\n</code></pre>"},{"location":"concepts/A2A/#quick-reference","title":"Quick Reference","text":"C#<pre><code>// To Built-in workflows\nawait XiansContext.A2A.SendTextAsync(\"WorkflowName\", \"message\");\nawait XiansContext.A2A.SendChatToBuiltInAsync(\"WorkflowName\", message);\nawait XiansContext.A2A.SendDataToBuiltInAsync(\"WorkflowName\", message);\n\n// To Custom workflows  \nawait XiansContext.A2A.SendSignalAsync(workflowId, \"SignalName\", args);\nvar result = await XiansContext.A2A.QueryAsync&lt;T&gt;(workflowId, \"QueryName\", args);\nvar result = await XiansContext.A2A.UpdateAsync&lt;T&gt;(workflowId, \"UpdateName\", args);\n</code></pre>"},{"location":"concepts/agents/","title":"Agents &amp; Workflows","text":""},{"location":"concepts/agents/#overview","title":"Overview","text":"<p>Agents in Xians are database entities that provide identity and management capabilities for your AI applications. They serve as containers for workflows, knowledge, documents, and other resources, with built-in multi-tenancy and isolation.</p>"},{"location":"concepts/agents/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/agents/#agents","title":"Agents","text":"<p>An Agent is a registered entity that:</p> <ul> <li>Provides an identity for management and isolation purposes</li> <li>Can be system-scoped (templates deployable across tenants) or tenant-scoped (deployed to a specific tenant)</li> <li>Owns and manages collections of workflows, knowledge, and documents</li> <li>Automatically handles tenant isolation and resource scoping</li> </ul> <pre><code>graph TB\n    A[XiansAgent] --&gt; B[Workflows]\n    A --&gt; C[Knowledge]\n    A --&gt; D[Documents]\n    B --&gt; E[Built-In Workflow 1]\n    B --&gt; F[Built-In Workflow 2]\n    B --&gt; G[Custom Workflow 1]\n    B --&gt; H[Custom Workflow 2]</code></pre>"},{"location":"concepts/agents/#workflows","title":"Workflows","text":"<p>Workflows are Temporal-based execution units attached to agents. There are two types:</p>"},{"location":"concepts/agents/#built-in-workflows","title":"Built-In Workflows","text":"<p>Pre-built workflows with plumbing for common patterns:</p> <ul> <li>Listen to user messages (chat and data)</li> <li>Handle webhook invocations</li> <li>No workflow class definition required</li> </ul>"},{"location":"concepts/agents/#custom-workflows","title":"Custom Workflows","text":"<p>Plain Temporal workflows you define:</p> <ul> <li>Full control over workflow logic</li> <li>Access to all Temporal features (signals, queries, updates, child workflows)</li> <li>Automatic tenant isolation</li> <li>Scheduled execution support</li> </ul> <pre><code>sequenceDiagram\n    participant U as User\n    participant BW as Built-In Workflow\n    participant CW as Custom Workflow\n    participant A as Activities\n\n    U-&gt;&gt;BW: Send Message\n    BW-&gt;&gt;BW: Execute Handler\n    BW-&gt;&gt;U: Reply\n\n    U-&gt;&gt;CW: Webhook/Signal\n    CW-&gt;&gt;A: Execute Activities\n    A--&gt;&gt;CW: Results\n    CW-&gt;&gt;U: Response</code></pre>"},{"location":"concepts/agents/#agent-registration","title":"Agent Registration","text":""},{"location":"concepts/agents/#creating-an-agent","title":"Creating an Agent","text":"C#<pre><code>var xiansPlatform = await XiansPlatform.InitializeAsync(new XiansOptions\n{\n    ServerUrl = \"https://your-server.com\",\n    ApiKey = \"agent-certificate\"\n});\n\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"MyAgent\",\n    Version = \"1.0.0\",\n    Description = \"My intelligent agent\",\n    IsTemplate = true  // or false for tenant-specific\n});\n</code></pre>"},{"location":"concepts/agents/#system-scoped-vs-tenant-scoped","title":"System-Scoped vs Tenant-Scoped","text":"Type Scope Use Case Deployment System-Scoped Multi-tenant template Reusable agents across tenants Registered once, deployed to multiple tenants Tenant-Scoped Single tenant Tenant-specific customizations Deployed to developer's tenant only"},{"location":"concepts/agents/#agent-api-reference","title":"Agent API Reference","text":""},{"location":"concepts/agents/#properties","title":"Properties","text":"Property Type Description <code>Name</code> <code>string</code> Unique identifier for the agent <code>Version</code> <code>string?</code> Optional version identifier <code>Description</code> <code>string?</code> Human-readable description <code>IsTemplate</code> <code>bool</code> Whether agent is multi-tenant template <code>Workflows</code> <code>WorkflowCollection</code> Collection of workflows <code>Knowledge</code> <code>KnowledgeCollection</code> Knowledge base management <code>Documents</code> <code>DocumentCollection</code> Document storage and retrieval"},{"location":"concepts/agents/#methods","title":"Methods","text":"Method Description <code>GetBuiltInWorkflow(string? name)</code> Get a built-in workflow by name (null for unnamed) <code>GetCustomWorkflow&lt;T&gt;()</code> Get a custom workflow by type <code>GetAllWorkflows()</code> Get all workflows for this agent <code>UploadWorkflowDefinitionsAsync()</code> Upload workflow definitions to server <code>RunAllAsync(CancellationToken)</code> Run all registered workflows"},{"location":"concepts/agents/#defining-workflows","title":"Defining Workflows","text":""},{"location":"concepts/agents/#built-in","title":"Built-In","text":"<p>Built-in workflows are ideal for message-driven patterns:</p> C#<pre><code>// Define an unnamed built-in workflow\nvar workflow = agent.Workflows.DefineBuiltIn();\n\n// Define a named built-in workflow\nvar chatWorkflow = agent.Workflows.DefineBuiltIn(name: \"ChatHandler\");\n\n// Register message handler\nchatWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var userMessage = context.Message.Text;\n    var response = await ProcessMessage(userMessage);\n    await context.ReplyAsync(response);\n});\n\n// Register data message handler\nchatWorkflow.OnUserDataMessage(async (context) =&gt;\n{\n    var data = context.Message.Data;\n    await ProcessData(data);\n});\n</code></pre>"},{"location":"concepts/agents/#custom","title":"Custom","text":"<p>Custom workflows give you full Temporal capabilities:</p> C#<pre><code>// Define custom workflow\nvar customWorkflow = agent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;();\n\n// Add activities\ncustomWorkflow.AddActivity&lt;MyActivity&gt;();\ncustomWorkflow.AddActivity(new MyActivityInstance());\n\n// Add multiple activities\ncustomWorkflow.AddActivities(\n    new Activity1(),\n    new Activity2(),\n    new Activity3()\n);\n</code></pre>"},{"location":"concepts/agents/#example-custom-workflow-class","title":"Example Custom Workflow Class","text":"C#<pre><code>using Temporalio.Workflows;\n\n[Workflow]\npublic class MyCustomWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(WorkflowInput input)\n    {\n        // Execute activities\n        var result = await Workflow.ExecuteActivityAsync(\n            (MyActivity act) =&gt; act.ProcessAsync(input),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) }\n        );\n\n        // Wait for signals\n        await Workflow.WaitConditionAsync(() =&gt; signalReceived);\n\n        return result;\n    }\n\n    [WorkflowSignal]\n    public async Task HandleSignalAsync(SignalData data)\n    {\n        // Handle signal\n    }\n\n    [WorkflowQuery]\n    public string GetStatus() =&gt; currentStatus;\n}\n</code></pre>"},{"location":"concepts/agents/#workflow-api-reference","title":"Workflow API Reference","text":""},{"location":"concepts/agents/#properties_1","title":"Properties","text":"Property Type Description <code>WorkflowType</code> <code>string</code> Unique workflow type identifier (prefixed with agent name) <code>Name</code> <code>string?</code> Optional workflow name <code>Workers</code> <code>int</code> Number of worker instances, Default is 100 <code>Schedules</code> <code>ScheduleCollection?</code> Scheduled execution management"},{"location":"concepts/agents/#methods_1","title":"Methods","text":"Method Description <code>AddActivity(object)</code> Register activity instance (shared across workers) <code>AddActivity&lt;T&gt;()</code> Register activity type (new instance per worker) <code>AddActivities(params object[])</code> Register multiple activity instances <code>OnUserChatMessage(Func&lt;UserMessageContext, Task&gt;)</code> Register chat message handler (built-in only) <code>OnUserDataMessage(Func&lt;UserMessageContext, Task&gt;)</code> Register data message handler (built-in only) <code>RunAsync(CancellationToken)</code> Start workflow workers"},{"location":"concepts/agents/#message-context","title":"Message Context","text":"<p>When handling messages in built-in workflows, you receive a <code>UserMessageContext</code>:</p>"},{"location":"concepts/agents/#usermessagecontext-properties","title":"UserMessageContext Properties","text":"Property Type Description <code>Message</code> <code>CurrentMessage</code> The current message with text, data, and context information <code>Metadata</code> <code>Dictionary&lt;string, string&gt;?</code> Optional metadata for the message <code>SkipResponse</code> <code>bool</code> Set to true to prevent messages from being sent to the user"},{"location":"concepts/agents/#usermessagecontext-methods","title":"UserMessageContext Methods","text":"Method Description <code>ReplyAsync(string text)</code> Send a simple text reply <code>ReplyAsync(string text, object? data)</code> Send a reply with text and data <code>SendDataAsync(object data, string? content)</code> Send a data message with optional text <code>GetChatHistoryAsync(int page, int pageSize)</code> Retrieve paginated chat history <code>GetLastHintAsync()</code> Retrieve the last hint for this conversation <code>SendHandoffAsync(string targetWorkflowId, ...)</code> Hand off conversation to another workflow"},{"location":"concepts/agents/#currentmessage-properties","title":"CurrentMessage Properties","text":"<p>All message properties are accessed via <code>context.Message</code>:</p> Property Type Description <code>Text</code> <code>string</code> The text content of the message <code>ParticipantId</code> <code>string</code> The participant (user) ID <code>RequestId</code> <code>string</code> Unique request identifier <code>TenantId</code> <code>string</code> The tenant ID for multi-tenancy <code>Scope</code> <code>string?</code> Optional scope for the message <code>Hint</code> <code>string?</code> Optional hint for context <code>ThreadId</code> <code>string?</code> Thread ID for conversation tracking <code>Data</code> <code>object?</code> Associated data payload <code>Authorization</code> <code>string?</code> Authorization token if provided"},{"location":"concepts/agents/#accessing-agent-resources","title":"Accessing Agent Resources","text":"<p>Agent resources (Knowledge, Documents, Workflows) are accessed via <code>XiansContext</code>:</p> C#<pre><code>// In workflow or activity context\nvar agent = XiansContext.CurrentAgent;\nvar workflow = XiansContext.CurrentWorkflow;\nvar tenantId = XiansContext.TenantId;  // For system-scoped agents\n</code></pre>"},{"location":"concepts/agents/#example-usage","title":"Example Usage","text":"C#<pre><code>chatWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Access message data\n    var message = context.Message.Text;\n    var participantId = context.Message.ParticipantId;\n    var requestId = context.Message.RequestId;\n    var tenantId = context.Message.TenantId;\n    var threadId = context.Message.ThreadId;\n    var data = context.Message.Data;\n\n    // Reply to user\n    await context.ReplyAsync(\"Hello!\");\n\n    // Reply with text and data\n    await context.ReplyAsync(\"Response text\", new { key = \"value\" });\n\n    // Send data message\n    await context.SendDataAsync(new { key = \"value\" }, \"Optional text\");\n\n    // Access agent's knowledge via XiansContext\n    var agent = XiansContext.CurrentAgent;\n    var knowledgeItem = await agent.Knowledge.GetAsync(\"knowledge-name\");\n    var allKnowledge = await agent.Knowledge.ListAsync();\n\n    // Update knowledge\n    await agent.Knowledge.UpdateAsync(\"knowledge-name\", \"content\", type: \"instruction\");\n\n    // Access documents\n    var doc = await agent.Documents.GetAsync(\"doc-id\");\n\n    // Get chat history\n    var history = await context.GetChatHistoryAsync(page: 1, pageSize: 10);\n});\n</code></pre>"},{"location":"concepts/agents/#workflow-scheduling-self-scheduling-pattern","title":"Workflow Scheduling (Self-Scheduling Pattern)","text":"<p>Workflows can schedule themselves to run at specific times or intervals. This is done inside the workflow using <code>XiansContext.CurrentWorkflow.Schedules</code>:</p>"},{"location":"concepts/agents/#self-scheduling-example","title":"Self-Scheduling Example","text":"C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents.Core;\nusing Xians.Lib.Agents.Scheduling.Models;\n\n[Workflow(\"MyAgent:RecurringTask\")]\npublic class RecurringTaskWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string taskId, int intervalHours)\n    {\n        // At the start of the workflow, ensure a recurring schedule exists\n        await EnsureScheduleExists(taskId, intervalHours);\n\n        // Perform the actual work\n        await DoWorkAsync(taskId);\n    }\n\n    private async Task EnsureScheduleExists(string taskId, int intervalHours)\n    {\n        try\n        {\n            // Self-schedule using XiansContext.CurrentWorkflow\n            // Automatically uses activities when in workflow context!\n            var schedule = await XiansContext.CurrentWorkflow.Schedules!\n                .Create($\"recurring-{taskId}\")\n                .WithIntervalSchedule(TimeSpan.FromHours(intervalHours))\n                .WithInput(new object[] { taskId, intervalHours })\n                .StartAsync();\n\n            Workflow.Logger.LogInformation(\n                \"Schedule created - will run every {Hours} hours\",\n                intervalHours);\n        }\n        catch (ScheduleAlreadyExistsException ex)\n        {\n            Workflow.Logger.LogInformation(\n                \"Schedule already exists: {ScheduleId}\",\n                ex.ScheduleId);\n        }\n    }\n\n    private async Task DoWorkAsync(string taskId)\n    {\n        // Your workflow logic here\n        Workflow.Logger.LogInformation(\"Processing task: {TaskId}\", taskId);\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#child-workflows","title":"Child Workflows","text":"<p>Workflows can start and execute other workflows as child workflows using <code>XiansContext.Workflows</code>:</p>"},{"location":"concepts/agents/#starting-child-workflows-fire-and-forget","title":"Starting Child Workflows (Fire and Forget)","text":"<p>Use <code>StartAsync</code> to start a child workflow without waiting for its completion:</p> C#<pre><code>[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string taskId)\n    {\n        // Start child workflow by type - fire and forget\n        await XiansContext.Workflows.StartAsync&lt;ChildWorkflow&gt;(\n            idPostfix: taskId,\n            args: new object[] { \"param1\", \"param2\" }\n        );\n\n        // Continue without waiting for child to complete\n        Workflow.Logger.LogInformation(\"Child workflow started\");\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#executing-child-workflows-wait-for-result","title":"Executing Child Workflows (Wait for Result)","text":"<p>Use <code>ExecuteAsync</code> to execute a child workflow and wait for its result:</p> C#<pre><code>[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(string data)\n    {\n        // Execute child workflow and wait for result\n        var result = await XiansContext.Workflows.ExecuteAsync&lt;ChildWorkflow, string&gt;(\n            idPostfix: \"process\",\n            args: new object[] { data }\n        );\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"concepts/agents/#xianscontextworkflows-api-reference","title":"XiansContext.Workflows API Reference","text":"Method Description <code>StartAsync&lt;TWorkflow&gt;(string? idPostfix, params object[] args)</code> Start child workflow by type without waiting <code>StartAsync(string workflowType, string? idPostfix, params object[] args)</code> Start child workflow by type string without waiting <code>ExecuteAsync&lt;TWorkflow, TResult&gt;(string? idPostfix, params object[] args)</code> Execute child workflow and wait for result <code>ExecuteAsync&lt;TResult&gt;(string workflowType, string? idPostfix, params object[] args)</code> Execute child workflow by type string and wait for result <p>Notes:</p> <ul> <li><code>idPostfix</code> is used to create unique workflow IDs (format: <code>{workflowType}-{idPostfix}</code>)</li> <li>If <code>idPostfix</code> is null, a GUID is generated automatically</li> <li>Throws <code>WorkflowAlreadyStartedException</code> if a workflow with the same ID is already running</li> <li>Works both inside workflows (as child workflows) and outside workflows (as new workflows)</li> </ul>"},{"location":"concepts/context/","title":"Operating Context","text":"<p><code>XiansContext</code> is the central hub for accessing all Xians SDK functionality. It provides unified access to agents, workflows, messaging, knowledge, documents, and schedules through a static API that works seamlessly in both workflow and activity contexts.</p>"},{"location":"concepts/context/#quick-reference","title":"Quick Reference","text":"Category Properties/Methods Description Context <code>WorkflowId</code>, <code>TenantId</code>, <code>InWorkflow</code>, <code>InActivity</code>, <code>InWorkflowOrActivity</code> Current execution context Safe Context <code>SafeWorkflowId</code>, <code>SafeWorkflowRunId</code>, <code>SafeWorkflowType</code>, <code>SafeAgentName</code> Non-throwing context access for logging Context Methods <code>GetParticipantId()</code>, <code>GetIdPostfix()</code>, <code>GetTaskQueue()</code> Extract metadata from context Current Instances <code>CurrentAgent</code>, <code>CurrentWorkflow</code> Access current agent/workflow instances Helpers <code>Workflows</code>, <code>Messaging</code>, <code>A2A</code> Operation helpers Registry <code>GetAgent()</code>, <code>TryGetAgent()</code>, <code>GetWorkflow()</code>, <code>GetBuiltInWorkflow()</code>, <code>GetAllAgents()</code>, <code>GetAllWorkflows()</code> Access registered resources Identity Construction <code>BuildBuiltInWorkflowType()</code>, <code>BuildBuiltInWorkflowId()</code>, <code>GetWorkflowTypeFor()</code> Build workflow identifiers"},{"location":"concepts/context/#context-properties","title":"Context Properties","text":""},{"location":"concepts/context/#basic-context","title":"Basic Context","text":"C#<pre><code>// Get current context information (throws if not in Temporal context)\nvar workflowId = XiansContext.WorkflowId;     // Current workflow ID\nvar tenantId = XiansContext.TenantId;         // Current tenant ID\n\n// Check execution context\nif (XiansContext.InWorkflow) { }              // In workflow?\nif (XiansContext.InActivity) { }              // In activity?\nif (XiansContext.InWorkflowOrActivity) { }    // In either?\n</code></pre>"},{"location":"concepts/context/#safe-context-no-exceptions","title":"Safe Context (No Exceptions)","text":"C#<pre><code>// Use for logging - returns null if not in context\n_logger.LogInfo(\"Workflow: {0}\", XiansContext.SafeWorkflowId ?? \"N/A\");\n_logger.LogInfo(\"Agent: {0}\", XiansContext.SafeAgentName ?? \"N/A\");\n</code></pre>"},{"location":"concepts/context/#context-methods","title":"Context Methods","text":"C#<pre><code>var userId = XiansContext.GetParticipantId();  // Get user ID from context\nvar idPostfix = XiansContext.GetIdPostfix();   // Get ID postfix\nvar taskQueue = XiansContext.GetTaskQueue();   // Get current task queue\n</code></pre>"},{"location":"concepts/context/#current-instance-access","title":"Current Instance Access","text":""},{"location":"concepts/context/#currentagent","title":"CurrentAgent","text":"<p>Access agent-scoped operations (Knowledge, Documents): C#<pre><code>var agent = XiansContext.CurrentAgent;\n\n// Access agent resources\nvar knowledge = await agent.Knowledge.GetAsync(\"config-key\");\nvar documents = await agent.Documents.QueryAsync(new DocumentQuery());\n</code></pre></p>"},{"location":"concepts/context/#currentworkflow","title":"CurrentWorkflow","text":"<p>Access workflow-scoped operations (Schedules): C#<pre><code>var workflow = XiansContext.CurrentWorkflow;\n\n// Access workflow resources\nvar schedule = await workflow.Schedules.GetAsync(\"my-schedule\");\nvar workflowType = workflow.WorkflowType;\n</code></pre></p>"},{"location":"concepts/context/#helper-operations","title":"Helper Operations","text":""},{"location":"concepts/context/#workflows-helper","title":"Workflows Helper","text":"<p>Manage workflow lifecycle: C#<pre><code>// Start workflow\nawait XiansContext.Workflows.StartAsync&lt;MyWorkflow&gt;(args, uniqueKey);\n\n// Execute and wait for result\nvar result = await XiansContext.Workflows.ExecuteAsync&lt;MyWorkflow, string&gt;(args, uniqueKey);\n\n// Get workflow handle for signaling/querying\nvar handle = await XiansContext.Workflows.GetWorkflowHandleAsync&lt;MyWorkflow&gt;(idPostfix);\nawait handle.SignalAsync(wf =&gt; wf.ProcessSignal, data);\nvar status = await handle.QueryAsync(wf =&gt; wf.GetStatus);\n</code></pre></p>"},{"location":"concepts/context/#messaging-helper","title":"Messaging Helper","text":"<p>Send messages to users: C#<pre><code>// Send chat message to user\nawait XiansContext.Messaging.SendChatAsync(\"userId123\", \"Your order shipped!\");\n\n// Send data message\nawait XiansContext.Messaging.SendDataAsync(\"userId123\", \"Order data\", orderObject);\n</code></pre></p>"},{"location":"concepts/context/#a2a-helper","title":"A2A Helper","text":"<p>Agent-to-agent communication: C#<pre><code>// Send message to built-in workflow\nvar response = await XiansContext.A2A.SendChatToBuiltInAsync(\n    \"WebWorkflow\", \n    new A2AMessage { Text = \"Fetch data\" }\n);\n\n// Send simple text\nvar response = await XiansContext.A2A.SendTextAsync(\"WebWorkflow\", \"Hello\");\n\n// Send data\nvar response = await XiansContext.A2A.SendDataToBuiltInAsync(\"DataWorkflow\", \n    new A2AMessage { Data = myData });\n</code></pre></p>"},{"location":"concepts/context/#registry-access","title":"Registry Access","text":""},{"location":"concepts/context/#agent-registry","title":"Agent Registry","text":"C#<pre><code>// Get agent (throws if not found)\nvar agent = XiansContext.GetAgent(\"MyAgent\");\n\n// Try get agent (returns bool)\nif (XiansContext.TryGetAgent(\"MyAgent\", out var agent))\n{\n    // Use agent\n}\n\n// Get all agents\nvar allAgents = XiansContext.GetAllAgents();\n</code></pre>"},{"location":"concepts/context/#workflow-registry","title":"Workflow Registry","text":"C#<pre><code>// Get workflow by type (throws if not found)\nvar workflow = XiansContext.GetWorkflow(\"MyAgent:CustomWorkflow\");\n\n// Get built-in workflow (auto-constructs type from current agent)\nvar webWorkflow = XiansContext.GetBuiltInWorkflow(\"WebWorkflow\");\n\n// Try methods (return bool)\nif (XiansContext.TryGetWorkflow(\"MyAgent:CustomWorkflow\", out var wf)) { }\nif (XiansContext.TryGetBuiltInWorkflow(\"WebWorkflow\", out var wf)) { }\n\n// Get all workflows\nvar allWorkflows = XiansContext.GetAllWorkflows();\n</code></pre>"},{"location":"concepts/context/#workflow-identity-construction","title":"Workflow Identity Construction","text":"<p>Build workflow identifiers: C#<pre><code>// Build workflow type: \"MyAgent:WebWorkflow\"\nvar workflowType = XiansContext.BuildBuiltInWorkflowType(\"MyAgent\", \"WebWorkflow\");\n\n// Build workflow ID: \"tenant123:MyAgent:WebWorkflow\"\nvar workflowId = XiansContext.BuildBuiltInWorkflowId(\"MyAgent\", \"WebWorkflow\");\n\n// Get workflow type from class\nvar workflowType = XiansContext.GetWorkflowTypeFor(typeof(MyCustomWorkflow));\n</code></pre></p>"},{"location":"concepts/context/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/context/#pattern-1-safe-context-check","title":"Pattern 1: Safe Context Check","text":"C#<pre><code>public void LogState()\n{\n    if (XiansContext.InWorkflowOrActivity)\n    {\n        _logger.LogInfo(\"Workflow: {0}\", XiansContext.WorkflowId);\n    }\n    else\n    {\n        _logger.LogInfo(\"Outside Temporal context\");\n    }\n}\n</code></pre>"},{"location":"concepts/context/#pattern-2-access-current-resources","title":"Pattern 2: Access Current Resources","text":"C#<pre><code>// Agent-scoped operations\nvar config = await XiansContext.CurrentAgent.Knowledge.GetAsync(\"config\");\n\n// Workflow-scoped operations\nvar schedule = await XiansContext.CurrentWorkflow.Schedules.GetAsync(\"daily-task\");\n</code></pre>"},{"location":"concepts/context/#pattern-3-optional-resource-access","title":"Pattern 3: Optional Resource Access","text":"C#<pre><code>if (XiansContext.TryGetAgent(\"OptionalAgent\", out var agent))\n{\n    // Agent exists\n}\nelse\n{\n    // Handle missing agent\n}\n</code></pre>"},{"location":"concepts/context/#pattern-4-workflow-management","title":"Pattern 4: Workflow Management","text":"C#<pre><code>// Start and signal pattern\nawait XiansContext.Workflows.StartAsync&lt;MyWorkflow&gt;(args);\nvar handle = await XiansContext.Workflows.GetWorkflowHandleAsync&lt;MyWorkflow&gt;(idPostfix);\nawait handle.SignalAsync(wf =&gt; wf.Process, data);\n</code></pre>"},{"location":"concepts/context/#pattern-5-a2a-communication","title":"Pattern 5: A2A Communication","text":"C#<pre><code>// Send to sub-workflow and wait for response\nvar response = await XiansContext.A2A.SendChatToBuiltInAsync(\n    \"WebWorkflow\",\n    new A2AMessage { Text = \"Fetch data from example.com\" }\n);\n</code></pre>"},{"location":"concepts/context/#api-reference","title":"API Reference","text":""},{"location":"concepts/context/#context-properties_1","title":"Context Properties","text":"Property Type Throws Description <code>WorkflowId</code> <code>string</code> Yes Current workflow ID <code>TenantId</code> <code>string</code> Yes Current tenant ID <code>InWorkflow</code> <code>bool</code> No In workflow context? <code>InActivity</code> <code>bool</code> No In activity context? <code>InWorkflowOrActivity</code> <code>bool</code> No In either context? <code>SafeWorkflowId</code> <code>string?</code> No Safe workflow ID <code>SafeWorkflowRunId</code> <code>string?</code> No Safe run ID <code>SafeWorkflowType</code> <code>string?</code> No Safe workflow type <code>SafeAgentName</code> <code>string?</code> No Safe agent name <code>CurrentAgent</code> <code>XiansAgent</code> Yes Current agent instance <code>CurrentWorkflow</code> <code>XiansWorkflow</code> Yes Current workflow instance <code>Workflows</code> <code>WorkflowHelper</code> No Workflow operations <code>Messaging</code> <code>MessagingHelper</code> No Messaging operations <code>A2A</code> <code>A2AContextOperations</code> No A2A operations"},{"location":"concepts/context/#context-methods_1","title":"Context Methods","text":"Method Returns Throws Description <code>GetParticipantId()</code> <code>string</code> Yes Get user ID from context <code>GetIdPostfix()</code> <code>string</code> Yes Get ID postfix <code>GetTaskQueue()</code> <code>string</code> Yes Get current task queue"},{"location":"concepts/context/#agent-registry-methods","title":"Agent Registry Methods","text":"Method Returns Throws Description <code>GetAgent(name)</code> <code>XiansAgent</code> Yes Get agent by name <code>TryGetAgent(name, out agent)</code> <code>bool</code> No Try get agent <code>GetAllAgents()</code> <code>IEnumerable&lt;XiansAgent&gt;</code> No Get all agents"},{"location":"concepts/context/#workflow-registry-methods","title":"Workflow Registry Methods","text":"Method Returns Throws Description <code>GetWorkflow(type)</code> <code>XiansWorkflow</code> Yes Get workflow by type <code>GetBuiltInWorkflow(name)</code> <code>XiansWorkflow</code> Yes Get built-in workflow <code>TryGetWorkflow(type, out wf)</code> <code>bool</code> No Try get workflow <code>TryGetBuiltInWorkflow(name, out wf)</code> <code>bool</code> No Try get built-in workflow <code>GetAllWorkflows()</code> <code>IEnumerable&lt;XiansWorkflow&gt;</code> No Get all workflows"},{"location":"concepts/context/#identity-construction-methods","title":"Identity Construction Methods","text":"Method Returns Description <code>BuildBuiltInWorkflowType(agent, name)</code> <code>string</code> Build workflow type identifier <code>BuildBuiltInWorkflowId(agent, name)</code> <code>string</code> Build workflow ID with tenant <code>GetWorkflowTypeFor(type)</code> <code>string</code> Get workflow type from class"},{"location":"concepts/context/#error-handling","title":"Error Handling","text":"<p>Most methods throw <code>InvalidOperationException</code> when called outside Temporal context:</p> C#<pre><code>// Will throw if not in context\nvar workflowId = XiansContext.WorkflowId;\n\n// Safe alternative\nvar workflowId = XiansContext.SafeWorkflowId;\nif (workflowId != null)\n{\n    // In Temporal context\n}\n\n// Or check first\nif (XiansContext.InWorkflowOrActivity)\n{\n    var workflowId = XiansContext.WorkflowId;\n}\n</code></pre>"},{"location":"concepts/context/#see-also","title":"See Also","text":"<ul> <li>Agent Operations</li> <li>Workflow Operations</li> <li>A2A Communication</li> <li>Knowledge Management</li> <li>Document Management</li> </ul>"},{"location":"concepts/document-db/","title":"Document DB","text":""},{"location":"concepts/document-db/#flexible-data-storage-for-ai","title":"Flexible Data Storage for AI","text":"<p>Your agents need to remember things. Customer profiles, order history, session data, analytics - structured information that doesn't fit neatly into prompts. Document DB gives your agents a schema-less, queryable memory that scales.</p>"},{"location":"concepts/document-db/#the-data-storage-problem","title":"The Data Storage Problem","text":"<p>Traditional Databases:</p> <ul> <li>Define rigid schema \u2192 Hope you got it right</li> <li>Need a new field? \u2192 Migration script, downtime, anxiety</li> </ul> <p>Document DB:</p> <ul> <li>Store JSON documents \u2192 No schema needed</li> <li>New field? \u2192 Just add it</li> <li>Query flexibly \u2192 Find exactly what you need</li> </ul>"},{"location":"concepts/document-db/#understanding-type-and-key","title":"Understanding Type and Key","text":"<p>The foundation of Document DB is built on two critical fields:</p>"},{"location":"concepts/document-db/#type-your-document-categories","title":"Type: Your Document Categories","text":"<p><code>Type</code> is how you organize documents into logical groups. Think of it as your document's category:</p> C#<pre><code>Type = \"user-profile\"     // Customer data\nType = \"session\"          // Active sessions\nType = \"order\"            // Purchase history\nType = \"preferences\"      // User settings\nType = \"analytics-event\"  // Event logs\n</code></pre> <p>Why it matters:</p> <ul> <li>Query all documents of a specific type</li> <li>Organize your data semantically</li> <li>Create natural data partitions per use case</li> </ul>"},{"location":"concepts/document-db/#key-your-semantic-identifier","title":"Key: Your Semantic Identifier","text":"<p><code>Key</code> is a human-readable, business-meaningful identifier. Instead of random UUIDs, use keys that make sense:</p> C#<pre><code>Key = \"user-12345\"           // User ID from your system\nKey = \"session-abc-def\"      // Session identifier\nKey = \"order-2024-001\"       // Order number\nKey = \"config-email-smtp\"    // Configuration name\n</code></pre> <p>Why it matters:</p> <ul> <li>Instantly know what the document is</li> <li>Debug easily in logs and dashboards</li> <li>Retrieve without remembering random IDs</li> </ul>"},{"location":"concepts/document-db/#type--key-powerful-lookup","title":"Type + Key: Powerful Lookup","text":"<p>The real magic happens when you combine them:</p> C#<pre><code>// Save with Type + Key as unique identifier (default behavior)\nvar doc = new Document\n{\n    Type = \"user-preferences\",\n    Key = \"user-12345\",\n    Content = JsonSerializer.SerializeToElement(prefs)\n};\n\n// Type+Key becomes the unique identifier by default\n// Updates existing documents by default\nawait agent.Documents.SaveAsync(doc);\n\n// Retrieve directly with Type + Key\nvar userPrefs = await agent.Documents.GetByKeyAsync(\"user-preferences\", \"user-12345\");\n</code></pre> <p>The Pattern: Text Only<pre><code>Type = \"What kind of data?\"\nKey = \"Which specific instance?\"\nType + Key = \"Exactly this document\"\n</code></pre></p> <p>Each agent can have multiple document types, and each type can have many documents with unique keys. This creates a powerful, self-documenting data organization system.</p>"},{"location":"concepts/document-db/#core-operations","title":"Core Operations","text":"<p>Every agent gets its own document collection with automatic multi-level scoping:</p> <ul> <li>Agent isolation - Documents are automatically tagged with agent name</li> <li>Context-based scoping - When in workflows, documents get additional ActivationName and ParticipantId scoping  </li> <li>Tenant isolation - All operations include tenant-level security</li> </ul> <p>No manual scoping or filtering required - it's all automatic.</p>"},{"location":"concepts/document-db/#default-behaviors","title":"Default Behaviors","text":"<p>Document DB now comes with sensible defaults:</p> <ul> <li>Type + Key Identifier: <code>UseKeyAsIdentifier = true</code> by default - documents are uniquely identified by their Type+Key combination</li> <li>Overwrite Mode: <code>Overwrite = true</code> by default - saving a document with the same Type+Key updates the existing one</li> <li>No Expiration: <code>TtlMinutes = null</code> by default - documents persist indefinitely unless TTL is explicitly set</li> </ul> <p>You can override any of these defaults by explicitly setting <code>DocumentOptions</code>.</p>"},{"location":"concepts/document-db/#save--retrieve","title":"Save &amp; Retrieve","text":"C#<pre><code>// Save any JSON-serializable data\nvar profile = new Document\n{\n    Type = \"user-profile\",\n    Content = JsonSerializer.SerializeToElement(new\n    {\n        Name = \"Alice\",\n        Plan = \"premium\",\n        Credits = 1000\n    })\n};\n\nvar saved = await agent.Documents.SaveAsync(profile);\n\n// Get it back\nvar retrieved = await agent.Documents.GetAsync(saved.Id);\n</code></pre>"},{"location":"concepts/document-db/#working-with-type--key","title":"Working with Type + Key","text":"<p>Practical examples of the Type+Key pattern:</p> C#<pre><code>// User preferences: One document per user\nawait agent.Documents.SaveAsync(new Document\n{\n    Type = \"user-preferences\",\n    Key = $\"user-{userId}\",\n    Content = JsonSerializer.SerializeToElement(preferences)\n});\n// Type+Key identifier and overwrite behavior are now default\n\n// Configuration: Named settings\nawait agent.Documents.SaveAsync(new Document\n{\n    Type = \"config\",\n    Key = \"email-templates\",\n    Content = JsonSerializer.SerializeToElement(templates)\n});\n\n// Retrieve by Type + Key - no GUID needed!\nvar userPrefs = await agent.Documents.GetByKeyAsync(\"user-preferences\", $\"user-{userId}\");\nvar emailConfig = await agent.Documents.GetByKeyAsync(\"config\", \"email-templates\");\n</code></pre>"},{"location":"concepts/document-db/#query--filter","title":"Query &amp; Filter","text":"<p>Find exactly what you need with automatic scoping:</p> C#<pre><code>// Query by type - automatically scoped to current agent and context\nvar activeUsers = await agent.Documents.QueryAsync(new DocumentQuery\n{\n    Type = \"user-profile\",\n    MetadataFilters = new Dictionary&lt;string, object&gt;\n    {\n        [\"status\"] = \"active\",\n        [\"plan\"] = \"premium\"\n    },\n    Limit = 50\n});\n// AgentId, ActivationName, and ParticipantId are automatically added to the query\n</code></pre> <p>Automatic Query Scoping: - <code>AgentId</code> is always added to limit results to your agent's documents - When in workflow context, <code>ActivationName</code> and <code>ParticipantId</code> are automatically added for context-specific filtering - You can override these by explicitly setting them in your query if needed</p>"},{"location":"concepts/document-db/#update--delete","title":"Update &amp; Delete","text":"C#<pre><code>// Update\nprofile.Content = JsonSerializer.SerializeToElement(new { Credits = 500 });\nawait agent.Documents.UpdateAsync(profile);\n\n// Delete one\nawait agent.Documents.DeleteAsync(profileId);\n\n// Delete many\nawait agent.Documents.DeleteManyAsync(new[] { id1, id2, id3 });\n\n// Check existence\nbool exists = await agent.Documents.ExistsAsync(profileId);\n</code></pre>"},{"location":"concepts/document-db/#advanced-features","title":"Advanced Features","text":""},{"location":"concepts/document-db/#time-to-live-ttl","title":"Time-to-Live (TTL)","text":"<p>Default Behavior: Documents persist indefinitely by default.</p> <p>Optional TTL: Set expiration when needed for temporary data:</p> C#<pre><code>var session = new Document\n{\n    Type = \"session\",\n    Content = JsonSerializer.SerializeToElement(new { Token = \"abc123\" })\n};\n\nawait agent.Documents.SaveAsync(session, new DocumentOptions\n{\n    TtlMinutes = 60  // Expires in 1 hour\n});\n\n// Most documents persist indefinitely (default behavior)\nawait agent.Documents.SaveAsync(configDoc);\n// No expiration - document persists until manually deleted\n</code></pre>"},{"location":"concepts/document-db/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Every document is automatically enriched with metadata for scoping and tracking:</p> <p>Always Populated:</p> <ul> <li><code>AgentId</code> - The agent name that owns this document</li> <li><code>CreatedAt</code>, <code>UpdatedAt</code> - Automatic timestamps</li> <li><code>ExpiresAt</code> - Only set when TTL is explicitly specified</li> </ul> <p>Populated When in Workflow/Activity Context:</p> <ul> <li><code>WorkflowId</code> - The specific workflow instance that created it</li> <li><code>ActivationName</code> - The workflow type postfix for context-based scoping</li> <li><code>ParticipantId</code> - The participant/user context for user-specific isolation</li> <li><code>CreatedBy</code>, <code>UpdatedBy</code> - User information from workflow context</li> </ul> <p>This automatic enrichment enables powerful scoping and auditing without any manual work.</p>"},{"location":"concepts/document-db/#multi-level-document-scoping","title":"Multi-Level Document Scoping","text":"<p>Documents are automatically scoped at multiple levels for complete isolation:</p> <p>1. Agent-Level Scoping Every document is automatically tagged with the agent's name (<code>AgentId</code>). Agents cannot access other agents' documents:</p> C#<pre><code>// Agent \"OrderProcessor\" saves a document\nvar doc = await orderAgent.Documents.SaveAsync(myDoc);\n\n// Agent \"UserManager\" tries to access it\nvar result = await userAgent.Documents.GetAsync(doc.Id);\n// Returns null - different agent, access denied\n</code></pre> <p>2. Context-Based Scoping (When in Workflows) When documents are created within workflow/activity contexts, they get additional scoping:</p> <ul> <li><code>ActivationName</code> - The workflow type postfix for fine-grained isolation</li> <li><code>ParticipantId</code> - The specific participant/user context  </li> <li><code>WorkflowId</code> - Links to the specific workflow instance</li> </ul> C#<pre><code>// Documents saved in workflow context are automatically scoped\n// to the current ActivationName and ParticipantId\nvar sessionDoc = await agent.Documents.SaveAsync(new Document\n{\n    Type = \"session\",\n    Key = \"current-state\",\n    Content = JsonSerializer.SerializeToElement(sessionData)\n});\n// Automatically populated: AgentId, ActivationName, ParticipantId, WorkflowId\n</code></pre> <p>3. Tenant-Level Isolation All document operations include tenant isolation via headers, ensuring multi-tenant security.</p> <p>This multi-level scoping ensures documents are isolated not just by agent, but also by workflow context and participant, providing granular access control.</p>"},{"location":"concepts/document-db/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/document-db/#document-organization-by-type","title":"Document Organization by Type","text":"<p>Here's how an e-commerce agent might organize its documents:</p> Text Only<pre><code>Agent: \"OrderProcessingAgent\"\n\u251c\u2500\u2500 Type: \"user-profile\"\n\u2502   \u251c\u2500\u2500 Key: \"user-001\" \u2192 { name, email, plan }\n\u2502   \u251c\u2500\u2500 Key: \"user-002\" \u2192 { name, email, plan }\n\u2502   \u2514\u2500\u2500 Key: \"user-003\" \u2192 { name, email, plan }\n\u2502\n\u251c\u2500\u2500 Type: \"order\"\n\u2502   \u251c\u2500\u2500 Key: \"order-2024-001\" \u2192 { items, total, status }\n\u2502   \u251c\u2500\u2500 Key: \"order-2024-002\" \u2192 { items, total, status }\n\u2502   \u2514\u2500\u2500 Key: \"order-2024-003\" \u2192 { items, total, status }\n\u2502\n\u251c\u2500\u2500 Type: \"session\"\n\u2502   \u251c\u2500\u2500 Key: \"session-abc\" \u2192 { userId, cart, expires }\n\u2502   \u2514\u2500\u2500 Key: \"session-xyz\" \u2192 { userId, cart, expires }\n\u2502\n\u2514\u2500\u2500 Type: \"config\"\n    \u251c\u2500\u2500 Key: \"payment-gateway\" \u2192 { apiKey, endpoint }\n    \u2514\u2500\u2500 Key: \"shipping-rates\" \u2192 { zones, rates }\n</code></pre> <p>Query examples: C#<pre><code>// Get all orders\nvar orders = await agent.Documents.QueryAsync(new DocumentQuery { Type = \"order\" });\n\n// Get specific user profile\nvar profile = await agent.Documents.GetByKeyAsync(\"user-profile\", \"user-001\");\n\n// Get configuration\nvar paymentConfig = await agent.Documents.GetByKeyAsync(\"config\", \"payment-gateway\");\n</code></pre></p>"},{"location":"concepts/document-db/#user-preferences-store","title":"User Preferences Store","text":"C#<pre><code>public async Task SaveUserPreferences(string userId, object prefs)\n{\n    var doc = new Document\n    {\n        Type = \"user-preferences\",\n        Key = userId,\n        Content = JsonSerializer.SerializeToElement(prefs)\n    };\n\n    // UseKeyAsIdentifier and Overwrite are true by default\n    await agent.Documents.SaveAsync(doc);\n}\n</code></pre>"},{"location":"concepts/document-db/#session-cache","title":"Session Cache","text":"C#<pre><code>var session = new Document\n{\n    Type = \"session\",\n    Key = sessionId,\n    Content = JsonSerializer.SerializeToElement(sessionData)\n};\n\nawait agent.Documents.SaveAsync(session, new DocumentOptions\n{\n    TtlMinutes = 30  // Optional: Auto-cleanup after 30 minutes\n});\n// UseKeyAsIdentifier and Overwrite are true by default\n</code></pre>"},{"location":"concepts/document-db/#event-log","title":"Event Log","text":"C#<pre><code>var event = new Document\n{\n    Type = \"analytics-event\",\n    Content = JsonSerializer.SerializeToElement(new\n    {\n        Event = \"purchase\",\n        UserId = userId,\n        Amount = 99.99,\n        Timestamp = DateTime.UtcNow\n    }),\n    Metadata = new Dictionary&lt;string, object&gt;\n    {\n        [\"category\"] = \"revenue\",\n        [\"priority\"] = \"high\"\n    }\n};\n\nawait agent.Documents.SaveAsync(event);\n</code></pre> <p>Golden Rule: If you can describe your data as \"I need the <code>{Type}</code> for <code>{Key}</code>\", you're doing it right.</p> <p>Examples:</p> <ul> <li>\"I need the user-profile for user-12345\"</li> <li>\"I need the session for session-abc-123\"  </li> <li>\"I need the config for email-smtp\"</li> </ul>"},{"location":"concepts/document-db/#what-you-get","title":"What You Get","text":"<ul> <li>Schema-less - Store any JSON structure  </li> <li>Multi-level scoping - Automatic agent, context, and tenant isolation  </li> <li>Agent isolation - Documents private per agent with automatic AgentId tagging  </li> <li>Context-aware - Workflow-based ActivationName and ParticipantId scoping  </li> <li>Type-based categorization - Organize by document type  </li> <li>Semantic keys - Human-readable identifiers (enabled by default)  </li> <li>Type + Key lookup - Direct retrieval without GUIDs (default behavior)  </li> <li>Update-friendly - Overwrites existing documents by default  </li> <li>Persistent by default - Documents last indefinitely unless TTL is set  </li> <li>Optional TTL - Auto-expire temporary data when needed  </li> <li>Auto-scoped queries - Queries automatically limited to your scope  </li> <li>Queryable - Filter by type, metadata, keys  </li> <li>Scalable - Handles small configs to large datasets  </li> <li>Type-safe - Full C# typing with <code>JsonSerializer</code></li> </ul>"},{"location":"concepts/document-db/#what-its-not","title":"What It's NOT","text":"<ul> <li>Not a relational database (no joins)  </li> <li>Not for large binary files (use blob storage)  </li> <li>Not for high-frequency writes (use caching layers)</li> </ul> <p>Document DB is your agent's persistent memory. Use it for configuration, state, user data, and anything your agent needs to remember between executions.</p>"},{"location":"concepts/hitl-tasks/","title":"Human-in-the-Loop Tasks","text":"<p>Human-in-the-Loop (HITL) tasks enable workflows to pause and wait for human decisions. Unlike rigid automation, tasks create a collaborative space where humans and agents work together, each contributing their unique strengths.</p>"},{"location":"concepts/hitl-tasks/#overview","title":"Overview","text":"<p>When a workflow needs human input\u2014whether to approve an order, review content, or make a business decision\u2014it creates a task with custom actions that fit your domain:</p> C#<pre><code>Actions = [\"approve\", \"reject\", \"hold\"]           // Order processing\nActions = [\"publish\", \"revise\", \"reject\"]         // Content review  \nActions = [\"ship\", \"refund\", \"escalate\"]          // Customer service\n</code></pre> <p>The human performs one of these actions with an optional comment, and the workflow continues based on their choice. It's that simple.</p>"},{"location":"concepts/hitl-tasks/#enabling-hitl-tasks","title":"Enabling HITL Tasks","text":"<p>Tasks are opt-in. Enable them only for agents that need human collaboration:</p> C#<pre><code>var agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"OrderProcessor\",\n    IsTemplate = false\n});\n\nagent.Workflows.DefineCustom&lt;OrderWorkflow&gt;();\n\n// Enable tasks - creates OrderProcessor:Task Workflow\nawait agent.Workflows.WithTasks();\n\nawait agent.RunAllAsync();\n</code></pre> <p>Key Points:</p> <ul> <li>Each agent gets its own task workflow: <code>{AgentName}:Task Workflow</code></li> <li>Optional <code>maxConcurrent</code> parameter (defaults to 100)</li> <li>Omit <code>WithTasks()</code> if your agent doesn't need human input</li> </ul>"},{"location":"concepts/hitl-tasks/#creating-tasks-in-workflows","title":"Creating Tasks in Workflows","text":"<p>Create tasks with domain-specific actions:</p> C#<pre><code>var taskHandle = await XiansContext.CurrentAgent.Tasks.StartTaskAsync(\n    new TaskWorkflowRequest\n    {\n        TaskId = $\"order-{orderId}\",\n        Title = \"Review High-Value Order\",\n        Description = $\"Order for ${amount} requires approval\",\n        ParticipantId = reviewerUserId, // optional, this is usually inherited from the parent workflow\n        DraftWork = orderDetails,\n        Actions = [\"approve\", \"reject\", \"request-info\"],  // Custom actions\n        Timeout = TimeSpan.FromHours(24)  // Optional: auto-timeout after 24 hours\n    }\n);\n\n// Later, wait for the result\nvar result = await XiansContext.CurrentAgent.Tasks.GetResultAsync(taskHandle);\n\n// Check if task timed out\nif (result.TimedOut)\n{\n    await HandleTimeout(result.TaskId);\n    return;\n}\n\n// Handle based on the action performed\nswitch (result.PerformedAction)\n{\n    case \"approve\":\n        await ProcessOrder(result.FinalWork);\n        break;\n    case \"reject\":\n        await CancelOrder(result.Comment);\n        break;\n    case \"request-info\":\n        await RequestMoreInfo(result.Comment);\n        break;\n}\n</code></pre> <p>Durable Waiting with Temporal</p> <p><code>GetResultAsync()</code> uses Temporal's durable execution\u2014your workflow can wait days, weeks, or months without tying up resources. It survives restarts and guarantees the workflow resumes exactly where it left off when the human responds.</p> <p>Available Methods:</p> Method Purpose <code>CreateAndWaitAsync()</code> Create task and block until completion <code>StartTaskAsync()</code> Create task, return handle immediately <code>GetResultAsync()</code> Wait for task completion using handle <code>CreateAsync()</code> Fire-and-forget (no result needed)"},{"location":"concepts/hitl-tasks/#task-timeouts","title":"Task Timeouts","text":"<p>Tasks can specify an optional timeout to automatically complete after a given duration:</p> C#<pre><code>var taskHandle = await XiansContext.CurrentAgent.Tasks.StartTaskAsync(\n    new TaskWorkflowRequest\n    {\n        Title = \"Review Content\",\n        Description = \"Please review before publishing\",\n        Actions = [\"publish\", \"reject\", \"revise\"],\n        Timeout = TimeSpan.FromHours(48)  // Auto-complete after 48 hours\n    }\n);\n\nvar result = await XiansContext.CurrentAgent.Tasks.GetResultAsync(taskHandle);\n\n// Check if task timed out\nif (result.TimedOut)\n{\n    // Handle timeout case - PerformedAction and Comment will be null\n    _logger.LogWarning(\"Task {TaskId} timed out without human action\", result.TaskId);\n    await HandleTimeoutLogic();\n}\nelse if (result.Completed)\n{\n    // Normal completion - human performed an action\n    await ProcessAction(result.PerformedAction, result.Comment);\n}\n</code></pre> <p>Timeout Behavior:</p> <ul> <li>When a timeout occurs, the task completes with <code>TimedOut = true</code></li> <li><code>PerformedAction</code> and <code>Comment</code> will be <code>null</code> for timed-out tasks</li> <li><code>Completed</code> will be <code>false</code> (only <code>true</code> when a human performed an action)</li> <li>The workflow can distinguish between timeouts and explicit human actions</li> <li>If no timeout is specified, the task waits indefinitely</li> </ul> <p>Use Cases:</p> <ul> <li>SLA Enforcement: Auto-escalate support tickets after 24 hours</li> <li>Default Actions: Auto-approve low-risk changes after review period</li> <li>Workflow Progression: Prevent workflows from waiting forever</li> <li>Business Logic: Implement time-based decision rules</li> </ul> C#<pre><code>// Example: Auto-approve after 72 hours if not reviewed\nvar result = await XiansContext.CurrentAgent.Tasks.GetResultAsync(taskHandle);\n\nif (result.TimedOut)\n{\n    // Auto-approve on timeout\n    await ApproveOrder(\"Auto-approved after 72-hour review period\");\n}\nelse if (result.PerformedAction == \"reject\")\n{\n    await RejectOrder(result.Comment);\n}\nelse\n{\n    await ApproveOrder(result.Comment);\n}\n</code></pre>"},{"location":"concepts/hitl-tasks/#linking-tasks-to-conversations","title":"Linking Tasks to Conversations","text":"<p>Connect tasks to conversations using message hints:</p> C#<pre><code>// Send message with task workflow ID as hint\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    \"MyAgent:Conversational\",\n    userId,\n    \"I found a high-value order. Please review it.\",\n    scope: orderId,\n    hint: taskHandle.Id  // Links task to this conversation\n);\n</code></pre> <p>The hint makes the task available to conversational agents, enabling natural task management through chat.</p>"},{"location":"concepts/hitl-tasks/#interacting-with-tasks-via-agents","title":"Interacting with Tasks via Agents","text":"<p>Conversational agents retrieve and manage tasks using <code>HitlTask</code>:</p> C#<pre><code>// In an agent tool\nvar taskWorkflowId = await context.GetLastHintAsync();\nvar task = await HitlTask.FromWorkflowIdAsync(taskWorkflowId);\n\n// Check available actions\nvar info = await task.GetInfoAsync();\nConsole.WriteLine($\"Available: {string.Join(\", \", info.AvailableActions)}\");\n\n// Perform an action with a comment\nawait task.PerformActionAsync(\"approve\", \"Verified by support team\");\n\n// Or use convenience methods\nawait task.ApproveAsync(\"Looks good!\");\nawait task.RejectAsync(\"Missing required documentation\");\n</code></pre> <p>HitlTask Methods:</p> Method Description <code>GetInfoAsync()</code> Get task details, available actions, status <code>PerformActionAsync(action, comment)</code> Perform any available action <code>ApproveAsync(comment)</code> Shortcut for \"approve\" action <code>RejectAsync(comment)</code> Shortcut for \"reject\" action <code>UpdateDraftAsync(draft)</code> Update work in progress <code>GetDraftAsync()</code> Get current draft <code>GetAvailableActionsAsync()</code> Get actions for this task"},{"location":"concepts/hitl-tasks/#complete-example-order-processing","title":"Complete Example: Order Processing","text":"<p>Here's how it all comes together:</p> C#<pre><code>[Workflow(\"OrderProcessor:Order Workflow\")]\npublic class OrderWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;OrderResult&gt; RunAsync(string customerId, decimal amount)\n    {\n        // Auto-approve small orders\n        if (amount &lt;= 100)\n        {\n            return new OrderResult { Status = \"Auto-Approved\", Amount = amount };\n        }\n\n        // High-value orders need human review\n        var taskHandle = await XiansContext.CurrentAgent.Tasks.StartTaskAsync(\n            new TaskWorkflowRequest\n            {\n                Title = \"Review Order\",\n                Description = $\"Customer {customerId} - ${amount}\",\n                Actions = [\"approve\", \"reject\", \"hold\", \"escalate\"],\n                Timeout = TimeSpan.FromHours(48)  // Auto-timeout after 48 hours\n            }\n        );\n\n        var result = await taskHandle.GetResultAsync(taskHandle);\n\n        // Handle timeout case\n        if (result.TimedOut)\n        {\n            return new OrderResult { Status = \"Escalated-Timeout\", Amount = amount };\n        }\n\n        return result.PerformedAction switch\n        {\n            \"approve\" =&gt; ProcessApprovedOrder(result.Comment),\n            \"reject\" =&gt; CancelOrder(result.Comment),\n            \"hold\" =&gt; PutOnHold(result.Comment),\n            \"escalate\" =&gt; EscalateToManager(result.Comment),\n            _ =&gt; throw new InvalidOperationException($\"Unknown action: {result.PerformedAction}\")\n        };\n    }\n}\n</code></pre> <p>TaskWorkflowResult Properties:</p> Property Type Description <code>TaskId</code> <code>string</code> The unique identifier for the task <code>InitialWork</code> <code>string?</code> The original draft when the task was created <code>FinalWork</code> <code>string?</code> The final draft when the task completed (may have been updated) <code>PerformedAction</code> <code>string?</code> The action that was performed (e.g., \"approve\", \"reject\"). <code>null</code> if timed out <code>Comment</code> <code>string?</code> Optional comment provided with the action. <code>null</code> if timed out <code>CompletedAt</code> <code>DateTime</code> When the task was completed (either by action or timeout) <code>TimedOut</code> <code>bool</code> <code>true</code> if the task timed out, <code>false</code> if completed by human action <code>Completed</code> <code>bool</code> <code>true</code> if a human performed an action, <code>false</code> if timed out <p>You can compare <code>InitialWork</code> and <code>FinalWork</code> to see if the draft was modified during the task lifecycle. Use <code>TimedOut</code> to distinguish between timeout and explicit human completion.</p>"},{"location":"concepts/hitl-tasks/#agent-tools-for-task-management","title":"Agent Tools for Task Management","text":"<p>Expose tasks through AI function tools:</p> C#<pre><code>[Description(\"Get information about the current task including available actions\")]\npublic async Task&lt;string&gt; GetTaskInfo()\n{\n    var taskId = await _context.GetLastHintAsync();\n    var task = await HitlTask.FromWorkflowIdAsync(taskId);\n    var info = await task.GetInfoAsync();\n\n    var actions = string.Join(\", \", info.AvailableActions ?? []);\n    var status = info.IsCompleted \n        ? $\"Completed ({info.PerformedAction})\" \n        : \"Pending\";\n\n    return $\"Task: {info.Title}\\n\" +\n           $\"Status: {status}\\n\" +\n           $\"Available Actions: {actions}\\n\" +\n           $\"Draft: {info.CurrentDraft ?? \"None\"}\";\n}\n\n[Description(\"Perform an action on the current task\")]\npublic async Task&lt;string&gt; PerformAction(\n    [Description(\"The action to perform (e.g., approve, reject)\")] string action,\n    [Description(\"Optional comment for the action\")] string? comment = null)\n{\n    var taskId = await _context.GetLastHintAsync();\n    var task = await HitlTask.FromWorkflowIdAsync(taskId);\n\n    await task.PerformActionAsync(action, comment);\n\n    return $\"Task action '{action}' performed successfully.\";\n}\n</code></pre> <p>The AI agent can now naturally guide humans through task decisions in conversation.</p>"},{"location":"concepts/hitl-tasks/#the-hint-pattern","title":"The Hint Pattern","text":"<p>The hint pattern connects long-running workflows with conversational agents:</p> <ol> <li>Workflow creates a task \u2192 sends message with task ID as hint</li> <li>Hint scopes the task to the conversation context</li> <li>Agent retrieves hint \u2192 reconstructs <code>HitlTask</code> from workflow ID</li> <li>Human decides through natural conversation</li> <li>Agent performs action via tools</li> <li>Workflow resumes instantly</li> </ol> <p>This creates seamless human-agent collaboration without exposing workflow complexity to users.</p>"},{"location":"concepts/hitl-tasks/#direct-task-operations","title":"Direct Task Operations","text":"<p>Manage tasks outside workflows (e.g., webhooks, admin tools):</p> C#<pre><code>var task = await HitlTask.FromWorkflowIdAsync(workflowId);\n\nvar info = await task.GetInfoAsync();\nawait task.UpdateDraftAsync(updatedContent);\nawait task.PerformActionAsync(\"approve\", \"Verified externally\");\n</code></pre>"},{"location":"concepts/hitl-tasks/#default-actions","title":"Default Actions","text":"<p>If you don't specify actions, tasks default to <code>[\"approve\", \"reject\"]</code>. Timeout is optional and tasks wait indefinitely if not specified:</p> C#<pre><code>new TaskWorkflowRequest\n{\n    Title = \"Simple Approval\",\n    // Actions defaults to [\"approve\", \"reject\"]\n    // Timeout is null by default (waits indefinitely)\n}\n</code></pre>"},{"location":"concepts/hitl-tasks/#task-lifecycle-control","title":"Task Lifecycle Control","text":"<p>Tasks can be configured to survive beyond their parent workflow using the <code>SurviveParentClose</code> attribute:</p> C#<pre><code>new TaskWorkflowRequest\n{\n    Title = \"Long-Running Approval\",\n    Description = \"This task will continue even if parent workflow terminates\",\n    Actions = [\"approve\", \"reject\"],\n    SurviveParentClose = true  // Task survives parent termination (defaults to false)\n}\n</code></pre> <p>Behavior:</p> <ul> <li>Default (<code>false</code>): When the parent workflow terminates, the task is automatically abandoned</li> <li>Enabled (<code>true</code>): The task continues to exist and wait for human action even after the parent workflow closes</li> </ul> <p>Use Cases:</p> <ul> <li>Independent Approvals: Tasks that should complete regardless of the requesting workflow's state</li> <li>Audit Trails: Ensure human decisions are recorded even if the initiating process fails</li> <li>Decoupled Processes: When task completion doesn't need to update the parent workflow</li> </ul> <p>Important Consideration</p> <p>When <code>SurviveParentClose = true</code>, the parent workflow cannot retrieve the task result via <code>GetResultAsync()</code> since it may have already terminated. Design your workflow accordingly, such as having the task trigger a separate callback workflow upon completion.</p>"},{"location":"concepts/hitl-tasks/#best-practices","title":"Best Practices","text":"<p>Design</p> <ul> <li>Use domain-specific actions that match your business process</li> <li>Keep action names simple and clear (<code>ship</code>, <code>refund</code>, not <code>initiateShippingProcess</code>)</li> <li>Provide meaningful titles and descriptions</li> <li>Set appropriate timeouts based on SLAs and business requirements</li> </ul> <p>Implementation</p> <ul> <li>Enable tasks only for agents that need human input</li> <li>Always use hints to link tasks to conversations</li> <li>Handle all possible actions in your workflow logic</li> <li>Always check <code>result.TimedOut</code> before processing <code>PerformedAction</code></li> <li>Consider timeout behavior as part of your business logic, not just error handling</li> </ul> <p>User Experience</p> <ul> <li>Pre-populate draft work to give context</li> <li>Use comments to capture rationale for decisions</li> <li>Configure agents to proactively notify users of pending tasks</li> <li>Send reminders before tasks timeout (using scheduled workflows)</li> </ul>"},{"location":"concepts/hitl-tasks/#architecture","title":"Architecture","text":"<p>When you call <code>WithTasks()</code>, Xians creates an agent-specific workflow:</p> Text Only<pre><code>{AgentName}:Task Workflow\n</code></pre> <p>This ensures:</p> <ul> <li>Isolation - Each agent has its own task queue</li> <li>Independent scaling - Task workers scale per agent</li> <li>Multi-tenancy - Tasks are automatically tenant-scoped</li> <li>No conflicts - Multiple agents can use tasks simultaneously</li> </ul> <p>HITL tasks transform rigid automation into flexible collaboration, letting humans and agents each do what they do best.</p>"},{"location":"concepts/knowledge/","title":"Knowledge","text":""},{"location":"concepts/knowledge/#give-your-agents-domain-expertise","title":"Give Your Agents Domain Expertise","text":"<p>LLMs are smart, but they don't know your business. Your products, your policies, your documentation. Knowledge bases solve this through Retrieval-Augmented Generation (RAG)\u2014letting agents search your content and ground their answers in your truth.</p>"},{"location":"concepts/knowledge/#what-is-agent-knowledge","title":"What is Agent Knowledge?","text":"<p>Every agent has its own private knowledge base\u2014a key-value store for information your agent needs to retrieve. Think of it as your agent's memory:</p> <ul> <li>System instructions that customize agent behavior</li> <li>Product catalogs for a sales agent</li> <li>Company policies for a support agent  </li> <li>User preferences for a personalization agent</li> <li>Workflow instructions for complex processes</li> </ul> <p>Knowledge is automatically scoped to each agent. Agent A can't access Agent B's knowledge\u2014perfect for multi-tenant applications.</p>"},{"location":"concepts/knowledge/#retrieving-knowledge","title":"Retrieving Knowledge","text":""},{"location":"concepts/knowledge/#get-specific-knowledge","title":"Get Specific Knowledge","text":"C#<pre><code>var agent = XiansContext.GetAgent(agentName); // or var agent = XiansContext.CurrentAgent;\n\n// Get specific knowledge by name\nvar knowledge = await agent.Knowledge.GetAsync(\"welcome-message\");\n\nif (knowledge != null)\n{\n    Console.WriteLine($\"Content: {knowledge.Content}\");\n    Console.WriteLine($\"Type: {knowledge.Type}\");\n}\n</code></pre> <p>Supported knowledge types:</p> <ul> <li><code>\"text\"</code> - Plain text content</li> <li><code>\"markdown\"</code> - Formatted documentation with Markdown syntax</li> <li><code>\"json\"</code> - Structured data</li> </ul>"},{"location":"concepts/knowledge/#list-all-knowledge","title":"List All Knowledge","text":"C#<pre><code>// See everything your agent knows\nvar allKnowledge = await agent.Knowledge.ListAsync();\n\nforeach (var item in allKnowledge)\n{\n    Console.WriteLine($\"Name: {item.Name}\");\n    Console.WriteLine($\"Type: {item.Type}\");\n    Console.WriteLine($\"Content: {item.Content}\");\n    Console.WriteLine($\"System Scoped: {item.SystemScoped}\");\n    Console.WriteLine();\n}\n</code></pre>"},{"location":"concepts/knowledge/#knowledge-in-workflows","title":"Knowledge in Workflows","text":"<p>Knowledge retrieval works seamlessly inside workflows\u2014the SDK automatically handles context switching:</p> C#<pre><code>[Workflow(\"CustomerSupport:HandleTicket\")]\npublic class TicketWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(string customerId)\n    {\n        // Get agent from workflow context\n        var agent = XiansContext.GetAgent(\"SupportAgent\");\n\n        // Retrieve knowledge - automatically uses progressive fallback\n        // Checks: instance-specific \u2192 tenant-specific \u2192 system default\n        var instructions = await agent.Knowledge.GetAsync(\"system-instructions\");\n\n        // Use the most specific version available\n        return $\"Processing ticket with instructions: {instructions?.Content}\";\n    }\n}\n</code></pre> <p>The SDK uses context-aware execution to route workflow calls through Temporal activities automatically, and the server applies the progressive fallback to find the most specific knowledge for this agent run.</p>"},{"location":"concepts/knowledge/#progressive-knowledge-retrieval","title":"Progressive Knowledge Retrieval","text":"<p>The Xians platform uses a progressive fallback mechanism when retrieving knowledge, allowing you to override defaults at multiple levels:</p>"},{"location":"concepts/knowledge/#fallback-hierarchy","title":"Fallback Hierarchy","text":"<p>When you call <code>GetAsync(\"knowledge-name\")</code>, the server checks for knowledge in this order:</p> <ol> <li>Instance-Scoped (<code>tenant/agent/activation</code>) - Most specific to this agent run</li> <li>Tenant-Scoped (<code>tenant/agent</code>) - Specific to this tenant's agent</li> <li>System-Scoped (<code>system/agent</code>) - Template/default knowledge shared across all tenants</li> </ol> <p>The server returns the first match found, making knowledge progressively more specific.</p>"},{"location":"concepts/knowledge/#how-it-works","title":"How It Works","text":"C#<pre><code>var knowledge = await agent.Knowledge.GetAsync(\"greeting\");\n</code></pre>"},{"location":"concepts/knowledge/#benefits","title":"Benefits","text":"<p>\u2705 Defaults for all - System-scoped knowledge provides baseline behavior \u2705 Tenant customization - Each tenant can override with their branding/rules \u2705 Instance personalization - Individual agent runs can be further customized \u2705 Efficient storage - Only store overrides, not duplicate defaults</p>"},{"location":"concepts/knowledge/#caching","title":"Caching","text":"<p>Knowledge reads are cached for better performance. The cache is invalidated automatically when you update or delete knowledge.</p> <p>Cache duration is configurable via <code>XiansOptions.Cache.Knowledge.TtlMinutes</code>:</p> C#<pre><code>var platform = await XiansPlatform.InitializeAsync(new XiansOptions\n{\n    ApiKey = yourApiKey,\n    Cache = new CacheOptions\n    {\n        Knowledge = new CacheAspectOptions\n        {\n            Enabled = true,\n            TtlMinutes = 10   // Default: 10 minutes\n        }\n    }\n});\n</code></pre>"},{"location":"concepts/knowledge/#agent-isolation","title":"Agent Isolation","text":"<p>Each agent's knowledge is completely isolated:</p> C#<pre><code>// Sales agent retrieves its knowledge\nvar salesPricing = await salesAgent.Knowledge.GetAsync(\"pricing\");\n\n// Support agent cannot see Sales agent's knowledge\nvar leaked = await supportAgent.Knowledge.GetAsync(\"pricing\");\n// Returns null - agents are isolated by tenant and name\n</code></pre> <p>Even if two agents use the same knowledge name, they maintain separate copies. Perfect for multi-tenant SaaS applications.</p>"},{"location":"concepts/knowledge/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"concepts/knowledge/#retrieving-system-instructions","title":"Retrieving System Instructions","text":"C#<pre><code>// In your message handler, retrieve system instructions\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var agent = XiansContext.GetAgent(\"CustomerSupportAgent\");\n    var systemInstructions = await agent.Knowledge.GetAsync(\"system-instructions\");\n\n    // Build your LLM messages with the retrieved instructions\n    var messages = new List&lt;ChatMessage&gt;\n    {\n        new SystemMessage(systemInstructions?.Content ?? \"Default instructions\"),\n        new UserMessage(context.Message.Text)\n    };\n\n    var response = await llm.GetCompletionAsync(messages);\n    await context.ReplyAsync(response);\n});\n</code></pre>"},{"location":"concepts/knowledge/#loading-configuration","title":"Loading Configuration","text":"C#<pre><code>// Retrieve configuration at runtime\nvar config = await agent.Knowledge.GetAsync(\"api-config\");\nif (config != null &amp;&amp; config.Type == \"json\")\n{\n    var settings = JsonSerializer.Deserialize&lt;ApiSettings&gt;(config.Content);\n    // Use settings...\n}\n</code></pre>"},{"location":"concepts/knowledge/#accessing-product-catalogs","title":"Accessing Product Catalogs","text":"C#<pre><code>// Retrieve product information\nvar catalog = await agent.Knowledge.GetAsync(\"product-catalog\");\nif (catalog != null)\n{\n    // Use catalog content in your agent logic\n    Console.WriteLine($\"Product catalog: {catalog.Content}\");\n}\n</code></pre>"},{"location":"concepts/logging/","title":"Logging in Xians","text":""},{"location":"concepts/logging/#overview","title":"Overview","text":"<p>Xians provides a context-aware logging system that automatically captures workflow metadata and routes logs to the console and/or the Xians server. Use the standard ILogger interface from <code>Microsoft.Extensions.Logging</code> for all logging.</p>"},{"location":"concepts/logging/#logging-in-workflows-and-activities","title":"Logging in Workflows and Activities","text":"Context Logger How to Obtain Workflows Temporal's <code>Workflow.Logger</code> Built-in; Xians uploads these logs to the server Activities <code>ILogger</code> via XiansLogger <code>XiansLogger.GetLogger&lt;T&gt;()</code> or <code>XiansLogger.ForILogger(Type)</code>"},{"location":"concepts/logging/#workflow-logging-workflowlogger","title":"Workflow Logging: Workflow.Logger","text":"<p>Workflows run in Temporal's deterministic environment. Use Temporal's built-in <code>Workflow.Logger</code>\u2014Xians captures these logs and uploads them to the Xians server.</p> C#<pre><code>using Temporalio.Exceptions;\nusing Temporalio.Workflows;\n\n[Workflow(Constants.AGENT_NAME + \":News Search Workflow\")]\npublic class NewsSearchWf\n{\n    [WorkflowRun]\n    public async Task&lt;string&gt; SearchNewsAsync()\n    {\n        try\n        {\n            var sources = await Workflow.ExecuteActivityAsync(\n                (NewsSearchActivities a) =&gt; a.FetchGenericNewsSourcesAsync(),\n                new ActivityOptions { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n\n            foreach (var source in sources)\n            {\n                Workflow.Logger.LogDebug($\"Source {source.Name} has companies with stale scans\");\n            }\n            return \"News search completed.\";\n        }\n        catch (Exception ex)\n        {\n            Workflow.Logger.LogError($\"News search workflow failed: {ex.Message}\", ex);\n            throw new ApplicationFailureException($\"News search workflow failed: {ex.Message}\");\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/logging/#activity-logging-ilogger-via-xianslogger","title":"Activity Logging: ILogger via XiansLogger","text":"<p>In activities, obtain an ILogger using <code>XiansLogger.GetLogger&lt;T&gt;()</code> or <code>XiansLogger.ForILogger(Type)</code>:</p> C#<pre><code>using Microsoft.Extensions.Logging;\nusing Temporalio.Activities;\nusing Xians.Lib.Logging;\n\npublic class NewsSearchActivities\n{\n    private readonly IDataContext _data;\n    private static readonly ILogger _logger = XiansLogger.GetLogger&lt;NewsSearchActivities&gt;();\n\n    public NewsSearchActivities(IDataContext data) =&gt; _data = data;\n\n    [Activity]\n    public async Task&lt;IReadOnlyList&lt;NewsSourceItem&gt;&gt; FetchGenericNewsSourcesAsync()\n    {\n        var sources = await _data.NewsSources.GetActiveGenericSourcesAsync();\n        _logger.LogDebug(\"Fetched {Count} generic news sources\", sources.Count);\n        return sources.Select(s =&gt; new NewsSourceItem(s.Id, s.Url, s.Name)).ToList();\n    }\n\n    [Activity]\n    public async Task&lt;int&gt; ValidateAndSaveArticlesAsync(SearchItem item, Guid newsSourceId, Guid peerCompanyId)\n    {\n        if (string.IsNullOrWhiteSpace(item.Link))\n        {\n            _logger.LogWarning(\"Skipping item with no link: {Title}\", item.Title);\n            return 0;\n        }\n        _logger.LogDebug(\"Saved article for {Link}\", item.Link);\n        return 1;\n    }\n}\n</code></pre> <p>Using runtime type:</p> C#<pre><code>private static readonly ILogger _logger = XiansLogger.ForILogger(typeof(NewsSearchActivities));\n</code></pre> <p>All standard <code>ILogger</code> extension methods are available: <code>LogTrace</code>, <code>LogDebug</code>, <code>LogInformation</code>, <code>LogWarning</code>, <code>LogError</code>, <code>LogCritical</code>, plus structured logging with message templates.</p>"},{"location":"concepts/logging/#automatic-context-capture","title":"Automatic Context Capture","text":"<p>Both workflow and activity logs automatically include workflow metadata when uploaded to the server:</p> JSON<pre><code>{\n  \"workflow_id\": \"tenant-abc:Market Analysts:News Search Workflow:user-123\",\n  \"workflow_run_id\": \"def456-789-abc\",\n  \"workflow_type\": \"Market Analysts:News Search Workflow\",\n  \"agent\": \"Market Analysts\",\n  \"participant_id\": \"user-123\",\n  \"level\": \"Information\",\n  \"message\": \"Fetched 4 generic news sources\",\n  \"created_at\": \"2026-01-25T10:30:00Z\"\n}\n</code></pre> <p>You don't need to add this context manually!</p>"},{"location":"concepts/logging/#server-upload-configuration","title":"Server Upload Configuration","text":"<p>Logs from both workflows and activities can be sent to the Xians server. Server upload is disabled by default; you must set <code>ServerLogLevel</code> during platform initialization.</p>"},{"location":"concepts/logging/#console-vs-server-log-levels","title":"Console vs Server Log Levels","text":"<p>Two independent thresholds control where logs go:</p> Configuration Where Logs Go Default ConsoleLogLevel Terminal/console <code>Debug</code> ServerLogLevel Xians server Disabled <p>With <code>ConsoleLogLevel = LogLevel.Debug</code> and <code>ServerLogLevel = LogLevel.Information</code>:</p> <ul> <li>Console shows: Debug, Information, Warning, Error, Critical</li> <li>Server receives: Information, Warning, Error, Critical</li> </ul> Text Only<pre><code>Your Code                Console              Server\n   \u251c\u2500 LogTrace        \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 (Below both)\n   \u251c\u2500 LogDebug        \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Displayed       \u2502     (Console only)\n   \u251c\u2500 LogInformation  \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Displayed   \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Uploaded\n   \u251c\u2500 LogWarning      \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Displayed   \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Uploaded\n   \u251c\u2500 LogError        \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Displayed   \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Uploaded\n   \u2514\u2500 LogCritical     \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Displayed   \u2500\u2500\u2500\u2500\u253c\u2500\u2500&gt; Uploaded\n</code></pre>"},{"location":"concepts/logging/#enable-server-upload","title":"Enable Server Upload","text":"<p>Set <code>ServerLogLevel</code> in code or via environment variables:</p> C#<pre><code>// Program.cs or startup\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new()\n{\n    ServerUrl = config.XiansServerUrl,\n    ApiKey = config.XiansAgentCertificate,\n    ServerLogLevel = LogLevel.Information,  // Enables upload; Information and above sent\n    ConsoleLogLevel = LogLevel.Debug\n});\n</code></pre> <p>Or via environment variables:</p> Bash<pre><code>CONSOLE_LOG_LEVEL=DEBUG\nSERVER_LOG_LEVEL=INFO\n</code></pre> <p>Priority: Code configuration &gt; Environment variables &gt; Defaults</p>"},{"location":"concepts/logging/#log-levels-reference","title":"Log Levels Reference","text":"Level Value Example <code>Trace</code> 0 \"Entering method X with param Y\" <code>Debug</code> 1 \"Fetched 4 generic news sources\" <code>Information</code> 2 \"News search completed\" <code>Warning</code> 3 \"Skipping item with no link\" <code>Error</code> 4 \"Workflow failed: connection timeout\" <code>Critical</code> 5 \"Database connection lost\""},{"location":"concepts/logging/#how-logs-are-uploaded-to-server","title":"How Logs Are Uploaded to Server","text":""},{"location":"concepts/logging/#batch-upload-mechanism","title":"Batch Upload Mechanism","text":"<p>Logs are not uploaded immediately. Instead, they are queued and uploaded in periodic batches:</p> Setting Default Description Batch Size 100 logs Maximum logs per upload batch Upload Interval 60 seconds Time between batch uploads Queue Type In-memory Concurrent queue (thread-safe) Retry Automatic Failed uploads are requeued Shutdown Flush all Pending logs uploaded on exit"},{"location":"concepts/logging/#what-this-means-for-you","title":"What This Means for You","text":"<p>\u23f1\ufe0f Delay: Logs may take up to 60 seconds to appear on the server dashboard.</p> <p>\ud83d\udd04 Reliability:</p> <ul> <li>Failed uploads are automatically retried</li> <li>Logs are flushed on application shutdown</li> <li>Network issues won't cause immediate log loss</li> </ul> <p>\ud83d\udcca Performance:</p> <ul> <li>Minimal impact on application performance</li> <li>Batching reduces server API calls</li> <li>Asynchronous upload doesn't block your code</li> </ul>"},{"location":"concepts/logging/#configuration-advanced","title":"Configuration (Advanced)","text":"<p>You can customize batch settings programmatically:</p> C#<pre><code>using Xians.Lib.Logging;\n\n// Customize batch upload settings (optional)\nLoggingServices.ConfigureBatchSettings(\n    batchSize: 50,              // Smaller batches\n    processingIntervalMs: 30000 // Upload every 30 seconds\n);\n</code></pre> <p>When to customize:</p> <ul> <li>Smaller batches + frequent uploads \u2192 Critical systems needing near real-time logs</li> <li>Larger batches + less frequent \u2192 High-volume systems to reduce API calls</li> </ul>"},{"location":"concepts/logging/#log-retention-on-server","title":"Log Retention on Server","text":""},{"location":"concepts/logging/#default-retention-period","title":"Default Retention Period","text":"<p>Server logs are automatically deleted after 15 days by default due to MongoDB TTL (Time To Live) indexing.</p> <p>Important Considerations:</p> <ol> <li>Logs are temporary - Don't rely on server logs for long-term audit trails</li> <li>Adjust if needed - Contact your server administrator to modify retention</li> <li>Storage costs - Longer retention = more storage required</li> <li>Compliance - Ensure retention meets your regulatory requirements</li> </ol>"},{"location":"concepts/logging/#how-to-change-retention","title":"How to Change Retention","text":"<p>Consult with your server administrator before making changes.</p>"},{"location":"concepts/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/logging/#my-logs-arent-appearing-on-the-server","title":"\"My logs aren't appearing on the server\"","text":"<p>Most common cause: Server logging is disabled by default.</p> <p>Solution: Set <code>ServerLogLevel</code> to enable server upload:</p> C#<pre><code>var xiansPlatform = await XiansPlatform.InitializeAsync(new ()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey,\n    ServerLogLevel = LogLevel.Warning  // \u2705 This enables server logging\n});\n</code></pre>"},{"location":"concepts/logging/#verification","title":"Verification","text":"<p>Confirm server logging is enabled:</p> C#<pre><code>// Log a test message at server threshold level\n_logger.LogWarning(\"Test message - server logging verification\");\n\n// Check logging service status\nvar (queuedCount, retryingCount) = LoggingServices.GetLoggingStats();\nConsole.WriteLine($\"Queued logs: {queuedCount}, Retrying: {retryingCount}\");\n</code></pre> <p>If <code>queuedCount &gt; 0</code>, server logging is working and logs are queued for upload.</p>"},{"location":"concepts/messaging-proactive/","title":"Messaging","text":"<p>Xians provides two distinct mechanisms for communicating with users, each designed for different scenarios:</p>"},{"location":"concepts/messaging-proactive/#two-flavors-of-messaging","title":"Two Flavors of Messaging","text":""},{"location":"concepts/messaging-proactive/#1-replying-to-user-messages","title":"1. Replying to User Messages","text":"<p>When users send messages to your agent via <code>OnUserChatMessage</code> or <code>OnUserDataMessage</code> listeners, you respond using the message context methods:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // User initiated - you're responding\n    await context.ReplyAsync(\"I received your message!\");\n});\n</code></pre> <p>Key characteristics:</p> <ul> <li>User-initiated: Responding to incoming messages</li> <li>Context-aware: Automatic participant ID, thread continuity, scope inheritance</li> <li>Conversational: Interactive back-and-forth exchanges</li> <li>Access method: <code>context.ReplyAsync()</code>, <code>context.SendDataAsync()</code>, <code>context.SendHandoffAsync()</code></li> </ul> <p>\ud83d\udcd6 Full documentation: Replying to User Messages</p>"},{"location":"concepts/messaging-proactive/#2-proactive-messaging","title":"2. Proactive Messaging","text":"<p>When your agent needs to initiate conversations or send messages from anywhere in your workflows (background processes, scheduled tasks, events), use XiansContext.Messaging:</p> C#<pre><code>// In any workflow or activity - with explicit participant ID\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your order has shipped!\",\n    participantId: \"user-123\"\n);\n\n// Or use current participant from workflow context\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your order has shipped!\"\n);\n</code></pre> <p>Key characteristics:</p> <ul> <li>Agent-initiated: Your workflows initiate the conversation</li> <li>Flexible participant targeting: Optionally specify participant ID or use current workflow context</li> <li>Background-friendly: Works from any workflow context, including scheduled/event-driven workflows</li> <li>Access method: <code>XiansContext.Messaging.&lt;methods&gt;</code> (exposed via MessagingHelper)</li> </ul> <p>\ud83d\udcd6 This document covers proactive messaging in detail below.</p>"},{"location":"concepts/messaging-proactive/#proactive-messaging","title":"Proactive Messaging","text":"<p>Proactive messaging enables your agent to initiate conversations and send messages to users without waiting for user input. This is essential for background workflows, scheduled tasks, event-driven notifications, and any scenario where your agent needs to reach out to users independently.</p>"},{"location":"concepts/messaging-proactive/#when-to-use-each-mechanism","title":"When to Use Each Mechanism","text":"<p>Use Proactive Messaging (<code>XiansContext.Messaging</code>) when:</p> <ul> <li>Background workflows need to notify users  </li> <li>Your agent detects system events requiring user notification  </li> <li>Time-based workflows send scheduled updates or reminders  </li> <li>One workflow needs to send messages on behalf of another  </li> <li>Background automation completes and needs to inform users</li> </ul> <p>Use Replying (<code>context.ReplyAsync()</code>) when:</p> <ul> <li>Responding to incoming user messages  </li> <li>Engaged in active conversational flows  </li> <li>Processing messages in <code>OnUserChatMessage</code> or <code>OnUserDataMessage</code> listeners</li> </ul>"},{"location":"concepts/messaging-proactive/#accessing-proactive-messaging","title":"Accessing Proactive Messaging","text":"<p>Proactive messaging is available through <code>XiansContext.Messaging</code> from any workflow or activity:</p> C#<pre><code>// With explicit participant ID\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your order has shipped!\",\n    participantId: \"user-123\"\n);\n\n// Using current participant from workflow context\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your order has shipped!\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#message-types","title":"Message Types","text":"<p>Xians provides several methods for proactive messaging:</p> Method Purpose Use Case <code>SendChatAsync</code> Send chat messages from current workflow Standard notifications and updates <code>SendDataAsync</code> Send data messages from current workflow Structured data delivery <code>SendChatAsWorkflowAsync</code> Send chat messages as another workflow Background workflows impersonating main workflows <code>SendDataAsWorkflowAsync</code> Send data messages as another workflow Background data delivery from impersonated workflows <code>SendChatAsSupervisorAsync</code> Send chat messages as Supervisor workflow Shorthand for messaging as Supervisor <code>SendDataAsSupervisorAsync</code> Send data messages as Supervisor workflow Shorthand for data delivery as Supervisor"},{"location":"concepts/messaging-proactive/#sending-chat-messages","title":"Sending Chat Messages","text":""},{"location":"concepts/messaging-proactive/#basic-chat-messages","title":"Basic Chat Messages","text":"<p>The most common use case is sending simple text messages:</p> C#<pre><code>// With explicit participant ID\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Reminder: Your appointment is tomorrow at 2 PM\",\n    participantId: \"user-123\"\n);\n\n// Using current workflow context participant\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Reminder: Your appointment is tomorrow at 2 PM\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#chat-messages-with-data","title":"Chat Messages with Data","text":"<p>Include structured data alongside your message:</p> C#<pre><code>var orderDetails = new\n{\n    OrderId = \"ORD-12345\",\n    Status = \"Shipped\",\n    TrackingNumber = \"1Z999AA10123456784\",\n    EstimatedDelivery = DateTime.UtcNow.AddDays(3)\n};\n\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your order has shipped!\",\n    data: orderDetails,\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#chat-messages-with-scope","title":"Chat Messages with Scope","text":"<p>Use scope to organize messages into topics:</p> C#<pre><code>await XiansContext.Messaging.SendChatAsync(\n    text: \"Your delivery is arriving today\",\n    scope: \"Order #12345 - Delivery Updates\",\n    participantId: \"user-123\"\n);\n</code></pre> <p>Learn more about message scope in Replying - Message Scope.</p>"},{"location":"concepts/messaging-proactive/#chat-messages-with-hints","title":"Chat Messages with Hints","text":"<p>Provide hints for message processing and additional context. Hints can be used by client applications to determine how to display or handle messages, and can also store additional context information that may be passed to LLMs along with chat history:</p> C#<pre><code>await XiansContext.Messaging.SendChatAsync(\n    text: \"Your payment method needs updating\",\n    hint: \"payment-reminder\",\n    participantId: \"user-123\"\n);\n</code></pre> <p>The <code>hint</code> field serves multiple purposes:</p> <ul> <li>UI Processing: Client applications can use hints to apply special styling, routing, or behavior</li> <li>LLM Context: Hints can store additional context information that gets passed to language models with chat history, helping them better understand the nature and intent of messages</li> </ul>"},{"location":"concepts/messaging-proactive/#associating-messages-with-tasks","title":"Associating Messages with Tasks","text":"<p>You can associate messages with specific tasks using the <code>taskId</code> parameter. This helps frontend UIs assist users in navigating to the associated task:</p> C#<pre><code>await XiansContext.Messaging.SendChatAsync(\n    text: \"Your analysis task has been completed\",\n    taskId: \"task-789\",\n    participantId: \"user-123\"\n);\n</code></pre> <p>The <code>taskId</code> is sent to the server alongside the message, enabling client applications to create clickable links or navigation elements that direct users to the relevant task details.</p>"},{"location":"concepts/messaging-proactive/#sending-data-messages","title":"Sending Data Messages","text":"<p>When the primary content is structured data (not text), use <code>SendDataAsync</code>:</p> C#<pre><code>var analyticsReport = new\n{\n    Period = \"2026-01\",\n    TotalRevenue = 125000,\n    NewCustomers = 47,\n    ConversionRate = 0.23,\n    TopProducts = new[] { \"Widget A\", \"Gadget B\", \"Tool C\" }\n};\n\nawait XiansContext.Messaging.SendDataAsync(\n    text: \"Your monthly analytics report is ready\",\n    data: analyticsReport,\n    participantId: \"user-123\"\n);\n</code></pre> <p>Key Difference:</p> <ul> <li><code>SendChatAsync</code>: Text is primary, data is supplementary</li> <li><code>SendDataAsync</code>: Data is primary, text is descriptive</li> </ul>"},{"location":"concepts/messaging-proactive/#workflow-impersonation","title":"Workflow Impersonation","text":"<p>Background workflows often need to send messages that appear to come from the user's main conversational workflow. This is called workflow impersonation.</p>"},{"location":"concepts/messaging-proactive/#why-impersonate-workflows","title":"Why Impersonate Workflows?","text":"<p>Consider this scenario:</p> <ol> <li>User chats with your \"Customer Support\" workflow</li> <li>You start a background \"Order Monitoring\" workflow to track their order</li> <li>When the order ships, the monitoring workflow needs to notify the user</li> <li>The message should appear in the user's \"Customer Support\" conversation, not from an unknown background workflow</li> </ol>"},{"location":"concepts/messaging-proactive/#sending-chat-messages-as-another-workflow","title":"Sending Chat Messages as Another Workflow","text":"<p>Use <code>SendChatAsWorkflowAsync</code> to send messages on behalf of a different BuiltIn workflow:</p> C#<pre><code>// In a background \"OrderMonitoring\" workflow\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    builtinWorkflowName: \"Conversational\",  // The workflow to impersonate\n    text: \"Great news! Your order has shipped and is on its way.\",\n    participantId: \"user-123\"\n);\n</code></pre> <p>The user receives this message as if it came from their \"Conversational\" workflow, maintaining conversation continuity.</p>"},{"location":"concepts/messaging-proactive/#sending-data-messages-as-another-workflow","title":"Sending Data Messages as Another Workflow","text":"<p>Similarly, send data messages while impersonating a workflow:</p> C#<pre><code>// In a background analytics workflow\nvar dashboardData = new\n{\n    Metrics = new[] { 100, 200, 150, 300 },\n    Labels = new[] { \"Week 1\", \"Week 2\", \"Week 3\", \"Week 4\" }\n};\n\nawait XiansContext.Messaging.SendDataAsWorkflowAsync(\n    builtinWorkflowName: \"Dashboard\",\n    text: \"Your weekly dashboard has been updated\",\n    data: dashboardData,\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#understanding-workflow-names","title":"Understanding Workflow Names","text":"<p>The <code>builtinWorkflowName</code> parameter refers to the workflow name you defined when creating built-in workflows, not the full workflow type:</p> C#<pre><code>// When you define a workflow\nvar chatWorkflow = agent.Workflows.DefineBuiltIn(name: \"Conversational\");\nvar analyticsWorkflow = agent.Workflows.DefineBuiltIn(name: \"Analytics\");\n\n// Use the name when impersonating\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    builtinWorkflowName: \"Conversational\",  // \u2705 Use the workflow name\n    text: \"Message from background process\",\n    participantId: \"user-123\"\n);\n\n// NOT the full workflow type\n// \u274c Don't use \"MyAgent:Conversational\"\n</code></pre>"},{"location":"concepts/messaging-proactive/#supervisor-workflow-shortcuts","title":"Supervisor Workflow Shortcuts","text":"<p>For the common scenario of sending messages as the Supervisor workflow, Xians provides convenience methods that eliminate the need to specify the workflow name:</p>"},{"location":"concepts/messaging-proactive/#sendchatassupervisorasync","title":"SendChatAsSupervisorAsync","text":"<p>Send chat messages as the Supervisor workflow without specifying the workflow name:</p> C#<pre><code>// Instead of this\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    builtinWorkflowName: \"Supervisor Workflow\",\n    text: \"Task completed successfully\",\n    participantId: \"user-123\"\n);\n\n// Use this shorthand with explicit participant ID\nawait XiansContext.Messaging.SendChatAsSupervisorAsync(\n    text: \"Task completed successfully\",\n    participantId: \"user-123\"\n);\n\n// Or without explicit participantId (uses current participant from context)\nawait XiansContext.Messaging.SendChatAsSupervisorAsync(\n    text: \"Background processing complete\",\n    data: new { Status = \"Success\", ProcessedItems = 150 }\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#senddataassupervisorasync","title":"SendDataAsSupervisorAsync","text":"<p>Send data messages as the Supervisor workflow:</p> C#<pre><code>// Shorthand for sending data as Supervisor with explicit participant ID\nawait XiansContext.Messaging.SendDataAsSupervisorAsync(\n    text: \"Task execution report\",\n    data: new\n    {\n        TaskId = \"task-456\",\n        Duration = TimeSpan.FromMinutes(5),\n        Result = \"Success\"\n    },\n    participantId: \"user-123\"\n);\n\n// Or using current participant from context\nawait XiansContext.Messaging.SendDataAsSupervisorAsync(\n    text: \"Workflow metrics\",\n    data: workflowMetrics,\n    scope: \"System Monitoring\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#when-to-use-supervisor-shortcuts","title":"When to Use Supervisor Shortcuts","text":"<p>These convenience methods are ideal for:</p> <ul> <li>Multi-agent systems where the Supervisor workflow coordinates other agents</li> <li>Background task notifications that need to appear from the Supervisor</li> <li>System-level updates sent from monitoring or orchestration workflows</li> <li>Reducing boilerplate in code that frequently messages as Supervisor</li> </ul> C#<pre><code>// Example: Background monitoring workflow notifying as Supervisor\nvar monitoringWorkflow = agent.Workflows.DefineBuiltIn(name: \"SystemMonitoring\");\n\nmonitoringWorkflow.RegisterWorkflow(async () =&gt;\n{\n    var healthStatus = await CheckSystemHealth();\n\n    if (healthStatus.HasIssues)\n    {\n        // Simplified: No need to specify workflow name\n        await XiansContext.Messaging.SendChatAsSupervisorAsync(\n            text: $\"\u26a0\ufe0f System health check detected {healthStatus.IssueCount} issues\",\n            data: healthStatus,\n            hint: \"system-alert\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-proactive/#complete-method-signatures","title":"Complete Method Signatures","text":""},{"location":"concepts/messaging-proactive/#sendchatasync","title":"SendChatAsync","text":"C#<pre><code>Task SendChatAsync(\n    string text,                // Required: Message text\n    object? data = null,        // Optional: Structured data\n    string? scope = null,       // Optional: Message scope/topic\n    string? hint = null,        // Optional: Processing hint\n    string? taskId = null,      // Optional: Task ID for UI navigation\n    string? participantId = null // Optional: User ID to send to (uses current context if null)\n)\n</code></pre>"},{"location":"concepts/messaging-proactive/#senddataasync","title":"SendDataAsync","text":"C#<pre><code>Task SendDataAsync(\n    string text,                // Required: Descriptive text\n    object data,                // Required: Data to send\n    string? scope = null,       // Optional: Message scope/topic\n    string? hint = null,        // Optional: Processing hint\n    string? taskId = null,      // Optional: Task ID for UI navigation\n    string? participantId = null // Optional: User ID to send to (uses current context if null)\n)\n</code></pre>"},{"location":"concepts/messaging-proactive/#sendchatasworkflowasync","title":"SendChatAsWorkflowAsync","text":"C#<pre><code>Task SendChatAsWorkflowAsync(\n    string builtinWorkflowName, // Required: Workflow name to impersonate\n    string text,                // Required: Message text\n    object? data = null,        // Optional: Structured data\n    string? scope = null,       // Optional: Message scope/topic\n    string? hint = null,        // Optional: Processing hint\n    string? taskId = null,      // Optional: Task ID for UI navigation\n    string? participantId = null // Optional: User ID to send to (uses current context if null)\n)\n</code></pre>"},{"location":"concepts/messaging-proactive/#senddataasworkflowasync","title":"SendDataAsWorkflowAsync","text":"C#<pre><code>Task SendDataAsWorkflowAsync(\n    string builtinWorkflowName, // Required: Workflow name to impersonate\n    string text,                // Required: Descriptive text\n    object data,                // Required: Data to send\n    string? scope = null,       // Optional: Message scope/topic\n    string? hint = null,        // Optional: Processing hint\n    string? taskId = null,      // Optional: Task ID for UI navigation\n    string? participantId = null // Optional: User ID to send to (uses current context if null)\n)\n</code></pre>"},{"location":"concepts/messaging-proactive/#sendchatassupervisorasync_1","title":"SendChatAsSupervisorAsync","text":"C#<pre><code>Task SendChatAsSupervisorAsync(\n    string text,                // Required: Message text\n    object? data = null,        // Optional: Structured data\n    string? scope = null,       // Optional: Message scope/topic\n    string? hint = null,        // Optional: Processing hint\n    string? taskId = null,      // Optional: Task ID for UI navigation\n    string? participantId = null // Optional: User ID to send to (uses current context if null)\n)\n</code></pre>"},{"location":"concepts/messaging-proactive/#senddataassupervisorasync_1","title":"SendDataAsSupervisorAsync","text":"C#<pre><code>Task SendDataAsSupervisorAsync(\n    string text,                // Required: Descriptive text\n    object data,                // Required: Data to send\n    string? scope = null,       // Optional: Message scope/topic\n    string? hint = null,        // Optional: Processing hint\n    string? taskId = null,      // Optional: Task ID for UI navigation\n    string? participantId = null // Optional: User ID to send to (uses current context if null)\n)\n</code></pre>"},{"location":"concepts/messaging-proactive/#best-practices","title":"Best Practices","text":""},{"location":"concepts/messaging-proactive/#1-choose-the-right-message-type","title":"1. Choose the Right Message Type","text":"C#<pre><code>// \u2705 Good: Text is primary content\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your package will arrive tomorrow between 2-4 PM\",\n    participantId: \"user-123\"\n);\n\n// \u2705 Good: Data is primary content\nawait XiansContext.Messaging.SendDataAsync(\n    text: \"Dashboard update\",\n    data: dashboardMetrics,\n    participantId: \"user-123\"\n);\n\n// \u274c Bad: Sending important structured data via chat\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Here's your data\",\n    data: complexAnalytics,  // Should use SendDataAsync instead\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#2-use-workflow-impersonation-for-user-context","title":"2. Use Workflow Impersonation for User Context","text":"C#<pre><code>// \u2705 Good: Background workflow sends as main workflow\n// User sees message in their familiar conversation context\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    builtinWorkflowName: \"Conversational\",\n    text: \"Update from background monitoring\",\n    participantId: \"user-123\"\n);\n\n// \u274c Bad: Background workflow sends as itself\n// User receives message from unfamiliar workflow name\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Update from OrderMonitoringWorkflow_Background_v2\",\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#3-provide-clear-actionable-messages","title":"3. Provide Clear, Actionable Messages","text":"C#<pre><code>// \u274c Vague message\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Update\",\n    participantId: \"user-123\"\n);\n\n// \u2705 Clear and informative\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your order #12345 has shipped and will arrive by Friday, Jan 24th\",\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#4-use-scope-for-topic-organization","title":"4. Use Scope for Topic Organization","text":"C#<pre><code>// \u2705 Good: Organized by topic\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Delivery scheduled for tomorrow\",\n    scope: \"Order #12345 - Delivery Updates\",\n    participantId: \"user-123\"\n);\n\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Payment received, thank you!\",\n    scope: \"Order #12345 - Payment\",\n    participantId: \"user-123\"\n);\n\n// \u274c Bad: Everything in general conversation\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Various updates about different things\",\n    participantId: \"user-123\"\n    // No scope = messages get mixed together\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#5-handle-errors-gracefully","title":"5. Handle Errors Gracefully","text":"C#<pre><code>// \u2705 Good: Proper error handling\ntry\n{\n    await XiansContext.Messaging.SendChatAsync(\n        text: notificationMessage,\n        participantId: userId\n    );\n}\ncatch (Exception ex)\n{\n    // Log the error\n    logger.LogError(ex, \"Failed to send notification to user {UserId}\", userId);\n\n    // Consider retry logic or fallback mechanisms\n    await QueueForRetry(userId, notificationMessage);\n}\n\n// \u274c Bad: Unhandled failures\nawait XiansContext.Messaging.SendChatAsync(\n    text: notificationMessage,\n    participantId: userId\n); // No error handling - failures go unnoticed\n</code></pre>"},{"location":"concepts/messaging-proactive/#6-use-hints-for-message-processing","title":"6. Use Hints for Message Processing","text":"C#<pre><code>// \u2705 Good: Hints help client applications process messages\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Critical: Your subscription expires in 24 hours\",\n    hint: \"subscription-urgent\",  // UI can show special styling\n    participantId: \"user-123\"\n);\n\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your weekly summary is ready\",\n    hint: \"weekly-summary\",  // UI can route to appropriate view\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#7-associate-task-related-messages-with-task-ids","title":"7. Associate Task-Related Messages with Task IDs","text":"C#<pre><code>// \u2705 Good: Include taskId for task-related notifications\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Your data analysis task has completed successfully\",\n    taskId: \"task-456\",  // Frontend can create a link to navigate to the task\n    participantId: \"user-123\"\n);\n\n// \u2705 Good: Combine with hint for enhanced UI behavior\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Task failed: Unable to process the uploaded file\",\n    hint: \"task-error\",\n    taskId: \"task-789\",  // UI can show error styling and task navigation\n    participantId: \"user-123\"\n);\n\n// \u274c Bad: Mentioning task without linking\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Task task-456 has completed\",  // User can't easily navigate to the task\n    participantId: \"user-123\"\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#comparison-proactive-messaging-vs-replying","title":"Comparison: Proactive Messaging vs Replying","text":"Aspect Proactive Messaging Replying Initiator Agent initiates User initiates Context No incoming message Responding to user message Access <code>XiansContext.Messaging.&lt;methods&gt;</code> <code>context.ReplyAsync()</code> / <code>context.SendDataAsync()</code> Available In Any workflow or activity Inside <code>OnUserChatMessage</code> / <code>OnUserDataMessage</code> listeners Participant ID Optional - can specify <code>participantId</code> or use current context Automatic from incoming message context Scope Must explicitly set (or null) Automatically inherits from incoming message Use Cases Background workflows, events, scheduled tasks, notifications Conversational interactions, responding to user input Implementation MessagingHelper class methods UserMessageContext methods"},{"location":"concepts/messaging-proactive/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/messaging-proactive/#messages-not-appearing","title":"Messages Not Appearing","text":"<p>Problem: Messages sent but users don't receive them.</p> <p>Solutions:</p> <ol> <li>Verify the participant ID is correct</li> <li>Check that the workflow context is properly initialized</li> <li>Ensure tenant ID is correctly set for multi-tenant scenarios</li> <li>Review logs for HTTP service errors</li> </ol> C#<pre><code>// Add logging for debugging\nlogger.LogInformation(\n    \"Sending message to participant {ParticipantId} in tenant {TenantId}\",\n    participantId,\n    XiansContext.TenantId\n);\n\nawait XiansContext.Messaging.SendChatAsync(\n    text: message,\n    participantId: participantId\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#workflow-impersonation-not-working","title":"Workflow Impersonation Not Working","text":"<p>Problem: Messages appear from wrong workflow.</p> <p>Solutions: 1. Use the workflow name (not full type) in <code>builtinWorkflowName</code> 2. Ensure the target workflow exists and is properly defined 3. Verify the workflow name matches exactly (case-sensitive)</p> C#<pre><code>// \u2705 Correct: Use the workflow name\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    builtinWorkflowName: \"Conversational\",  // Name from DefineBuiltIn\n    text: message,\n    participantId: userId\n);\n\n// \u274c Wrong: Don't use full workflow type\nawait XiansContext.Messaging.SendChatAsWorkflowAsync(\n    builtinWorkflowName: \"MyAgent:Conversational\",  // Too specific\n    text: message,\n    participantId: userId\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#messages-in-wrong-scope","title":"Messages in Wrong Scope","text":"<p>Problem: Messages appearing in unexpected conversation topics.</p> <p>Solutions: 1. Explicitly set <code>scope</code> parameter to organize messages 2. Use consistent scope naming across related messages 3. Remember that <code>null</code> scope is a distinct conversation area</p> C#<pre><code>// \u2705 Explicit scope management\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Order shipped\",\n    scope: \"Order #12345\",  // Explicit scope\n    participantId: userId\n);\n\n// Later messages use same scope\nawait XiansContext.Messaging.SendChatAsync(\n    text: \"Order delivered\",\n    scope: \"Order #12345\",  // Same scope = same topic\n    participantId: userId\n);\n</code></pre>"},{"location":"concepts/messaging-proactive/#next-steps","title":"Next Steps","text":"<ul> <li>Replying to User Messages - Learn how to respond to incoming user messages in <code>OnUserChatMessage</code> listeners</li> <li>Workflows - Understand workflow structure and lifecycle</li> <li>Scheduling - Set up time-based proactive messaging with scheduled workflows</li> <li>A2A Communication - Enable agent-to-agent messaging for multi-agent systems</li> </ul>"},{"location":"concepts/messaging-replying/","title":"Replying to User Messages","text":"<p>Built-in workflows in Xians provide a powerful messaging system that allows your agents to listen for incoming messages and respond to users naturally. This guide covers everything you need to know about handling user messages and crafting responses.</p>"},{"location":"concepts/messaging-replying/#two-flavors-of-messaging","title":"Two Flavors of Messaging","text":"<p>Xians provides two distinct mechanisms for communicating with users:</p>"},{"location":"concepts/messaging-replying/#1-replying-to-user-messages-this-document","title":"1. Replying to User Messages (This Document)","text":"<p>When users send messages to your agent, you respond using message context methods available in your message listeners:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // User initiated - you're responding\n    await context.ReplyAsync(\"I received your message!\");\n});\n</code></pre> <p>Key characteristics:</p> <ul> <li>User-initiated: Responding to incoming messages</li> <li>Context-aware: Automatic participant ID, thread continuity, scope inheritance</li> <li>Conversational: Interactive back-and-forth exchanges</li> <li>Access method: <code>context.ReplyAsync()</code>, <code>context.SendDataAsync()</code>, <code>context.SendHandoffAsync()</code></li> </ul>"},{"location":"concepts/messaging-replying/#2-proactive-messaging","title":"2. Proactive Messaging","text":"<p>When your agent needs to initiate conversations from background workflows, scheduled tasks, or events, use XiansContext.Messaging:</p> C#<pre><code>// In any workflow or activity\nawait XiansContext.Messaging.SendChatAsync(\n    participantId: \"user-123\",\n    text: \"Your order has shipped!\"\n);\n</code></pre> <p>\ud83d\udcd6 Full documentation: Proactive Messaging</p>"},{"location":"concepts/messaging-replying/#overview","title":"Overview","text":"<p>When you define a built-in workflow (like a Conversational workflow), you can register message listeners that are triggered when users send messages to your agent. These listeners receive a rich context object that contains the incoming message details and provides methods to respond.</p>"},{"location":"concepts/messaging-replying/#message-listeners","title":"Message Listeners","text":""},{"location":"concepts/messaging-replying/#listening-to-chat-messages","title":"Listening to Chat Messages","text":"<p>The most common type of message is a chat message. Register a listener using <code>OnUserChatMessage</code>:</p> C#<pre><code>var conversationalWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Conversational\");\n\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Access the user's message\n    var userMessage = context.Message.Text;\n\n    // Process and respond\n    await context.ReplyAsync($\"You said: {userMessage}\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#listening-to-data-messages","title":"Listening to Data Messages","text":"<p>For structured data messages, use <code>OnUserDataMessage</code>:</p> C#<pre><code>conversationalWorkflow.OnUserDataMessage(async (context) =&gt;\n{\n    // Access structured data from the message\n    var data = context.Message.Data;\n\n    // Process the data and respond\n    await context.ReplyAsync(\"Data received and processed!\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#accessing-message-properties","title":"Accessing Message Properties","text":"<p>The <code>context.Message</code> property gives you access to all incoming message details:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Message content\n    var text = context.Message.Text;\n    var data = context.Message.Data;\n\n    // User and conversation context\n    var participantId = context.Message.ParticipantId;\n    var threadId = context.Message.ThreadId;\n    var requestId = context.Message.RequestId;\n\n    // Additional context\n    var scope = context.Message.Scope;\n    var hint = context.Message.Hint;\n    var tenantId = context.Message.TenantId;\n\n    // Authorization (if applicable)\n    var authorization = context.Message.Authorization;\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#message-properties-reference","title":"Message Properties Reference","text":"Property Type Description <code>Text</code> <code>string</code> The text content of the message <code>Data</code> <code>object?</code> Structured data associated with the message <code>ParticipantId</code> <code>string</code> Unique identifier for the conversation participant <code>RequestId</code> <code>string</code> Unique identifier for this specific message request <code>ThreadId</code> <code>string?</code> Thread identifier for conversation threading <code>Scope</code> <code>string?</code> Optional scope for organizing messages into topics (see Scope) <code>Hint</code> <code>string?</code> Optional hint for message handling <code>TenantId</code> <code>string</code> Tenant identifier (for multi-tenant applications) <code>Authorization</code> <code>string?</code> Authorization token if provided"},{"location":"concepts/messaging-replying/#message-types","title":"Message Types","text":"<p>When responding to users, there are three distinct message types:</p> Type Purpose Method Use Case Chat Standard agent-user conversations <code>ReplyAsync()</code> Text-based communication and typical conversational interactions Data Passing structured data between parties <code>SendDataAsync()</code> Sending structured data objects; data is the primary content Handoff Transfer user to a different workflow/sub-agent <code>SendHandoffAsync()</code> Routing to specialized agents; requests UI to switch to a different workflow ID"},{"location":"concepts/messaging-replying/#responding-to-users","title":"Responding to Users","text":"<p>Xians provides several methods for sending responses back to users, each optimized for different use cases.</p>"},{"location":"concepts/messaging-replying/#simple-text-replies","title":"Simple Text Replies","text":"<p>The most straightforward way to respond is with plain text:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    await context.ReplyAsync(\"Hello! How can I help you today?\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#replies-with-data","title":"Replies with Data","text":"<p>Send both text and structured data together using the optional <code>data</code> parameter:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var result = new \n    {\n        Status = \"Success\",\n        Timestamp = DateTime.UtcNow,\n        ProcessedItems = 42\n    };\n\n    await context.ReplyAsync(\"Processing complete!\", result);\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#data-focused-responses","title":"Data-Focused Responses","text":"<p>When the primary response is structured data, use <code>SendDataAsync</code>:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var analyticsData = new \n    {\n        Metrics = new[] { 100, 200, 300 },\n        Labels = new[] { \"Jan\", \"Feb\", \"Mar\" }\n    };\n\n    // Data is the primary content\n    await context.SendDataAsync(analyticsData, \"Here are your analytics\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#message-scope","title":"Message Scope","text":"<p>Scope is a powerful feature for organizing messages into isolated topics within a conversation thread. When messages share the same scope value, they form a distinct topic, allowing you to manage multiple parallel conversations or subject areas with the same participant.</p>"},{"location":"concepts/messaging-replying/#how-scope-works","title":"How Scope Works","text":"<ul> <li>Messages with the same scope string are grouped together as a topic</li> <li>Each scope creates an isolated conversation context within the thread</li> <li>Users and agents can set scope when sending messages or responding</li> <li>Scope is optional - messages without a scope belong to the main conversation</li> </ul>"},{"location":"concepts/messaging-replying/#accessing-current-message-scope","title":"Accessing Current Message Scope","text":"C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var currentScope = context.Message.Scope;\n\n    if (currentScope != null)\n    {\n        await context.ReplyAsync($\"Discussing topic: {currentScope}\");\n    }\n    else\n    {\n        await context.ReplyAsync(\"General conversation\");\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#best-practices-for-scope","title":"Best Practices for Scope","text":"<p>Use Human-Readable Scope Values</p> <p>Always use descriptive, human-readable strings for scope values. These can be displayed to users when showing conversation threads:</p> C#<pre><code>// Good - Clear, human-readable scope\nvar scope = \"Order #12345 - Delivery Status\";\nvar scope = \"Project Alpha - Budget Discussion\";\nvar scope = \"Technical Support - Login Issues\";\n\n// Bad - Technical IDs or codes\nvar scope = \"ord_12345_dlv_sts\";\nvar scope = \"uuid-1234-5678-9abc\";\n</code></pre>"},{"location":"concepts/messaging-replying/#creating-scoped-conversations","title":"Creating Scoped Conversations","text":"<p>When you want to start a new topic or respond within a specific scope, you can set the scope in your context. Messages will automatically inherit the current scope:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var userMessage = context.Message.Text.ToLower();\n\n    if (userMessage.Contains(\"order status\"))\n    {\n        // The scope from the incoming message will be preserved in the reply\n        // All subsequent messages in this topic will share this scope\n        await context.ReplyAsync(\n            \"Let me check your order status. Which order would you like to know about?\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#scope-with-chat-history","title":"Scope with Chat History","text":"<p>When retrieving chat history, only messages with the same scope are returned, maintaining topic isolation:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var currentScope = context.Message.Scope;\n\n    // This returns only messages with the same scope\n    var scopedHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n    if (currentScope != null)\n    {\n        // All messages in scopedHistory will share the same scope\n        await context.ReplyAsync(\n            $\"I see we've discussed '{currentScope}' in {scopedHistory.Count} previous messages.\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#reply-scope","title":"Reply Scope","text":"<p>When you send a reply, it automatically inherits the scope from the incoming message, maintaining topic continuity:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // This reply automatically uses the same scope as context.Message.Scope\n    await context.ReplyAsync(\"Your message is within the current scope.\");\n\n    // The sent message will have the same scope as the incoming message\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#null-scope","title":"Null Scope","text":"<p>Messages sent without a specified scope (scope is <code>null</code>) form their own isolated context - the general conversation area within the thread:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    if (context.Message.Scope == null)\n    {\n        // This is a general conversation message\n        // History will only include other messages with null scope\n        var generalHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n        await context.ReplyAsync(\"Discussing general topics.\");\n    }\n    else\n    {\n        // This is a scoped topic message\n        var topicHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n        await context.ReplyAsync($\"Discussing: {context.Message.Scope}\");\n    }\n});\n</code></pre> <p>Key Points:</p> <ul> <li>Messages with <code>scope = null</code> are NOT accessible when querying with a specific scope</li> <li>Messages with <code>scope = \"Topic A\"</code> are NOT accessible when querying with <code>scope = null</code> or <code>scope = \"Topic B\"</code></li> <li>Each scope (including <code>null</code>) forms a completely isolated conversation context</li> <li>Scope isolation happens automatically - you don't need to manually filter messages</li> </ul>"},{"location":"concepts/messaging-replying/#chat-history","title":"Chat History","text":"<p>Access the conversation history to provide context-aware responses:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Get the last 10 messages\n    var history = await context.GetChatHistoryAsync(page: 1, pageSize: 10);\n\n    // Use history to understand context\n    var messageCount = history.Count;\n    await context.ReplyAsync($\"I see we've exchanged {messageCount} messages so far.\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#pagination","title":"Pagination","text":"<p>For longer conversations, use pagination:</p> C#<pre><code>// Get second page with 20 messages per page\nvar page2 = await context.GetChatHistoryAsync(page: 2, pageSize: 20);\n</code></pre>"},{"location":"concepts/messaging-replying/#working-with-hints","title":"Working with Hints","text":"<p>Retrieve the last hint to understand user intent or context:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var lastHint = await context.GetLastHintAsync();\n\n    if (lastHint != null)\n    {\n        await context.ReplyAsync($\"Based on your hint '{lastHint}', I'll help with that.\");\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#skipping-responses","title":"Skipping Responses","text":"<p>Sometimes you want to process a message without sending a response:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Set this flag to prevent automatic responses\n    context.SkipResponse = true;\n\n    // Process the message silently\n    await LogMessageToDatabase(context.Message.Text);\n\n    // No response will be sent to the user\n});\n</code></pre> <p>This is useful for:</p> <ul> <li>Analytics and logging</li> <li>Background processing</li> <li>Conditional response logic</li> </ul> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Conditionally skip responses\n    if (context.Message.Text.StartsWith(\"LOG:\"))\n    {\n        context.SkipResponse = true;\n        await LogSystemEvent(context.Message.Text);\n        return;\n    }\n\n    await context.ReplyAsync(\"Message received!\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#handing-off-to-another-workflow","title":"Handing Off to Another Workflow","text":"<p>Transfer the conversation to a different workflow when needed:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    if (context.Message.Text.Contains(\"talk to sales\"))\n    {\n        await context.SendHandoffAsync(\n            targetWorkflowId: \"sales-workflow-id\",\n            message: \"Customer wants to discuss sales\",\n            data: new { Source = \"chat\", Priority = \"high\" },\n            userMessage: \"Connecting you with our sales team...\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#best-practices","title":"Best Practices","text":""},{"location":"concepts/messaging-replying/#1-always-handle-errors-gracefully","title":"1. Always Handle Errors Gracefully","text":"C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    try\n    {\n        var response = await ProcessMessageAsync(context.Message.Text);\n        await context.ReplyAsync(response);\n    }\n    catch (Exception ex)\n    {\n        // Log the error\n        logger.LogError(ex, \"Error processing message\");\n\n        // Send friendly error message to user\n        await context.ReplyAsync(\n            \"I encountered an error processing your request. Please try again.\"\n        );\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#2-provide-clear-actionable-responses","title":"2. Provide Clear, Actionable Responses","text":"C#<pre><code>//  Vague response\nawait context.ReplyAsync(\"Done\");\n\n//  Clear, informative response\nawait context.ReplyAsync(\"I've updated your preferences. You'll now receive daily summaries at 9 AM.\");\n</code></pre>"},{"location":"concepts/messaging-replying/#3-use-appropriate-response-methods","title":"3. Use Appropriate Response Methods","text":"C#<pre><code>// For text-only responses\nawait context.ReplyAsync(\"Simple message\");\n\n// For text with data\nawait context.ReplyAsync(\"Your order is ready!\", orderDetails);\n\n// When data is the primary response\nawait context.SendDataAsync(chartData, \"Here's your analytics dashboard\");\n</code></pre>"},{"location":"concepts/messaging-replying/#4-leverage-chat-history-wisely","title":"4. Leverage Chat History Wisely","text":"C#<pre><code>// Don't fetch too much history unnecessarily\nvar recentHistory = await context.GetChatHistoryAsync(pageSize: 5); // Good\n\n// Avoid excessive pagination in real-time handlers\nvar allHistory = await context.GetChatHistoryAsync(pageSize: 1000); // Potentially slow\n</code></pre>"},{"location":"concepts/messaging-replying/#5-use-descriptive-scopes-for-topic-organization","title":"5. Use Descriptive Scopes for Topic Organization","text":"C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var scope = context.Message.Scope;\n\n    // \u2705 Good - Users can understand the topic\n    if (scope == \"Order #12345 - Delivery Questions\")\n    {\n        await HandleOrderDeliveryQuestions(context);\n    }\n\n    // \u274c Bad - Cryptic scope values\n    if (scope == \"ord_dlv_12345\")\n    {\n        await HandleOrderDeliveryQuestions(context);\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#metadata-access","title":"Metadata Access","text":"<p>Access optional metadata passed with messages internally in the agent (For example in A2A message passing). Metada is not returned or obtained from the user.</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    if (context.Metadata != null)\n    {\n        if (context.Metadata.TryGetValue(\"priority\", out var priority))\n        {\n            // Handle high-priority messages differently\n            if (priority == \"high\")\n            {\n                await HandleUrgentMessage(context);\n            }\n        }\n    }\n\n    await context.ReplyAsync(\"Processing your request...\");\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#message-threads","title":"Message Threads","text":"<p>Message threads are the fundamental organizational unit for conversations between users and agents in the Xians platform. Every message exchange is associated with a specific thread that groups related interactions together.</p>"},{"location":"concepts/messaging-replying/#thread-identity","title":"Thread Identity","text":"<p>Each message thread is uniquely identified by a composite primary key consisting of three components:</p> <ol> <li>Tenant ID: Identifies the organization or tenant</li> <li>Workflow ID: Identifies the specific workflow or agent instance  </li> <li>Participant ID: Identifies the user or participant in the conversation</li> </ol> <p>This three-part identifier ensures that conversations are properly isolated and organized across different tenants, workflows, and users.</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // Thread identity components\n    var tenantId = context.Message.TenantId;           // Which organization\n    var workflowId = XiansContext.CurrentWorkflow.WorkflowType; // Which agent/workflow\n    var participantId = context.Message.ParticipantId; // Which user\n\n    // Together, these three values uniquely identify this conversation thread\n    // All messages between this user and this workflow in this tenant\n    // belong to the same thread\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#thread-continuity","title":"Thread Continuity","text":"<p>All conversations between a specific user and agent workflow are grouped within a single thread, maintaining context and conversation history throughout the interaction lifecycle:</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var threadId = context.Message.ThreadId;\n\n    if (threadId != null)\n    {\n        // This conversation has history\n        var allMessages = await context.GetChatHistoryAsync(pageSize: 100);\n\n        await context.ReplyAsync(\n            $\"We've exchanged {allMessages.Count} messages in this ongoing conversation.\"\n        );\n    }\n    else\n    {\n        // First message in this thread\n        await context.ReplyAsync(\"Welcome! This is the start of our conversation.\");\n    }\n});\n</code></pre> <p>Key Thread Characteristics:</p> <ul> <li>Persistent: Threads persist across multiple message exchanges and sessions</li> <li>Isolated: Messages in one thread are never visible to other threads</li> <li>Tenant-Scoped: Threads are isolated per tenant in multi-tenant applications</li> <li>Workflow-Specific: Each workflow maintains separate threads with the same user</li> <li>User-Specific: Each user has their own thread with each workflow</li> </ul>"},{"location":"concepts/messaging-replying/#thread-and-scope-management","title":"Thread and Scope Management","text":"<p>Threads and scopes work together in a hierarchical structure to organize conversations and manage context.</p>"},{"location":"concepts/messaging-replying/#hierarchical-organization","title":"Hierarchical Organization","text":"<p>The Xians messaging system uses a three-level hierarchy:</p> Text Only<pre><code>Thread (Top Level)\n\u251c\u2500\u2500 Scope: null (Default/General Conversation)\n\u2502   \u251c\u2500\u2500 Message 1\n\u2502   \u251c\u2500\u2500 Message 2\n\u2502   \u2514\u2500\u2500 Message 3\n\u251c\u2500\u2500 Scope: \"Order #12345\"\n\u2502   \u251c\u2500\u2500 Message 4\n\u2502   \u251c\u2500\u2500 Message 5\n\u2502   \u2514\u2500\u2500 Message 6\n\u2514\u2500\u2500 Scope: \"Technical Support\"\n    \u251c\u2500\u2500 Message 7\n    \u2514\u2500\u2500 Message 8\n</code></pre> <p>Hierarchy Breakdown:</p> <ol> <li>Thread: The top-level container (identified by Tenant + Workflow + Participant)</li> <li>Scope: Sub-organization within the thread (optional string identifier)</li> <li>Messages: Individual messages within a specific scope</li> </ol> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var threadId = context.Message.ThreadId;\n    var scope = context.Message.Scope;\n\n    if (threadId != null)\n    {\n        // This is part of a thread\n        var threadHistory = await context.GetChatHistoryAsync(pageSize: 20);\n\n        if (scope != null)\n        {\n            // Scoped topic within a thread\n            await context.ReplyAsync(\n                $\"Continuing our discussion about '{scope}' in this thread...\"\n            );\n        }\n        else\n        {\n            // General thread conversation (null scope)\n            await context.ReplyAsync(\"Continuing our conversation in this thread...\");\n        }\n    }\n    else\n    {\n        // New conversation\n        await context.ReplyAsync(\"Starting a new conversation!\");\n    }\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#understanding-threads-vs-scope","title":"Understanding Threads vs Scope","text":"<ul> <li>Thread: A continuous conversation session between a user and agent workflow</li> <li>Purpose: Groups all interactions between a specific user and workflow</li> <li>Lifetime: Persists indefinitely across all message exchanges</li> <li> <p>Uniqueness: One thread per (Tenant, Workflow, Participant) combination</p> </li> <li> <p>Scope: Topics or subject areas within a thread for organizing messages</p> </li> <li>Purpose: Isolates related messages into distinct topics within a thread</li> <li>Lifetime: Exists as long as messages reference it</li> <li>Uniqueness: Multiple scopes can exist within a single thread</li> </ul> <p>Think of it as:</p> <ul> <li>Thread = The entire conversation book</li> <li>Scope = Individual chapters within that book</li> <li>Messages = Pages within each chapter</li> </ul>"},{"location":"concepts/messaging-replying/#practical-examples","title":"Practical Examples","text":"<p>Single Thread, Multiple Scopes:</p> C#<pre><code>// Example: Multiple topics within one thread\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var threadId = context.Message.ThreadId; // e.g., \"thread-123\"\n    var scope = context.Message.Scope;\n\n    // Same thread, different scopes = different topics in the same conversation\n    // - Thread \"thread-123\", Scope \"Order #5678\" (messages about this order)\n    // - Thread \"thread-123\", Scope \"Shipping Questions\" (shipping-related messages)\n    // - Thread \"thread-123\", Scope null (general chat messages)\n\n    // Each scope maintains its own isolated message history\n    var scopeHistory = await context.GetChatHistoryAsync(pageSize: 20);\n    // Only returns messages from the current scope\n});\n</code></pre> <p>Multi-User, Multi-Workflow Isolation:</p> C#<pre><code>// Different users with same workflow = different threads\n// User A + Workflow \"Sales\" + Tenant \"ACME\" = Thread 1\n// User B + Workflow \"Sales\" + Tenant \"ACME\" = Thread 2\n\n// Same user with different workflows = different threads  \n// User A + Workflow \"Sales\" + Tenant \"ACME\" = Thread 1\n// User A + Workflow \"Support\" + Tenant \"ACME\" = Thread 3\n\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    // This user's history with THIS specific workflow\n    var workflowSpecificHistory = await context.GetChatHistoryAsync(pageSize: 50);\n\n    // Messages from other workflows are never visible here\n});\n</code></pre>"},{"location":"concepts/messaging-replying/#next-steps","title":"Next Steps","text":"<ul> <li>Proactive Messaging - Learn how to initiate messages from background workflows using <code>XiansContext.Messaging</code></li> <li>Workflows - Understand workflow structure and how to define built-in workflows</li> <li>A2A Communication - Enable agent-to-agent messaging for multi-agent systems</li> </ul>"},{"location":"concepts/metrics/","title":"Metrics &amp; Usage Tracking","text":"<p>Track everything your agents do\u2014from LLM token usage to business outcomes\u2014with zero configuration required.</p>"},{"location":"concepts/metrics/#choose-your-starting-point","title":"Choose Your Starting Point","text":"<p>The metrics system has two entry points depending on where you're working:</p>"},{"location":"concepts/metrics/#-in-message-listeners-use-contextmetrics","title":"\ud83d\udce8 In Message Listeners? Use <code>context.Metrics</code>","text":"<p>When handling user messages, the context already knows everything:</p> C#<pre><code>workflow.OnUserChatMessage(async (context) =&gt; \n{\n    await context.Metrics\n        .WithMetric(\"tokens\", \"total\", 150, \"tokens\")\n        .ReportAsync();\n});\n</code></pre>"},{"location":"concepts/metrics/#-in-custom-workflows-use-xianscontextmetrics","title":"\u2699\ufe0f In Custom Workflows? Use <code>XiansContext.Metrics</code>","text":"<p>For workflows and activities, grab context from the Xians runtime:</p> C#<pre><code>[WorkflowRun]\npublic async Task RunAsync()\n{\n    await XiansContext.Metrics\n        .WithMetric(\"workflow\", \"started\", 1, \"count\")\n        .ReportAsync();\n}\n</code></pre>"},{"location":"concepts/metrics/#beyond-the-basics","title":"Beyond the Basics","text":"<p>Want more control? Chain these fluent methods:</p> C#<pre><code>await context.Metrics\n    .WithCustomIdentifier($\"msg-{messageId}\")    // Link to your systems\n    .WithMetadata(\"version\", \"2.1.0\")            // Add context\n    .WithMetadata(customTags)                    // Or bulk metadata\n    .WithRequestId(\"trace-123\")                  // For request tracing\n    .WithMetrics(                                // Track multiple values\n        (\"tokens\", \"prompt\", 45, \"tokens\"),\n        (\"tokens\", \"completion\", 105, \"tokens\")\n    )\n    .ReportAsync();\n</code></pre> <p>Optional: Only add <code>.ForModel(\"gpt-4\")</code> when tracking model-specific costs or performance.</p>"},{"location":"concepts/metrics/#why-track-metrics","title":"Why Track Metrics?","text":"<p>Agent work spans technical (tokens, API calls), business (approvals, documents), and operational (HITL tasks) layers. Xians auto-captures context (tenant, user, workflow) so you track what matters.</p>"},{"location":"concepts/metrics/#automatic-context-population","title":"Automatic Context Population","text":"<p>Every metric report automatically includes:</p> Field Auto-Populated From Purpose <code>TenantId</code> <code>XiansContext.SafeTenantId</code> Multi-tenant isolation <code>ParticipantId</code> <code>XiansContext.SafeParticipantId</code> User attribution <code>WorkflowId</code> <code>XiansContext.SafeWorkflowId</code> Session tracking <code>AgentName</code> <code>XiansContext.SafeAgentName</code> Agent attribution <code>ActivationName</code> <code>XiansContext.SafeWorkflowType</code> Workflow type <p>No setup required. Call it from anywhere in your workflow or activity.</p>"},{"location":"concepts/metrics/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/metrics/#track-llm-token-usage","title":"Track LLM Token Usage","text":"C#<pre><code>var response = await CallLLM(prompt);\n\nawait context.Metrics\n    .ForModel(\"gpt-4\")\n    .WithMetrics(\n        (\"tokens\", \"prompt\", response.PromptTokens, \"tokens\"),\n        (\"tokens\", \"completion\", response.CompletionTokens, \"tokens\"),\n        (\"tokens\", \"total\", response.TotalTokens, \"tokens\")\n    )\n    .ReportAsync();\n</code></pre>"},{"location":"concepts/metrics/#track-business-outcomes","title":"Track Business Outcomes","text":"C#<pre><code>await context.Metrics\n    .WithMetrics(\n        (\"approvals\", \"submitted\", 1, \"count\"),\n        (\"documents\", \"generated\", 1, \"count\"),\n        (\"emails\", \"sent\", 3, \"count\")\n    )\n    .ReportAsync();\n</code></pre>"},{"location":"concepts/metrics/#track-performance","title":"Track Performance","text":"C#<pre><code>var stopwatch = Stopwatch.StartNew();\nvar result = await ProcessData(input);\nstopwatch.Stop();\n\nawait context.Metrics\n    .WithMetrics(\n        (\"performance\", \"processing_time\", stopwatch.ElapsedMilliseconds, \"ms\"),\n        (\"performance\", \"records_processed\", result.Count, \"count\")\n    )\n    .ReportAsync();\n</code></pre>"},{"location":"concepts/metrics/#link-to-external-systems","title":"Link to External Systems","text":"<p>Use custom identifiers to correlate metrics with your external systems:</p> C#<pre><code>await context.Metrics\n    .ForModel(\"gpt-4\")\n    .WithCustomIdentifier($\"msg-{messageId}\")  // Your message ID\n    .WithMetric(\"tokens\", \"total\", 150, \"tokens\")\n    .ReportAsync();\n</code></pre>"},{"location":"concepts/metrics/#fine-tune-when-needed","title":"Fine-Tune When Needed","text":"<p>Need to override auto-populated values? Chain any of these:</p> <ul> <li><code>.WithTenantId(string)</code> - Override tenant</li> <li><code>.WithUserId(string)</code> - Override participant/user  </li> <li><code>.WithWorkflowId(string)</code> - Override workflow</li> <li><code>.WithRequestId(string)</code> - Set request correlation ID</li> <li><code>.FromSource(string)</code> - Override source identifier</li> </ul> <p>Example: C#<pre><code>await XiansContext.Metrics\n    .WithTenantId(\"custom-tenant\")     \n    .WithUserId(\"admin-override\")         \n    .WithMetric(\"admin\", \"action\", 1, \"count\")\n    .ReportAsync();\n</code></pre></p>"},{"location":"concepts/metrics/#a2a-aware-tracking","title":"A2A-Aware Tracking","text":"<p>In Agent-to-Agent (A2A) scenarios, metrics automatically use the target workflow context:</p> C#<pre><code>// Metrics tracked against TargetWorkflow, not SourceWorkflow\nawait context.Metrics  // A2AMessageContext\n    .WithMetric(\"a2a_call\", \"completed\", 1, \"count\")\n    .ReportAsync();\n</code></pre> <p>No special handling required\u2014the builder detects A2A context automatically.</p>"},{"location":"concepts/metrics/#workflow-vs-activity-context","title":"Workflow vs Activity Context","text":"<p>The metrics system handles both seamlessly:</p> <ul> <li>In Workflows: Uses Temporal activities (deterministic)</li> <li>In Activities: Direct HTTP calls (non-deterministic allowed)</li> </ul> <p>You call the same API everywhere. The system chooses the right approach.</p>"},{"location":"concepts/metrics/#best-practices","title":"Best Practices","text":"<p>\u2705 Track early and often - Metrics are cheap, insights are valuable \u2705 Use meaningful categories - \"tokens\", \"approvals\", \"emails\", not \"metric1\" \u2705 Include units - \"tokens\", \"count\", \"ms\", \"usd\" \u2705 Link to business value - Track what matters to your users \u2705 Use custom identifiers - Correlate with your external systems  </p> <p>\u274c Don't track PII - Metrics are for aggregation, not user data \u274c Don't track secrets - Never include API keys or credentials \u274c Don't over-specify - Let auto-population handle context fields  </p>"},{"location":"concepts/metrics/#summary","title":"Summary","text":"<p>Metrics in Xians are:</p> <ul> <li>Automatic: Context population with zero configuration</li> <li>Flexible: Track any metric with any label</li> <li>Universal: Same API in workflows, activities, and message handlers</li> <li>Smart: A2A-aware, workflow-aware, determinism-aware</li> </ul> <p>Just call <code>.WithMetric()</code> and <code>.ReportAsync()</code>. Everything else is handled for you.</p>"},{"location":"concepts/multitenancy/","title":"Agents &amp; Multitenancy","text":"<p>The Xians platform supports a comprehensive multitenancy model that enables system administrators, tenant administrators, and end users to work with agents at different levels of control and customization.</p>"},{"location":"concepts/multitenancy/#agent-lifecycle-in-a-multitenant-environment","title":"Agent Lifecycle in a Multitenant Environment","text":"<p>The agent lifecycle in Xians consists of three distinct phases: Registration, Deployment, and Activation. Each phase is controlled by different user roles and serves a specific purpose in the multitenant architecture.</p> <pre><code>sequenceDiagram\n    participant SA as System Admin\n    participant System as Xians Platform\n    participant TA as Tenant Admin\n    participant Tenant as Tenant Space\n    participant User as Tenant User\n    participant WF as Workflow Instance\n\n    SA-&gt;&gt;System: Register Agent (IsTemplate=true)\n    System--&gt;&gt;System: Create Agent Template\n    Note over System: Available to all tenants\n\n    TA-&gt;&gt;System: Browse Agent Templates\n    TA-&gt;&gt;Tenant: Deploy Agent\n    Note over Tenant: Agent available but inactive\n\n    User-&gt;&gt;Tenant: View Deployed Agents\n    User-&gt;&gt;WF: Activate Workflow (with identity &amp; config)\n    WF--&gt;&gt;User: Workflow Instance Running\n    User-&gt;&gt;WF: Activate Another Instance\n    WF--&gt;&gt;User: Second Instance Running\n\n    Note over SA,WF: Registration \u2192 Deployment \u2192 Activation</code></pre>"},{"location":"concepts/multitenancy/#lifecycle-phase-overview","title":"Lifecycle Phase Overview","text":"Phase Role Action Scope Output 1. Registration System Administrator Create agent template with <code>IsTemplate=true</code> Platform-wide Reusable agent template available to all tenants 2. Deployment Tenant Administrator Deploy agent template to tenant Tenant-specific Agent visible and configurable within tenant 3. Activation Tenant Users Activate workflow with unique identity Workflow-specific Running workflow instance with custom configuration"},{"location":"concepts/multitenancy/#1-agent-registration-system-scoped","title":"1. Agent Registration (System-Scoped)","text":"<p>Who: System Administrators</p> <p>What: System administrators can register agents as IsTemplate through agent code. These agents become reusable templates that are available across all tenants in the platform.</p> <p>How: Agents are registered programmatically using the agent registration API:</p> C#<pre><code>var agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"LeadDiscoveryAgent\",\n    Description = \"A lead discovery agent that can discover leads from a given company\",\n    Version = \"1.0.0\",\n    Author = \"99x\",\n    IsTemplate = true  // Makes this agent available as a template for all tenants\n});\n</code></pre> <p>When an agent is registered with <code>IsTemplate = true</code>, it becomes an agent template that can be deployed to any tenant without needing to duplicate the agent code.</p>"},{"location":"concepts/multitenancy/#2-agent-deployment","title":"2. Agent Deployment","text":"<p>Who: Tenant Administrators</p> <p>What: Tenant administrators can deploy system-scoped agent templates to their specific tenant, making the agent available for users within that tenant.</p> <p>How: Deployment can be performed through:</p> <ul> <li>UI Portal: A visual interface where tenant admins can browse available agent templates and deploy them to their tenant</li> <li>API: Programmatic deployment for automation and integration scenarios</li> </ul> <p>Once deployed, the agent becomes available in the tenant's context but is not yet active. Deployment is a tenant-level operation that makes the agent visible and configurable within the tenant.</p>"},{"location":"concepts/multitenancy/#3-agent-activation","title":"3. Agent Activation","text":"<p>Who: Tenant Users</p> <p>What: Users within a tenant can activate deployed agents. Activation occurs at the individual workflow level, not at the agent level. A single deployed agent can be activated multiple times, with each activation having a unique identity.</p> <p>How: When activating an agent workflow, users can:</p> <ul> <li>Provide a unique identity for the activation</li> <li>Supply necessary input parameters required by the workflow</li> <li>Configure workflow-specific settings</li> </ul> <p>Multiple Activations: The same deployed agent can be activated multiple times by different users or for different purposes, each with its own unique configuration and identity.</p>"},{"location":"concepts/multitenancy/#knowledge-and-multi-tenancy","title":"Knowledge and Multi-Tenancy","text":"<p>Knowledge in Xians follows the same multi-tenancy principles as agents, with automatic scoping based on the agent's configuration.</p>"},{"location":"concepts/multitenancy/#system-scoped-knowledge","title":"System-Scoped Knowledge","text":"<p>When knowledge is uploaded with a system-scoped agent (during registration), it is automatically created as system-scoped knowledge:</p> C#<pre><code>// Register system-scoped agent\nvar agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n{\n    Name = \"LeadDiscoveryAgent\",\n    IsTemplate = true  // Agent is system-scoped\n});\n\n// Upload knowledge - automatically becomes system-scoped\nawait agent.Knowledge.UploadEmbeddedResourceAsync(\n    resourcePath: \"prompts/system-prompt.md\",\n    knowledgeName: \"default-prompt\"\n);\n// \u2705 Knowledge is stored with IsTemplate = true\n</code></pre> <p>Learn More About Knowledge</p> <p>For detailed information on embedding knowledge files, configuring your project, and managing knowledge resources, see the Knowledge documentation.</p> <p>Characteristics of system-scoped knowledge:</p> <ul> <li>Shared across all tenants as default/template knowledge</li> <li>Visible to all tenants that deploy the agent</li> <li>Can only be edited by system administrators</li> <li>Serves as the baseline knowledge for the agent</li> </ul>"},{"location":"concepts/multitenancy/#tenant-scoped-knowledge","title":"Tenant-Scoped Knowledge","text":"<p>When a system-scoped agent is deployed to a tenant, the associated system-scoped knowledge is automatically duplicated and attached to the deployed agent under tenant scope:</p>"},{"location":"concepts/multitenancy/#workflow-types-and-activation","title":"Workflow Types and Activation","text":"<p>Agents in the Xians platform can contain multiple workflows, and these workflows are categorized into two types based on their activation behavior:</p> Feature Built-In Workflows Custom Workflows Input Requirements No user input needed Requires user-provided parameters Activation Timing Automatic upon invocation Manual with configuration Primary Use Case Event-driven operations Scheduled &amp; business processes"},{"location":"concepts/multitenancy/#built-in-workflows","title":"Built-In Workflows","text":"<p>Characteristics:</p> <ul> <li>Do not require input parameters from users</li> <li>Automatically activated upon invocation</li> <li>Typically handle standard, event-driven operations</li> </ul> <p>Examples:</p> <ul> <li>Webhook Handling: Automatically processes incoming webhook requests</li> <li>Conversation Handling: Responds to user conversations without manual configuration</li> </ul> <p>Built-in workflows are designed for immediate use and require no additional setup beyond deployment.</p>"},{"location":"concepts/multitenancy/#custom-workflows","title":"Custom Workflows","text":"<p>Characteristics:</p> <ul> <li>Require user-provided input parameters during activation</li> <li>Support scheduled and business-specific processes</li> <li>Allow for customization and configuration per activation</li> </ul> <p>Examples:</p> <ul> <li>Scheduled Business Processes: Periodic data processing, report generation, or batch operations</li> <li>Custom Integrations: Workflows that need API keys, endpoints, or business-specific parameters</li> </ul> <p>Custom workflows enable users to tailor agent behavior to their specific needs while maintaining the reusability of the agent template.</p>"},{"location":"concepts/multitenancy/#benefits-of-this-model","title":"Benefits of This Model","text":"<ol> <li>Reusability: System-scoped agents can be deployed across multiple tenants without code duplication</li> <li>Isolation: Each tenant's deployed agents operate independently</li> <li>Flexibility: Multiple activations allow different teams or use cases within a tenant</li> <li>Governance: Clear separation of responsibilities between system admins, tenant admins, and users</li> <li>Scalability: Agents can be updated centrally while maintaining tenant-specific configurations</li> </ol>"},{"location":"concepts/overview/","title":"Concepts","text":"<p>Deep dive into Xians' core concepts and patterns for building production-ready AI agents. This section covers the architectural patterns, workflows, and capabilities that power enterprise agent systems.</p> Page Description SDK Patterns Understand key SDK design patterns for working with agents and workflows Agents Learn about agent registration, workflows, and multi-tenancy architecture Multitenancy Explore strategies for securely isolating and serving multiple tenants Temporal Workflows Start, execute, and communicate with Temporal-based workflows [XiansContext] Replying to User Master message handling, replies, threads, scopes, and conversational patterns Proactive Messaging Initiate conversations, send notifications proactively from any workflow Web SDK Build web-based conversational UIs with the official TypeScript client Knowledge Manage prompts, instructions, and configuration shared between code and UI Document DB Store and query structured JSON data with semantic keys and metadata Scheduling Create time-based workflow automation with cron expressions and intervals Agent-to-Agent (A2A) Enable workflow communication through messages, signals, queries, and updates Human-in-the-Loop Implement approval workflows where agents pause for human review Webhooks Integrate external systems using incoming and outgoing HTTP callbacks"},{"location":"concepts/overview/#a-typical-agent-flow","title":"A Typical Agent Flow","text":"<p>Here's how features combine in a real-world scenario\u2014an autonomous content agent:</p> <pre><code>sequenceDiagram\n    participant S as \u23f0 Schedule\n    participant W as \ud83d\udd04 Workflow\n    participant K as \ud83d\udca1 Knowledge\n    participant D as \ud83d\udce6 Document DB\n    participant A2A as \ud83d\udd17 A2A\n    participant H as \ud83d\udc64 Human\n    participant M as \ud83d\udcac Messaging\n\n    S-&gt;&gt;W: Trigger daily content check\n    W-&gt;&gt;K: Fetch system instructions\n    W-&gt;&gt;D: Get pending content items\n    W-&gt;&gt;A2A: Send to analyzer agent\n    A2A--&gt;&gt;W: Return analysis\n    W-&gt;&gt;H: Create HITL approval task\n    H--&gt;&gt;W: Approve with edits\n    W-&gt;&gt;M: Notify user of publication\n    W-&gt;&gt;D: Update content status\n    W-&gt;&gt;S: Schedule next run</code></pre> <p>example: \"What's happening here?\"</p> Text Only<pre><code>1. **Schedule** triggers the workflow every morning\n2. **Knowledge** provides the agent's instructions and policies\n3. **Document DB** stores the content items being processed\n4. **A2A** delegates analysis to a specialized agent\n5. **HITL** pauses for human approval before publishing\n6. **Messaging** notifies stakeholders of the outcome\n7. **Schedule** ensures the cycle continues autonomously\n</code></pre>"},{"location":"concepts/scheduling/","title":"Scheduling Concepts","text":""},{"location":"concepts/scheduling/#what-are-schedules","title":"What Are Schedules?","text":"<p>Schedules are cron jobs for AI agents. They let your workflows execute on time-based triggers - daily reports at 9 AM, hourly health checks, weekly analytics, or any recurring task your agents need to handle.</p> <p>Unlike traditional cron jobs, Xians schedules are:</p> <ul> <li>Durable - Survive restarts and failures</li> <li>Multi-tenant aware - Automatic isolation per tenant</li> <li>Workflow-native - Fully deterministic when used inside workflows</li> <li>Production-ready - Built-in retries, timeouts, and overlap policies</li> </ul> <p>Powered by Temporal Schedules, wrapped in a fluent API that feels natural to use.</p>"},{"location":"concepts/scheduling/#why-scheduling","title":"Why Scheduling?","text":"<p>AI agents need to be proactive, not just reactive. Schedules let your agents:</p> <ul> <li>Run daily data syncs without manual triggers</li> <li>Generate morning briefings automatically</li> <li>Perform background research on a schedule</li> <li>Monitor systems at regular intervals</li> <li>Orchestrate recurring business processes</li> </ul> <p>The key insight: Workflows that schedule themselves are autonomous. They control their own timing, create follow-up work, and operate continuously without external coordination.</p>"},{"location":"concepts/scheduling/#quick-start","title":"Quick Start","text":"<p>Here's a workflow that schedules itself to run every day at 9 AM:</p> C#<pre><code>[Workflow(\"Daily Report Workflow\")]\npublic class DailyReportWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string reportType)\n    {\n        // Do the work\n        await GenerateReport(reportType);\n\n        // Schedule next run (idempotent - safe to call repeatedly)\n        var schedule = await XiansContext.CurrentAgent.Schedules\n            .Create&lt;DailyReportWorkflow&gt;(\"daily-report\")\n            .Daily(hour: 9, timezone: \"America/New_York\")\n            .WithInput(reportType)\n            .SkipIfRunning()\n            .CreateIfNotExistsAsync(); // Returns existing or creates new\n    }\n}\n</code></pre> <p>That's it. The workflow runs, does its work, and schedules itself. Your agent is now autonomous.</p>"},{"location":"concepts/scheduling/#scheduling-options","title":"Scheduling Options","text":""},{"location":"concepts/scheduling/#time-based-schedules","title":"Time-Based Schedules","text":"C#<pre><code>// Daily at specific time (timezone-aware)\n.Daily(hour: 9, timezone: \"America/New_York\")\n\n// Hourly at specific minute\n.Hourly(minute: 30)\n\n// Weekdays only\n.Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n\n// Weekly on specific day\n.Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n\n// Monthly\n.Monthly(dayOfMonth: 1, hour: 8, timezone: \"Asia/Tokyo\")\n</code></pre>"},{"location":"concepts/scheduling/#interval-based-schedules","title":"Interval-Based Schedules","text":"C#<pre><code>// Fixed intervals (no timezone - duration-based)\n.EverySeconds(30)\n.EveryMinutes(15)\n.EveryHours(2)\n.EveryDays(3)  // Note: Multi-day intervals (&gt;1) ignore hour/minute parameters\n\n// Multi-day intervals with specific time (only works for 1 day)\n.EveryDays(1, hour: 9, minute: 30, timezone: \"America/New_York\") // Same as .Daily()\n</code></pre>"},{"location":"concepts/scheduling/#cron-expressions","title":"Cron Expressions","text":"C#<pre><code>// Every 2 hours\n.WithCronSchedule(\"0 */2 * * *\")\n\n// Weekdays at 9 AM ET\n.WithCronSchedule(\"0 9 * * 1-5\", timezone: \"America/New_York\")\n\n// First of month at midnight\n.WithCronSchedule(\"0 0 1 * *\", timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling/#one-time-execution","title":"One-Time Execution","text":"C#<pre><code>// Specific future date/time\nvar futureDate = new DateTime(2026, 12, 25, 9, 0, 0);\n.WithCalendarSchedule(futureDate, timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling/#overlap-policies","title":"Overlap Policies","text":"<p>What happens when a schedule triggers but the previous execution is still running?</p> C#<pre><code>.SkipIfRunning()      // Skip new run (recommended for most cases)\n.AllowOverlap()       // Allow concurrent executions\n.BufferOne()          // Queue one execution for after current\n.CancelOther()        // Cancel running, start new\n.TerminateOther()     // Force stop running (use with caution)\n</code></pre> <p>Recommendation: Use <code>.SkipIfRunning()</code> by default. It prevents execution pile-up when workflows take longer than the schedule interval.</p>"},{"location":"concepts/scheduling/#creation-methods","title":"Creation Methods","text":"<p>Choose the right method for your use case:</p> C#<pre><code>// 1. CreateIfNotExistsAsync() - Idempotent (recommended)\n// Returns existing schedule or creates new one. Safe to call repeatedly.\nvar schedule = await XiansContext.CurrentAgent.Schedules\n    .Create&lt;MyWorkflow&gt;(\"my-schedule\")\n    .Daily(hour: 9)\n    .CreateIfNotExistsAsync();\n\n// 2. CreateAsync() - Strict\n// Fails if schedule exists. Use when you need to guarantee a new schedule.\nvar schedule = await XiansContext.CurrentAgent.Schedules\n    .Create&lt;MyWorkflow&gt;(\"unique-schedule\")\n    .EveryHours(2)\n    .CreateAsync(); // Throws ScheduleAlreadyExistsException if exists\n\n// 3. RecreateAsync() - Replace\n// Deletes existing and creates new. Use when updating schedule configuration.\nvar schedule = await XiansContext.CurrentAgent.Schedules\n    .Create&lt;MyWorkflow&gt;(\"my-schedule\")\n    .EveryMinutes(30) // Changed from every hour!\n    .RecreateAsync(); // Deletes old, creates new\n</code></pre> <p>Rule of thumb: Use <code>CreateIfNotExistsAsync()</code> unless you have a specific reason not to.</p>"},{"location":"concepts/scheduling/#managing-schedules","title":"Managing Schedules","text":"<p>Full lifecycle control from within workflows:</p> C#<pre><code>var agent = XiansContext.CurrentAgent;\n\n// Get existing schedule\nvar schedule = await agent.Schedules.GetAsync(\"my-schedule\");\n\n// Check if schedule exists\nbool exists = await agent.Schedules.ExistsAsync(\"my-schedule\");\n\n// Pause/resume schedules\nawait schedule.PauseAsync(\"System maintenance\");\nawait schedule.UnpauseAsync(\"Maintenance complete\");\n\n// Or pause/unpause by ID directly\nawait agent.Schedules.PauseAsync(\"my-schedule\", note: \"System maintenance\");\nawait agent.Schedules.UnpauseAsync(\"my-schedule\", note: \"Maintenance complete\");\n\n// Trigger immediate run (doesn't affect schedule)\nawait schedule.TriggerAsync();\nawait agent.Schedules.TriggerAsync(\"my-schedule\"); // Or by ID\n\n// Get schedule information\nvar description = await schedule.DescribeAsync(); // Contains next run times, recent actions, etc.\n\n// Delete schedule\nawait schedule.DeleteAsync();\nawait agent.Schedules.DeleteAsync(\"my-schedule\"); // Or by ID\n\n// Update schedule configuration\nawait schedule.UpdateAsync(update =&gt; new ScheduleUpdate(\n    update.Description.Schedule,\n    TypedSearchAttributes: newSearchAttributes));\n\n// Backfill schedule (run actions for past time periods)\nawait schedule.BackfillAsync(new[]\n{\n    new ScheduleBackfill(\n        startAt: DateTime.UtcNow.AddDays(-7), \n        endAt: DateTime.UtcNow.AddDays(-1))\n});\n\n// Get underlying Temporal handle for advanced scenarios\nvar temporalHandle = schedule.GetHandle();\n</code></pre>"},{"location":"concepts/scheduling/#multi-tenant-isolation","title":"Multi-Tenant Isolation","text":"<p>Schedules automatically respect tenant boundaries - zero configuration required:</p> C#<pre><code>[Workflow(\"Multi-Tenant Task\")]\npublic class TenantTaskWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        // Schedule automatically scoped to current tenant\n        await XiansContext.CurrentAgent.Schedules\n            .Create&lt;TenantTaskWorkflow&gt;(\"daily-task\")  // Internal ID: \"{tenantId}:{agentName}:{idPostfix}:daily-task\"\n            .Daily(hour: 9)\n            .CreateIfNotExistsAsync();\n    }\n}\n</code></pre> <p>What you get:</p> <ul> <li>Schedules prefixed with tenant ID and agent context internally</li> <li>Search attributes automatically inherited from parent workflow</li> <li>Cross-tenant access blocked automatically</li> <li>No manual tenant filtering needed</li> <li>Schedule IDs follow pattern: <code>{tenantId}:{agentName}:{idPostfix}:{scheduleId}</code></li> </ul>"},{"location":"concepts/scheduling/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/scheduling/#self-scheduling-workflow-recommended","title":"Self-Scheduling Workflow (Recommended)","text":"<p>Workflows that create their own recurring schedules:</p> C#<pre><code>[Workflow(\"Content Crawler\")]\npublic class ContentCrawlerWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string url, int intervalHours)\n    {\n        // Do the work\n        var content = await CrawlContent(url);\n        await ProcessContent(content);\n\n        // Schedule next run (idempotent)\n        await XiansContext.CurrentAgent.Schedules\n            .Create&lt;ContentCrawlerWorkflow&gt;($\"crawler-{url}\")\n            .EveryHours(intervalHours)\n            .WithInput(url, intervalHours)\n            .SkipIfRunning()\n            .CreateIfNotExistsAsync();\n    }\n}\n</code></pre> <p>Why this works well:</p> <ul> <li>Workflow controls its own timing</li> <li>Automatic determinism (SDK uses activities internally)</li> <li>Tenant context always available</li> <li>Clean separation of concerns</li> </ul>"},{"location":"concepts/scheduling/#bulk-schedule-creation","title":"Bulk Schedule Creation","text":"<p>Set up schedules for multiple entities:</p> C#<pre><code>[Workflow(\"Research Setup\")]\npublic class ResearchSetupWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string[] companies)\n    {\n        foreach (var company in companies)\n        {\n            await XiansContext.CurrentAgent.Schedules\n                .Create&lt;ResearchWorkflow&gt;($\"research-{company.ToLower()}\")\n                .Weekdays(hour: 8, timezone: \"America/New_York\")\n                .WithInput(company)\n                .SkipIfRunning()\n                .CreateIfNotExistsAsync();\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/scheduling/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"concepts/scheduling/#starting-schedules-paused","title":"Starting Schedules Paused","text":"<p>Sometimes you want to create a schedule but not start it immediately:</p> C#<pre><code>var schedule = await XiansContext.CurrentAgent.Schedules\n    .Create&lt;MaintenanceWorkflow&gt;(\"maintenance-task\")\n    .Daily(hour: 2, timezone: \"America/New_York\")\n    .WithInput(\"system-cleanup\")\n    .StartPaused(true, \"Created for future use\")\n    .CreateIfNotExistsAsync();\n\n// Later, unpause when ready\nawait schedule.UnpauseAsync(\"Ready to start maintenance\");\n</code></pre>"},{"location":"concepts/scheduling/#custom-idpostfix","title":"Custom idPostfix","text":"<p>The <code>idPostfix</code> parameter provides additional uniqueness to schedule IDs within the same tenant/agent context:</p> C#<pre><code>// Use custom idPostfix - requires non-generic overload\nvar workflowType = XiansContext.GetWorkflowTypeFor(typeof(SyncWorkflow));\nvar schedule = await XiansContext.CurrentAgent.Schedules\n    .Create(\"daily-sync\", workflowType, idPostfix: \"user123\")  // Results in: {tenantId}:{agent}:user123:daily-sync\n    .Daily(hour: 9)\n    .CreateIfNotExistsAsync();\n\n// Retrieve with same idPostfix\nvar retrieved = await XiansContext.CurrentAgent.Schedules.GetAsync(\"daily-sync\", idPostfix: \"user123\");\n</code></pre> <p>Note: If not specified, <code>idPostfix</code> defaults to the current workflow context's idPostfix. The generic <code>Create&lt;TWorkflow&gt;()</code> method uses the default idPostfix; use the non-generic overload for custom idPostfix values.</p>"},{"location":"concepts/scheduling/#calendar-based-scheduling","title":"Calendar-Based Scheduling","text":"<p>For one-time or specific date scheduling:</p> C#<pre><code>// Schedule for a specific future date/time\nvar futureDate = new DateTime(2026, 12, 25, 9, 0, 0);\nvar schedule = await XiansContext.CurrentAgent.Schedules\n    .Create&lt;HolidayReportWorkflow&gt;(\"holiday-report\")\n    .WithCalendarSchedule(futureDate, timezone: \"America/New_York\")\n    .WithInput(\"holiday-summary\")\n    .CreateIfNotExistsAsync();\n</code></pre>"},{"location":"concepts/scheduling/#low-level-temporal-integration","title":"Low-Level Temporal Integration","text":"<p>For advanced scenarios, you can access the underlying Temporal schedule handle:</p> C#<pre><code>var schedule = await XiansContext.CurrentAgent.Schedules.GetAsync(\"my-schedule\");\nvar temporalHandle = schedule.GetHandle();\n\n// Use native Temporal APIs\nvar temporalDescription = await temporalHandle.DescribeAsync();\n</code></pre>"},{"location":"concepts/scheduling/#error-handling","title":"Error Handling","text":"<p>The SDK provides specific exceptions for different error scenarios:</p> C#<pre><code>try\n{\n    var schedule = await XiansContext.CurrentAgent.Schedules\n        .Create&lt;MyWorkflow&gt;(\"my-schedule\")\n        .Daily(hour: 9)\n        .CreateAsync(); // Strict creation\n}\ncatch (ScheduleAlreadyExistsException ex)\n{\n    // Handle case where schedule already exists\n    var existing = await XiansContext.CurrentAgent.Schedules.GetAsync(\"my-schedule\");\n    // ... use existing schedule\n}\ncatch (ScheduleNotFoundException ex)\n{\n    // Handle case where schedule wasn't found during GetAsync()\n    Console.WriteLine($\"Schedule '{ex.ScheduleId}' not found\");\n}\ncatch (InvalidScheduleSpecException ex)\n{\n    // Handle invalid schedule configuration\n    Console.WriteLine($\"Invalid schedule configuration: {ex.Message}\");\n}\n</code></pre>"},{"location":"concepts/scheduling/#best-practices","title":"Best Practices","text":"<p>Do:</p> <ul> <li>Use <code>CreateIfNotExistsAsync()</code> for most cases (idempotent)</li> <li>Use <code>.SkipIfRunning()</code> to prevent execution pile-up</li> <li>Add retry policies for production schedules</li> <li>Specify timezones for time-based schedules</li> <li>Use descriptive IDs: <code>daily-sync-{company}</code> not <code>schedule1</code></li> <li>Handle schedule-specific exceptions appropriately</li> </ul> <p>Don't:</p> <ul> <li>Use <code>CreateAsync()</code> unless you need strict failure on duplicates</li> <li>Forget to handle timezone differences</li> <li>Create schedules without overlap policies</li> <li>Use generic schedule IDs</li> <li>Ignore specific exception types - they provide valuable context</li> </ul>"},{"location":"concepts/scheduling/#quick-reference","title":"Quick Reference","text":""},{"location":"concepts/scheduling/#schedule-patterns","title":"Schedule Patterns","text":"C#<pre><code>// Time-based patterns\n.Daily(hour: 9, timezone: \"America/New_York\")\n.Hourly(minute: 30)\n.Weekdays(hour: 8, minute: 30, timezone: \"America/Chicago\")\n.Weekly(DayOfWeek.Monday, hour: 10, timezone: \"Europe/London\")\n.Monthly(dayOfMonth: 1, hour: 9, timezone: \"America/New_York\")\n\n// Interval-based patterns\n.EverySeconds(30)\n.EveryMinutes(15)\n.EveryHours(2)\n.EveryDays(3)\n\n// Advanced patterns\n.WithCronSchedule(\"0 */2 * * *\", timezone: \"UTC\")  // Every 2 hours\n.WithCalendarSchedule(futureDateTime, timezone: \"America/New_York\")\n</code></pre>"},{"location":"concepts/scheduling/#creation-methods_1","title":"Creation Methods","text":"C#<pre><code>.CreateIfNotExistsAsync()  // Idempotent (recommended)\n.CreateAsync()             // Strict (fails if exists)\n.RecreateAsync()          // Replace existing\n</code></pre>"},{"location":"concepts/scheduling/#overlap-policies_1","title":"Overlap Policies","text":"C#<pre><code>.SkipIfRunning()    // Skip if previous still running (recommended)\n.AllowOverlap()     // Allow concurrent executions\n.BufferOne()        // Queue one execution\n.CancelOther()      // Cancel running, start new\n.TerminateOther()   // Force stop running (use with caution)\n</code></pre>"},{"location":"concepts/scheduling/#management-operations","title":"Management Operations","text":"C#<pre><code>// Direct schedule operations\nawait schedule.PauseAsync(\"reason\");\nawait schedule.UnpauseAsync(\"reason\");\nawait schedule.TriggerAsync();\nawait schedule.DeleteAsync();\nawait schedule.DescribeAsync();\n\n// Operations by ID\nawait schedules.GetAsync(\"schedule-id\");\nawait schedules.ExistsAsync(\"schedule-id\");\nawait schedules.PauseAsync(\"schedule-id\");\nawait schedules.UnpauseAsync(\"schedule-id\");\nawait schedules.TriggerAsync(\"schedule-id\");\nawait schedules.DeleteAsync(\"schedule-id\");\n</code></pre>"},{"location":"concepts/scheduling/#whats-next","title":"What's Next?","text":"<ul> <li>Agents - Agent architecture and patterns</li> <li>Workflows - Workflow patterns and lifecycle</li> </ul> <p>Bottom line: Schedules turn reactive workflows into autonomous agents. They're the difference between \"run this when I tell you\" and \"run this every day at 9 AM until I tell you to stop.\"</p>"},{"location":"concepts/sdk-patterns/","title":"SDK Access Patterns","text":"<p>The Xians SDK is designed around explicit ownership\u2014every operation is accessed through its logical owner. No confusion, no guessing. Just four simple access patterns that cover everything.</p>"},{"location":"concepts/sdk-patterns/#quick-reference","title":"Quick Reference","text":"Access Pattern What It's For Available In Common Examples <code>UserMessageContext</code> Message-specific operations Message handlers only <code>context.ReplyAsync()</code><code>context.GetChatHistoryAsync()</code> <code>CurrentAgent</code> Agent-level data All workflows <code>XiansContext.CurrentAgent.Knowledge.SearchAsync()</code><code>XiansContext.CurrentAgent.Documents.SaveAsync()</code> <code>CurrentWorkflow</code> Workflow-level operations All workflows <code>XiansContext.CurrentWorkflow.Schedules.Create()</code><code>XiansContext.CurrentWorkflow.WorkflowId</code> <code>XiansContext</code> Cross-cutting orchestration All workflows <code>XiansContext.Messaging.SendChatAsync()</code><code>XiansContext.A2A.SendChatAsync()</code><code>XiansContext.Workflows.StartAsync&lt;T&gt;()</code><code>XiansContext.GetAgent()</code> / <code>GetWorkflow()</code>"},{"location":"concepts/sdk-patterns/#the-four-access-patterns","title":"The Four Access Patterns","text":""},{"location":"concepts/sdk-patterns/#1-usermessagecontext--for-message-specific-operations","title":"1. UserMessageContext \u2192 For Message-Specific Operations","text":"<p>When handling user messages in built-in workflows, use the <code>UserMessageContext</code> parameter for message-specific operations.</p> C#<pre><code>conversationalWorkflow.OnUserChatMessage(async (context) =&gt; \n{\n    // Message metadata\n    var userId = context.Message.ParticipantId;\n    var threadId = context.Message.ThreadId;\n\n    // Reply to THIS message\n    await context.ReplyAsync(\"Response\");\n\n    // Get THIS conversation's history\n    var history = await context.GetChatHistoryAsync();\n\n    // A2A communication\n    var targetWorkflow = XiansContext.GetWorkflow(\"Agent:Workflow\");\n    var response = await XiansContext.A2A.SendChatAsync(\n        targetWorkflow, \n        new A2AMessage { Text = \"message\" }\n    );\n});\n</code></pre> <p>When: Inside built-in workflow message handlers only Use for: Replying, conversation history, message metadata, contextual A2A</p>"},{"location":"concepts/sdk-patterns/#2-currentagent--for-agent-level-data","title":"2. CurrentAgent \u2192 For Agent-Level Data","text":"<p>Access knowledge and documents\u2014data that belongs to your agent across all workflows.</p> C#<pre><code>// Search agent's knowledge base\nvar results = await XiansContext.CurrentAgent.Knowledge.SearchAsync(\"query\");\n\n// Store agent-wide documents\nawait XiansContext.CurrentAgent.Documents.SaveAsync(new Document\n{\n    Type = \"user-preferences\",\n    Key = \"user-123\",\n    Content = JsonSerializer.SerializeToElement(data)\n});\n</code></pre> <p>When: Any workflow (built-in or custom) Use for: Knowledge search, document storage, agent metadata</p>"},{"location":"concepts/sdk-patterns/#3-currentworkflow--for-workflow-level-operations","title":"3. CurrentWorkflow \u2192 For Workflow-Level Operations","text":"<p>Access schedules and workflow-specific information.</p> C#<pre><code>// Create a schedule for THIS workflow\nawait XiansContext.CurrentWorkflow.Schedules!\n    .Create(\"daily-report\")\n    .Daily(hour: 9, minute: 0)\n    .WithInput(\"user-123\")\n    .StartAsync();\n\n// Get workflow metadata\nvar workflowId = XiansContext.CurrentWorkflow.WorkflowId;\nvar taskQueue = XiansContext.CurrentWorkflow.TaskQueue;\n</code></pre> <p>When: Any workflow (built-in or custom) Use for: Schedules, workflow identity, task queue info</p>"},{"location":"concepts/sdk-patterns/#4-xianscontext--for-cross-cutting-operations","title":"4. XiansContext \u2192 For Cross-Cutting Operations","text":"<p>Access orchestration features\u2014messaging, sub-workflows, and agent/workflow discovery.</p> C#<pre><code>// Start a sub-workflow\nawait XiansContext.Workflows.StartAsync&lt;NotificationWorkflow&gt;(\n    idPostfix: \"notify-123\",\n    args: new object[] { \"user-123\", \"message\" }\n);\n\n// Send proactive message to any user\nawait XiansContext.Messaging.SendChatAsync(\n    participantId: \"user-456\",\n    text: \"Your order shipped!\"\n);\n\n// A2A communication\nvar analyzer = XiansContext.GetWorkflow(\"Analyzer:Process\");\nvar result = await XiansContext.A2A.SendChatAsync(\n    analyzer,\n    new A2AMessage { Text = \"Analyze this content\" }\n);\n\n// Discover agents and workflows\nvar allAgents = XiansContext.GetAllAgents();\nvar tenant = XiansContext.TenantId;\n</code></pre> <p>When: Any workflow (built-in or custom) Use for: Proactive messaging, A2A, sub-workflows, agent/workflow registry</p>"},{"location":"concepts/sdk-patterns/#design-philosophy","title":"Design Philosophy","text":"<p>Explicit ownership. Every SDK feature is accessed through its logical owner:</p> <ul> <li>UserMessageContext owns reply operations</li> <li>Agent owns knowledge and documents</li> <li>Workflow owns schedules</li> <li>XiansContext orchestrates everything else</li> </ul>"},{"location":"concepts/unit-tests/","title":"Unit Testing Temporal Workflows with Xians","text":"<p>Run your Temporal workflows in isolation\u2014no server, no network, just fast, deterministic tests. This guide shows you how to combine Temporal's time-skipping test environment with Xians Local Mode to unit test workflows that use knowledge.</p>"},{"location":"concepts/unit-tests/#why-this-matters","title":"Why This Matters","text":"<p>Workflows orchestrate activities, retries, and long-running logic. Testing them end-to-end against a real Temporal server is slow and flaky. Unit testing with Temporal's built-in time-skipping environment lets you:</p> <ul> <li>Execute workflows in-process with mocked time</li> <li>Resolve knowledge from embedded resources (no server calls)</li> <li>Assert on workflow results in milliseconds</li> <li>Run in CI without Docker or external services</li> </ul> <p>Note: Unit testing currently supports Logs and Knowledge usage out of the box. If your workflows or activities use other Xians functionality\u2014such as DocumentDb, Tasks, or Messaging\u2014you must abstract those dependencies behind interfaces and mock them in tests. Inject the abstractions into your activities so tests can supply fake implementations.</p>"},{"location":"concepts/unit-tests/#architecture-at-a-glance","title":"Architecture at a Glance","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Test Class (IClassFixture&lt;EnvFixture&gt;)                         \u2502\n\u2502  \u251c\u2500\u2500 EnvFixture: XiansPlatform.InitializeForTestsAsync()        \u2502\n\u2502  \u251c\u2500\u2500 EnvFixture: Register agent + Upload workflow definitions   \u2502\n\u2502  \u2514\u2500\u2500 Temporal: WorkflowEnvironment.StartTimeSkippingAsync()     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  TemporalWorker                                                 \u2502\n\u2502  \u251c\u2500\u2500 AddWorkflow&lt;YourWorkflow&gt;()                                \u2502\n\u2502  \u2514\u2500\u2500 AddAllActivities(new YourActivities(...))                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  YourWorkflow  \u2500\u2500\u25ba  YourActivities  \u2500\u2500\u25ba  XiansContext.CurrentAgent \u2502\n\u2502                                              .Knowledge.GetAsync() \u2502\n\u2502                                              (from embedded DLLs)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/unit-tests/#quick-setup-a-minimal-example","title":"Quick Setup: A Minimal Example","text":"<p>We'll use a greeting workflow that reads a greeting template from Xians knowledge and returns a personalized message.</p>"},{"location":"concepts/unit-tests/#1-embed-knowledge-in-your-main-project","title":"1. Embed Knowledge in Your Main Project","text":"<p>Knowledge is loaded by searching inside DLLs. Xians looks for embedded resources in loaded assemblies using naming conventions. You must embed your knowledge files in the agent project's output assembly.</p> <p>In your agent <code>.csproj</code> (e.g. <code>my-agent.csproj</code>):</p> XML<pre><code>&lt;ItemGroup&gt;\n  &lt;!-- Embed JSON and Markdown for knowledge lookup --&gt;\n  &lt;EmbeddedResource Include=\"**\\*.json\" /&gt;\n  &lt;EmbeddedResource Include=\"**\\*.md\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>Place your knowledge file under a folder, e.g. <code>Knowledge/greeting-config.json</code>:</p> JSON<pre><code>{\n  \"greeting\": \"Hello\",\n  \"punctuation\": \"!\"\n}\n</code></pre> <p>The embedded resource will be named something like <code>my_agent.Knowledge.greeting-config.json</code>. Xians' Local Mode searches all non-system assemblies for manifest resources matching either:</p> <ul> <li>Strict convention: <code>{AgentName}.Knowledge.{KnowledgeName}.{extension}</code></li> <li>Fallback: Any resource ending with <code>.{normalized-name}.{extension}</code> (e.g. <code>.greeting-config.json</code>)</li> </ul> <p>So as long as your file name matches the knowledge name you use in code (normalized: spaces \u2192 hyphens, lowercased), it will be found.</p>"},{"location":"concepts/unit-tests/#2-define-the-workflow-and-activity","title":"2. Define the Workflow and Activity","text":"<p><code>GreetingWorkflow.cs</code></p> C#<pre><code>using Temporalio.Exceptions;\nusing Temporalio.Workflows;\n\n[Workflow(\"MyAgent:Greeting Workflow\")]\npublic class GreetingWorkflow\n{\n    private static readonly ActivityOptions Options = new()\n    {\n        StartToCloseTimeout = TimeSpan.FromMinutes(1),\n    };\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(string userName)\n    {\n        var template = await Workflow.ExecuteActivityAsync(\n            (GreetingActivities a) =&gt; a.GetGreetingTemplateAsync(),\n            Options);\n\n        return $\"{template} {userName}!\";\n    }\n}\n</code></pre> <p><code>GreetingActivities.cs</code></p> C#<pre><code>using Temporalio.Activities;\nusing Xians.Lib.Agents.Core;\n\npublic class GreetingActivities\n{\n    [Activity]\n    public async Task&lt;string&gt; GetGreetingTemplateAsync()\n    {\n        var knowledge = await XiansContext.CurrentAgent.Knowledge.GetAsync(\"Greeting Config\");\n        if (knowledge == null)\n            throw new ApplicationFailureException(\"Greeting Config not found in knowledge base.\");\n\n        var config = JsonSerializer.Deserialize&lt;GreetingConfig&gt;(knowledge.Content);\n        return config?.Greeting ?? \"Hello\";\n    }\n}\n\npublic record GreetingConfig(string Greeting, string Punctuation);\n</code></pre> <p>Your knowledge name <code>\"Greeting Config\"</code> normalizes to <code>greeting-config</code>, so a file <code>greeting-config.json</code> will be matched by the fallback.</p>"},{"location":"concepts/unit-tests/#3-create-the-test-fixture","title":"3. Create the Test Fixture","text":"<p><code>EnvFixture.cs</code> (shared across workflow test classes):</p> C#<pre><code>using DotNetEnv;\nusing Temporalio.Testing;\nusing Xians.Lib.Agents.Core;\n\npublic class EnvFixture : IDisposable, Xunit.IAsyncLifetime\n{\n    public EnvFixture() =&gt; LoadEnv();\n\n    public async Task InitializeAsync()\n    {\n        var xiansPlatform = await XiansPlatform.InitializeForTestsAsync();\n        var agent = xiansPlatform.Agents.Register(new XiansAgentRegistration\n        {\n            Name = \"MyAgent\",\n            IsTemplate = false,\n        });\n        await agent.UploadWorkflowDefinitionsAsync();\n    }\n\n    private static void LoadEnv()\n    {\n        // Load .env from project root or sibling for API keys if needed\n        var baseDir = AppContext.BaseDirectory;\n        var envPath = Path.Combine(baseDir, \"..\", \"..\", \"..\", \".env\");\n        if (File.Exists(Path.GetFullPath(envPath)))\n            Env.Load(Path.GetFullPath(envPath));\n    }\n\n    public async Task&lt;(WorkflowEnvironment Env, string TaskQueue)&gt; CreateTemporalEnvAsync()\n    {\n        var env = await WorkflowEnvironment.StartTimeSkippingAsync();\n        return (env, $\"task-queue-{Guid.NewGuid()}\");\n    }\n\n    public void Dispose() =&gt; GC.SuppressFinalize(this);\n}\n</code></pre>"},{"location":"concepts/unit-tests/#4-write-the-unit-test","title":"4. Write the Unit Test","text":"<p><code>GreetingWorkflowTests.cs</code></p> C#<pre><code>using Temporalio.Client;\nusing Temporalio.Testing;\nusing Temporalio.Worker;\nusing Xians.Lib.Common.Infrastructure;\nusing Xunit;\n\n[Trait(\"Category\", \"Workflow\")]\npublic class GreetingWorkflowTests : IClassFixture&lt;EnvFixture&gt;, IDisposable\n{\n    private readonly WorkflowEnvironment _env;\n    private readonly string _taskQueue;\n    private readonly TemporalWorker _worker;\n\n    public GreetingWorkflowTests(EnvFixture fixture)\n    {\n        var (env, taskQueue) = fixture.CreateTemporalEnvAsync().GetAwaiter().GetResult();\n        _env = env;\n        _taskQueue = taskQueue;\n        _worker = new TemporalWorker(\n            env.Client,\n            new TemporalWorkerOptions(taskQueue)\n            {\n                LoggerFactory = LoggerFactory.CreateLoggerFactoryWithApiLogging(enableApiLogging: false),\n            }\n                .AddWorkflow&lt;GreetingWorkflow&gt;()\n                .AddAllActivities(new GreetingActivities()));\n    }\n\n    [Fact]\n    public async Task RunAsync_WithUserName_ReturnsGreeting()\n    {\n        await _worker.ExecuteAsync(async () =&gt;\n        {\n            var result = await _env.Client.ExecuteWorkflowAsync(\n                (GreetingWorkflow wf) =&gt; wf.RunAsync(\"Alice\"),\n                new(id: $\"wf-{Guid.NewGuid()}\", taskQueue: _taskQueue));\n\n            Assert.Equal(\"Hello Alice!\", result);\n        });\n    }\n\n    public void Dispose()\n    {\n        _worker.Dispose();\n        _env.DisposeAsync().AsTask().GetAwaiter().GetResult();\n        GC.SuppressFinalize(this);\n    }\n}\n</code></pre>"},{"location":"concepts/unit-tests/#how-knowledge-discovery-works","title":"How Knowledge Discovery Works","text":"<p>When your activity calls <code>XiansContext.CurrentAgent.Knowledge.GetAsync(\"Greeting Config\")</code> in Local Mode:</p> <ol> <li>XiansPlatform.InitializeForTestsAsync() sets <code>LocalMode = true</code>, so no HTTP or Temporal server is used.</li> <li>The LocalKnowledgeProvider resolves knowledge by:</li> <li>Searching the in-memory store first (for knowledge uploaded via <code>UploadEmbeddedResourceAsync</code> during setup).</li> <li>Falling back to embedded resources in all loaded assemblies.</li> <li>It scans <code>Assembly.GetManifestResourceNames()</code> in each non-system assembly.</li> <li>It matches resources by:</li> <li>Strict: <code>{AgentName}.Knowledge.{KnowledgeName}.{ext}</code></li> <li>Fallback: any resource ending with <code>.{normalized-name}.{ext}</code> (e.g. <code>.greeting-config.json</code>).</li> </ol> <p>Because your test project references your agent project, the agent DLL is loaded and its embedded resources are searchable. Embedding in the agent <code>.csproj</code> ensures the knowledge travels with the assembly.</p> <ul> <li><code>\"Greeting Config\"</code> \u2192 normalizes to <code>greeting-config</code> \u2192 matches <code>*.greeting-config.json</code></li> <li><code>\"Article Extraction Schema\"</code> \u2192 normalizes to <code>article-extraction-schema</code> \u2192 matches <code>*.article-extraction-schema.json</code></li> </ul>"},{"location":"concepts/unit-tests/#checklist","title":"Checklist","text":"<ul> <li> Add <code>&lt;EmbeddedResource Include=\"**\\*.json\" /&gt;</code> (and <code>**\\*.md</code> if needed) to your agent <code>.csproj</code>.</li> <li> Use <code>XiansPlatform.InitializeForTestsAsync()</code> in your fixture's <code>InitializeAsync</code>.</li> <li> Register the agent and call <code>UploadWorkflowDefinitionsAsync()</code>.</li> <li> Create a Temporal time-skipping env with <code>WorkflowEnvironment.StartTimeSkippingAsync()</code>.</li> <li> Build a <code>TemporalWorker</code> with your workflow and activities.</li> <li> Run <code>ExecuteWorkflowAsync</code> inside <code>_worker.ExecuteAsync</code>.</li> <li> Dispose the worker and environment in <code>Dispose</code>.</li> </ul>"},{"location":"concepts/unit-tests/#running-tests","title":"Running Tests","text":"Bash<pre><code># All workflow tests\ndotnet test --filter \"Category=Workflow\"\n\n# Specific test class\ndotnet test --filter \"FullyQualifiedName~GreetingWorkflowTests\"\n</code></pre>"},{"location":"concepts/unit-tests/#see-also","title":"See Also","text":"<ul> <li>Knowledge \u2013 Managing agent knowledge in production</li> </ul>"},{"location":"concepts/webhook/","title":"Webhooks","text":"<p>Webhooks enable external systems to trigger and interact with your agent workflows in real-time. Think of them as HTTP callbacks that let third-party services (payment processors, CRMs, monitoring systems, etc.) push events directly into your agent ecosystem.</p>"},{"location":"concepts/webhook/#quick-start","title":"Quick Start","text":""},{"location":"concepts/webhook/#1-register-a-webhook-handler","title":"1. Register a Webhook Handler","text":"<p>Built-in workflows can handle webhooks using the <code>OnWebhook()</code> method. You can use either a synchronous or async handler:</p>"},{"location":"concepts/webhook/#synchronous-handler-for-simple-non-async-operations","title":"Synchronous Handler (for simple, non-async operations)","text":"C#<pre><code>using DotNetEnv;\nusing System.Net;\nusing Xians.Lib.Agents.Core;\nusing Xians.Lib.Agents.Messaging;\n\n// Load environment variables\nEnv.Load();\n\nvar serverUrl = Environment.GetEnvironmentVariable(\"XIANS_SERVER_URL\") \n    ?? throw new InvalidOperationException(\"XIANS_SERVER_URL not found\");\nvar xiansApiKey = Environment.GetEnvironmentVariable(\"XIANS_API_KEY\") \n    ?? throw new InvalidOperationException(\"XIANS_API_KEY not found\");\n\n// Initialize platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey\n});\n\n// Register agent (system-scoped can handle webhooks across all tenants)\nvar xiansAgent = xiansPlatform.Agents.Register(new()\n{\n    Name = \"WebhookTestAgent\",\n    IsTemplate = true\n});\n\n// Define built-in workflow\nvar integratorWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Integrator\");\n\n// Handle incoming webhooks (synchronous)\nintegratorWorkflow.OnWebhook((context) =&gt;\n{\n    // Your webhook processing logic here\n    Console.WriteLine($\"Received: {context.Webhook.Name}\");\n    context.Respond(new { status = \"success\" });\n});\n\n// Start the agent\nawait xiansAgent.RunAllAsync();\n</code></pre>"},{"location":"concepts/webhook/#async-handler-when-you-need-async-operations","title":"Async Handler (when you need async operations)","text":"<p>Use the async version when you need to perform async operations like database calls, HTTP requests, etc.:</p> C#<pre><code>// Handle incoming webhooks (async)\nintegratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    // Perform async operations\n    var result = await ProcessWebhookAsync(context.Webhook.Payload);\n    context.Respond(new { status = \"success\", result });\n});\n</code></pre>"},{"location":"concepts/webhook/#2-call-your-webhook","title":"2. Call Your Webhook","text":"<p>Once your agent is running, send POST requests to:</p> Text Only<pre><code>POST {SERVER_URL}/api/user/webhooks/builtin\n</code></pre>"},{"location":"concepts/webhook/#required-query-parameters","title":"Required Query Parameters","text":"Parameter Description Example <code>apikey</code> Your Xians API key <code>sk-Xnai-abc123...</code> <code>agentName</code> The target agent name <code>WebhookTestAgent</code> <code>workflowName</code> The target workflow name <code>Integrator</code> <code>webhookName</code> Any identifier for this webhook event <code>Email Received</code> <code>participantId</code> Any User/participant identifier <code>user@example.com</code>"},{"location":"concepts/webhook/#optional-query-parameters","title":"Optional Query Parameters","text":"Parameter Description Example <code>activationName</code> Optional activation identifier to distinguish multiple instances <code>instance-1</code> <code>timeoutSeconds</code> Request timeout (default: 30s) <code>60</code> <code>scope</code> Custom scope for context (same as Chat messages) <code>tenant-123</code> <code>authorization</code> Auth token for your logic <code>Bearer jwt-token</code>"},{"location":"concepts/webhook/#request-body","title":"Request Body","text":"<p>Send your webhook payload as JSON in the request body:</p> JSON<pre><code>{\n  \"orderId\": \"12345\",\n  \"amount\": 99.99,\n  \"status\": \"completed\"\n}\n</code></pre>"},{"location":"concepts/webhook/#complete-examples","title":"Complete Examples","text":""},{"location":"concepts/webhook/#basic-webhook-call-with-curl","title":"Basic Webhook Call with cURL","text":"Bash<pre><code>curl -X POST \"http://localhost:5005/api/user/webhooks/builtin?apikey=sk-Xnai-zSsUNO5KaeyHefrWEyQvvyOBmX0&amp;timeoutSeconds=30&amp;agentName=WebhookTestAgent&amp;workflowName=Integrator&amp;webhookName=OrderCompleted&amp;participantId=customer@example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"orderId\": \"12345\", \"amount\": 99.99, \"status\": \"completed\"}'\n</code></pre>"},{"location":"concepts/webhook/#with-activation-name-for-multiple-instances","title":"With Activation Name (for multiple instances)","text":"<p>Use <code>activationName</code> to target specific workflow instances:</p> Bash<pre><code>curl -X POST \"http://localhost:5005/api/user/webhooks/builtin?apikey=sk-Xnai-abc123&amp;agentName=WebhookTestAgent&amp;workflowName=Integrator&amp;webhookName=OrderCompleted&amp;activationName=instance-1&amp;participantId=customer@example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"orderId\": \"12345\", \"amount\": 99.99, \"status\": \"completed\"}'\n</code></pre>"},{"location":"concepts/webhook/#with-scope-and-authorization","title":"With Scope and Authorization","text":"Bash<pre><code>curl -X POST \"http://localhost:5005/api/user/webhooks/builtin?apikey=sk-Xnai-abc123&amp;agentName=WebhookTestAgent&amp;workflowName=Integrator&amp;webhookName=OrderCompleted&amp;scope=tenant-123&amp;authorization=Bearer-token&amp;participantId=customer@example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"orderId\": \"12345\", \"amount\": 99.99, \"status\": \"completed\"}'\n</code></pre>"},{"location":"concepts/webhook/#using-postman","title":"Using Postman","text":"<ol> <li>Method: POST</li> <li>URL: <code>http://localhost:5005/api/user/webhooks/builtin</code></li> <li>Query Parameters:</li> <li><code>apikey</code>: <code>sk-Xnai-abc123</code></li> <li><code>agentName</code>: <code>WebhookTestAgent</code></li> <li><code>workflowName</code>: <code>Integrator</code></li> <li><code>webhookName</code>: <code>OrderCompleted</code></li> <li><code>participantId</code>: <code>customer@example.com</code></li> <li><code>activationName</code> (optional): <code>instance-1</code></li> <li><code>timeoutSeconds</code> (optional): <code>60</code></li> <li><code>scope</code> (optional): <code>tenant-123</code></li> <li><code>authorization</code> (optional): <code>Bearer jwt-token</code></li> <li>Headers:</li> <li><code>Content-Type</code>: <code>application/json</code></li> <li>Body (raw JSON):    JSON<pre><code>{\n  \"orderId\": \"12345\",\n  \"amount\": 99.99,\n  \"status\": \"completed\"\n}\n</code></pre></li> </ol>"},{"location":"concepts/webhook/#3-monitor-webhooks-in-the-ui","title":"3. Monitor Webhooks in the UI","text":"<p>All webhook messages are visible in the Messaging Playground in the Xians UI, just like chat and data messages. This provides full visibility into webhook execution, timing, and metadata.</p> <p></p> <p>In the Messaging Playground, you can:</p> <ul> <li>View webhook messages alongside other message types in the conversation view</li> <li>Inspect message details including:</li> <li>Message Type: <code>Webhook</code></li> <li>Webhook name and participant ID</li> <li>Request ID for tracking</li> <li>Scope and authorization data</li> <li>Complete payload data</li> <li>Execution status and timing</li> <li>Track conversations created by webhook invocations</li> <li>Debug webhook flows by observing the complete message history</li> </ul> <p>This makes it easy to monitor, debug, and audit webhook integrations without needing to add custom logging.</p>"},{"location":"concepts/webhook/#extracting-webhook-information","title":"Extracting Webhook Information","text":"<p>The <code>WebhookContext</code> provides access to all webhook data through the <code>Webhook</code> property:</p> C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    // Extract webhook metadata\n    var webhookName = context.Webhook.Name;           // \"OrderCompleted\"\n    var participantId = context.Webhook.ParticipantId; // \"customer@example.com\"\n    var scope = context.Webhook.Scope;                // \"tenant-123\"\n    var authorization = context.Webhook.Authorization; // \"Bearer-token\"\n    var requestId = context.Webhook.RequestId;        // Unique request ID\n    var tenantId = context.Webhook.TenantId;          // Tenant context\n\n    // Payload comes as a JSON string - deserialize it\n    if (context.Webhook.Payload is not string jsonString)\n    {\n        Console.WriteLine(\"Invalid payload type\");\n        return;\n    }\n\n    var payload = JsonSerializer.Deserialize&lt;OrderPayload&gt;(jsonString);\n    Console.WriteLine($\"Processing order {payload.OrderId} for ${payload.Amount}\");\n});\n\n// Define your payload type\npublic class OrderPayload\n{\n    public string OrderId { get; set; }\n    public decimal Amount { get; set; }\n    public string Status { get; set; }\n}\n</code></pre>"},{"location":"concepts/webhook/#available-webhook-properties","title":"Available Webhook Properties","text":"Property Type Description <code>Name</code> <code>string</code> Webhook name from query parameter <code>ParticipantId</code> <code>string</code> Participant identifier <code>Payload</code> <code>string?</code> Request body as JSON string (deserialize to use) <code>Scope</code> <code>string?</code> Optional scope context <code>Authorization</code> <code>string?</code> Optional auth token <code>RequestId</code> <code>string</code> Unique request identifier <code>TenantId</code> <code>string</code> Tenant context"},{"location":"concepts/webhook/#responding-to-webhooks","title":"Responding to Webhooks","text":"<p>You have three ways to respond, all with full control over HTTP status codes, headers, and content.</p>"},{"location":"concepts/webhook/#option-1-simple-object-response","title":"Option 1: Simple Object Response","text":"<p>Perfect for straightforward JSON responses:</p> C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    // Process webhook...\n\n    // Respond with an object (auto-serialized to JSON)\n    context.Respond(new \n    { \n        message = \"Success\", \n        processedAt = DateTime.UtcNow \n    });\n});\n</code></pre>"},{"location":"concepts/webhook/#option-2-full-control-response","title":"Option 2: Full Control Response","text":"<p>For custom status codes, headers, and content types:</p> C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    context.Response = new WebhookResponse\n    {\n        StatusCode = HttpStatusCode.OK,\n        Content = \"{\\\"message\\\": \\\"Success\\\", \\\"id\\\": \\\"12345\\\"}\",\n        ContentType = \"application/json\",\n        Headers = new Dictionary&lt;string, string[]&gt;\n        {\n            [\"X-Custom-Header\"] = new[] { \"CustomValue\" },\n            [\"X-Request-Id\"] = new[] { context.Webhook.RequestId }\n        }\n    };\n});\n</code></pre>"},{"location":"concepts/webhook/#option-3-static-factory-methods","title":"Option 3: Static Factory Methods","text":"<p>Convenient helpers for common responses:</p> C#<pre><code>integratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    try\n    {\n        // Process webhook...\n        var result = await ProcessOrderAsync(context.Webhook.Payload);\n\n        // Success response\n        context.Response = WebhookResponse.Ok(new \n        { \n            success = true, \n            orderId = result.OrderId \n        });\n    }\n    catch (ValidationException ex)\n    {\n        // Bad request (400)\n        context.Response = WebhookResponse.BadRequest(ex.Message);\n    }\n    catch (NotFoundException ex)\n    {\n        // Not found (404)\n        context.Response = WebhookResponse.NotFound(ex.Message);\n    }\n    catch (Exception ex)\n    {\n        // Internal server error (500)\n        context.Response = WebhookResponse.InternalServerError(\n            $\"Failed to process webhook: {ex.Message}\");\n    }\n});\n</code></pre>"},{"location":"concepts/webhook/#available-factory-methods","title":"Available Factory Methods","text":"Method Status Code Description <code>WebhookResponse.Ok(object)</code> 200 Success with JSON data <code>WebhookResponse.Ok(string)</code> 200 Success with custom content <code>WebhookResponse.BadRequest(message)</code> 400 Validation/client error <code>WebhookResponse.NotFound(message)</code> 404 Resource not found <code>WebhookResponse.InternalServerError(message)</code> 500 Server error <code>WebhookResponse.Error(code, message)</code> Custom Custom status code"},{"location":"concepts/webhook/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/webhook/#authentication--authorization","title":"Authentication &amp; Authorization","text":"C#<pre><code>integratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    // Verify authorization token\n    var authToken = context.Webhook.Authorization;\n    if (string.IsNullOrEmpty(authToken) || !await ValidateTokenAsync(authToken))\n    {\n        context.Response = WebhookResponse.Error(\n            HttpStatusCode.Unauthorized, \n            \"Invalid or missing authorization token\");\n        return;\n    }\n\n    // Process authenticated webhook\n    // ...\n});\n</code></pre>"},{"location":"concepts/webhook/#payload-validation","title":"Payload Validation","text":"C#<pre><code>integratorWorkflow.OnWebhook((context) =&gt;\n{\n    if (context.Webhook.Payload is not string jsonString)\n    {\n        context.Response = WebhookResponse.BadRequest(\"Invalid payload format\");\n        return;\n    }\n\n    OrderPayload? payload;\n    try\n    {\n        payload = JsonSerializer.Deserialize&lt;OrderPayload&gt;(jsonString);\n    }\n    catch (JsonException)\n    {\n        context.Response = WebhookResponse.BadRequest(\"Invalid JSON payload\");\n        return;\n    }\n\n    if (string.IsNullOrEmpty(payload?.OrderId))\n    {\n        context.Response = WebhookResponse.BadRequest(\"Missing required field: orderId\");\n        return;\n    }\n\n    // Continue processing...\n});\n</code></pre>"},{"location":"concepts/webhook/#async-processing","title":"Async Processing","text":"C#<pre><code>integratorWorkflow.OnWebhook(async (context) =&gt;\n{\n    var webhookName = context.Webhook.Name;\n    var payloadJson = context.Webhook.Payload as string;\n\n    // Start async processing\n    _ = Task.Run(async () =&gt; \n    {\n        await ProcessLongRunningTaskAsync(webhookName, payloadJson);\n    });\n\n    // Respond immediately\n    context.Respond(new \n    { \n        status = \"accepted\", \n        message = \"Processing started\",\n        requestId = context.Webhook.RequestId\n    });\n});\n</code></pre>"},{"location":"concepts/webhook/#important-notes","title":"Important Notes","text":"<ul> <li>Error Handling: Always wrap webhook logic in try-catch blocks to provide meaningful error responses</li> <li>Timeouts: Default timeout is 30 seconds; adjust via <code>timeoutSeconds</code> parameter for long-running operations</li> <li>Security: Use the <code>authorization</code> parameter to pass and validate tokens in your webhook handler</li> <li>Request IDs: Use <code>context.Webhook.RequestId</code> for logging and tracking webhook requests</li> </ul>"},{"location":"concepts/webhook/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Agents &amp; Workflows for built-in workflows and system-scoped agents</li> <li>Explore Replying to Users for more messaging capabilities</li> <li>Check out SDK Patterns for common implementation patterns</li> </ul>"},{"location":"concepts/workflows/","title":"Temporal Workflows","text":""},{"location":"concepts/workflows/#starting-and-executing-workflows","title":"Starting and Executing Workflows","text":"<p>The Xians SDK provides <code>XiansContext.Workflows</code> to start and execute child workflows. These methods automatically create the necessary Temporal workflow search attributes and memo values that help keep workflows properly scoped (to tenant, agent, and user) and discoverable via the Xians UI.</p> <p>Always use <code>XiansContext.Workflows</code> instead of direct Temporal SDK calls when starting workflows.</p>"},{"location":"concepts/workflows/#xianscontextworkflows-api","title":"XiansContext.Workflows API","text":"<p><code>XiansContext.Workflows</code> provides methods for two primary patterns:</p> <ol> <li>Fire and Forget - Start a workflow without waiting for completion (<code>StartAsync</code>)</li> <li>Wait for Result - Execute a workflow and wait for its result (<code>ExecuteAsync</code>)</li> </ol>"},{"location":"concepts/workflows/#method-reference","title":"Method Reference","text":"Method Description <code>StartAsync&lt;TWorkflow&gt;(object[] args, string? uniqueKey = null)</code> Start child workflow by type without waiting <code>StartAsync(string workflowType, object[] args, string? uniqueKey = null)</code> Start child workflow by type string without waiting <code>ExecuteAsync&lt;TWorkflow, TResult&gt;(object[] args, string? uniqueKey = null)</code> Execute child workflow and wait for result <code>ExecuteAsync&lt;TResult&gt;(string workflowType, object[] args, string? uniqueKey = null)</code> Execute child workflow by type string and wait for result <p>Note: Parent's <code>idPostfix</code> is always automatically extracted from workflow/activity context when available. The <code>uniqueKey</code> parameter provides additional uniqueness beyond the parent's context.</p>"},{"location":"concepts/workflows/#starting-workflows-fire-and-forget","title":"Starting Workflows (Fire and Forget)","text":"<p>Use <code>StartAsync</code> to start a workflow without waiting for its completion. This is useful for background tasks or when you don't need the result immediately.</p>"},{"location":"concepts/workflows/#by-workflow-type","title":"By Workflow Type","text":"C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents.Core;\n\n[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync(string taskId)\n    {\n        // Start child workflow by type - fire and forget\n        // Parent's idPostfix is automatically included in workflow ID\n        await XiansContext.Workflows.StartAsync&lt;BackgroundTaskWorkflow&gt;(\n            new object[] { \"param1\", \"param2\" }\n        );\n\n        // Continue without waiting for child to complete\n        Workflow.Logger.LogInformation(\"Background task started\");\n\n        // You can start multiple workflows in parallel\n        await Task.WhenAll(\n            XiansContext.Workflows.StartAsync&lt;Task1Workflow&gt;(Array.Empty&lt;object&gt;()),\n            XiansContext.Workflows.StartAsync&lt;Task2Workflow&gt;(Array.Empty&lt;object&gt;()),\n            XiansContext.Workflows.StartAsync&lt;Task3Workflow&gt;(Array.Empty&lt;object&gt;())\n        );\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#by-workflow-type-string","title":"By Workflow Type String","text":"C#<pre><code>[WorkflowRun]\npublic async Task RunAsync(string workflowType, string taskId)\n{\n    // Start workflow by type string (useful for dynamic workflow selection)\n    // Parent's idPostfix is automatically included in workflow ID\n    await XiansContext.Workflows.StartAsync(\n        \"MyAgent:DynamicWorkflow\",\n        new object[] { \"param1\", \"param2\" }\n    );\n}\n</code></pre>"},{"location":"concepts/workflows/#executing-workflows-wait-for-result","title":"Executing Workflows (Wait for Result)","text":"<p>Use <code>ExecuteAsync</code> to execute a workflow and wait for its result. This is useful when you need the workflow's output before continuing.</p>"},{"location":"concepts/workflows/#execute-by-workflow-type","title":"Execute By Workflow Type","text":"C#<pre><code>[Workflow(\"MyAgent:ParentWorkflow\")]\npublic class ParentWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;ProcessingResult&gt; RunAsync(string data)\n    {\n        // Execute child workflow and wait for result\n        // Parent's idPostfix is automatically included in workflow ID\n        var result = await XiansContext.Workflows.ExecuteAsync&lt;ProcessingWorkflow, string&gt;(\n            new object[] { data }\n        );\n\n        // Use the result\n        Workflow.Logger.LogInformation(\"Processing completed: {Result}\", result);\n\n        return new ProcessingResult { Data = result };\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#execute-by-workflow-type-string","title":"Execute By Workflow Type String","text":"C#<pre><code>[WorkflowRun]\npublic async Task&lt;string&gt; RunAsync(string workflowType, string input)\n{\n    // Execute workflow by type string and wait for result\n    // Parent's idPostfix is automatically included in workflow ID\n    var result = await XiansContext.Workflows.ExecuteAsync&lt;string&gt;(\n        \"MyAgent:DataProcessor\",\n        new object[] { input }\n    );\n\n    return result;\n}\n</code></pre>"},{"location":"concepts/workflows/#workflow-id-generation","title":"Workflow ID Generation","text":"<p>Workflow IDs are automatically constructed with the following format:</p> <p>Format: <code>{tenantId}:{agentName}:{workflowName}[:{parent_idPostfix}][:{uniqueKey}]</code></p> <ul> <li>parent_idPostfix: Automatically extracted from parent workflow/activity context (always included when available)</li> <li>uniqueKey: Optional parameter for additional uniqueness (e.g., order ID, task ID, session ID)</li> </ul> <p>Examples:</p> C#<pre><code>// Inside workflow with parent idPostfix \"session-abc123\"\n// Result: tenant1:MyAgent:Task:session-abc123\nawait XiansContext.Workflows.StartAsync&lt;TaskWorkflow&gt;(\n    Array.Empty&lt;object&gt;()\n);\n\n// Inside workflow with parent idPostfix \"session-abc123\" + uniqueKey\n// Result: tenant1:MyAgent:Task:session-abc123:order-456\nawait XiansContext.Workflows.StartAsync&lt;TaskWorkflow&gt;(\n    Array.Empty&lt;object&gt;(),\n    uniqueKey: \"order-456\"\n);\n\n// Outside workflow context (no parent idPostfix)\n// Result: tenant1:MyAgent:Task:order-456\nawait XiansContext.Workflows.StartAsync&lt;TaskWorkflow&gt;(\n    Array.Empty&lt;object&gt;(),\n    uniqueKey: \"order-456\"\n);\n</code></pre>"},{"location":"concepts/workflows/#error-handling","title":"Error Handling","text":"C#<pre><code>using Xians.Lib.Agents.Workflows;\n\n[WorkflowRun]\npublic async Task RunAsync(string taskId)\n{\n    try\n    {\n        // Parent's idPostfix automatically included in workflow ID\n        await XiansContext.Workflows.StartAsync&lt;ProcessWorkflow&gt;(\n            Array.Empty&lt;object&gt;()\n        );\n    }\n    catch (WorkflowAlreadyStartedException ex)\n    {\n        // Workflow with this ID is already running\n        Workflow.Logger.LogWarning(\n            \"Workflow already started: {WorkflowId}\", \n            ex.WorkflowId\n        );\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#context-behavior","title":"Context Behavior","text":"<p><code>XiansContext.Workflows</code> works both inside workflows and outside of workflows (e.g., in message handlers):</p> Context Behavior Inside Workflow Starts/executes as a child workflow Outside Workflow Starts/executes as a new workflow using the Temporal client <p>This allows you to use the same API consistently throughout your application.</p>"},{"location":"concepts/workflows/#complete-example","title":"Complete Example","text":"C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Agents.Core;\n\n[Workflow(\"MyAgent:OrderProcessor\")]\npublic class OrderProcessorWorkflow\n{\n    [WorkflowRun]\n    public async Task&lt;OrderResult&gt; ProcessOrderAsync(Order order)\n    {\n        // Start payment processing in the background\n        // Parent's idPostfix is automatically included in workflow ID\n        await XiansContext.Workflows.StartAsync&lt;PaymentWorkflow&gt;(\n            new object[] { order.PaymentInfo }\n        );\n\n        // Execute inventory check and wait for result\n        var inventoryResult = await XiansContext.Workflows\n            .ExecuteAsync&lt;InventoryCheckWorkflow, bool&gt;(\n                new object[] { order.Items }\n            );\n\n        if (!inventoryResult)\n        {\n            return new OrderResult { Success = false, Reason = \"Out of stock\" };\n        }\n\n        // Execute shipping calculation and wait for result\n        var shippingCost = await XiansContext.Workflows\n            .ExecuteAsync&lt;ShippingWorkflow, decimal&gt;(\n                new object[] { order.ShippingAddress }\n            );\n\n        return new OrderResult \n        { \n            Success = true, \n            TotalCost = order.Total + shippingCost \n        };\n    }\n}\n</code></pre>"},{"location":"concepts/workflows/#communicating-with-workflows","title":"Communicating with Workflows","text":"<p>For signaling, querying, or updating workflows after they've been started, use the standard Temporal .NET SDK. Xians does not provide wrapper methods for these operations to keep your workflows from depending on the Xians platform.</p>"},{"location":"concepts/workflows/#obtaining-the-temporal-client","title":"Obtaining the Temporal Client","text":"<p>The Xians SDK provides easy access to the Temporal client through <code>XiansContext.Workflows</code>:</p> C#<pre><code>using Temporalio.Client;\nusing Xians.Lib.Agents.Core;\n\n// Get the Temporal client from the current agent context\n// All agents share the same Temporal connection\nvar temporalClient = await XiansContext.Workflows.GetClientAsync();\n</code></pre> <p>The client is automatically configured when you initialize the platform with <code>XiansPlatform.InitializeAsync()</code>. Since all agents share the same Temporal connection, <code>GetClientAsync()</code> returns the shared client regardless of which agent is calling it.</p>"},{"location":"concepts/workflows/#signal-example","title":"Signal Example","text":""},{"location":"concepts/workflows/#using-getworkflowhandleasync-recommended","title":"Using GetWorkflowHandleAsync (Recommended)","text":"<p>The simplest way to get a workflow handle is using <code>XiansContext.Workflows.GetWorkflowHandleAsync()</code>, which automatically constructs the workflow ID:</p> C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Get workflow handle using the workflow class and ID postfix\n// This automatically constructs the full workflow ID\nvar workflowHandle = await XiansContext.Workflows.GetWorkflowHandleAsync&lt;MyWorkflow&gt;(\"12345\");\n\n// Send signal\nawait workflowHandle.SignalAsync(\n    wf =&gt; wf.HandleSignalAsync(new SignalData { Message = \"Update\" })\n);\n</code></pre>"},{"location":"concepts/workflows/#using-manual-workflow-id","title":"Using Manual Workflow ID","text":"<p>Alternatively, you can construct the workflow ID manually:</p> C#<pre><code>using Temporalio.Client;\nusing Xians.Lib.Agents.Core;\n\n// Get the Temporal client\nvar temporalClient = await XiansContext.Workflows.GetClientAsync();\n\n// Construct full workflow ID manually: {tenantId}:{agentName}:{workflowName}[:{parent_idPostfix}][:{uniqueKey}]\n// Example: tenant123:MyAgent:Task:session-abc:order-12345\nvar workflowHandle = temporalClient.GetWorkflowHandle&lt;MyWorkflow&gt;(\n    workflowId: \"tenant123:MyAgent:Task:session-abc:order-12345\"\n);\n\n// Send signal\nawait workflowHandle.SignalAsync(\n    wf =&gt; wf.HandleSignalAsync(new SignalData { Message = \"Update\" })\n);\n</code></pre>"},{"location":"concepts/workflows/#query-example","title":"Query Example","text":"C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Get workflow handle (automatically constructs workflow ID)\nvar workflowHandle = await XiansContext.Workflows.GetWorkflowHandleAsync&lt;MyWorkflow&gt;(\"12345\");\n\n// Query workflow state\nvar status = await workflowHandle.QueryAsync(wf =&gt; wf.GetStatus());\n</code></pre>"},{"location":"concepts/workflows/#advanced-access-to-temporal-service","title":"Advanced: Access to Temporal Service","text":"<p>For advanced scenarios like health monitoring or reconnection, you can access the underlying <code>ITemporalClientService</code>:</p> C#<pre><code>using Xians.Lib.Agents.Core;\n\n// Get the Temporal service\nvar temporalService = XiansContext.Workflows.GetService();\n\n// Check connection health\nbool isHealthy = temporalService.IsConnectionHealthy();\n\n// Force reconnection if needed\nif (!isHealthy)\n{\n    await temporalService.ForceReconnectAsync();\n}\n</code></pre> <p>For more information on message passing, see the Temporal .NET SDK documentation.</p>"},{"location":"concepts/workflows/#other-temporal-features","title":"Other Temporal Features","text":"<p>You are free to use all other Temporal SDK features when designing your agents, including:</p> <ul> <li>Timers and Sleep - <code>Workflow.DelayAsync()</code></li> <li>Conditions - <code>Workflow.WaitConditionAsync()</code></li> <li>Activities - <code>Workflow.ExecuteActivityAsync()</code></li> <li>Queries - <code>[WorkflowQuery]</code></li> <li>Signals - <code>[WorkflowSignal]</code></li> <li>Updates - <code>[WorkflowUpdate]</code></li> <li>Continue-As-New - <code>Workflow.ContinueAsNewAsync()</code></li> <li>Local Activities - For fast, local operations</li> <li>Side Effects - For non-deterministic operations</li> </ul> <p>Refer to Temporal Docs</p> <p>The Xians SDK enhances Temporal with multi-tenancy, agent scoping, and built-in workflows, but doesn't restrict your use of Temporal's powerful features.</p>"},{"location":"contribution/learning-path/","title":"Learning &amp; Contribution Path","text":"<p>Welcome to the Xians AI Platform development journey! Follow this structured path to become proficient in building AI agents and contributing to the platform.</p>"},{"location":"contribution/learning-path/#phase-1-explore-and-learn","title":"Phase 1: Explore and Learn","text":""},{"location":"contribution/learning-path/#get-started-with-the-platform","title":"Get Started with the Platform","text":"<ul> <li> 1.1 Login to agentri.ai (hosted version of Xians.AI platform)</li> <li> 1.2 Join the existing tenant 99x and request admin approval</li> <li> 1.4 Review the complete documentation to understand how Xians.AI helps developers build AI Agent systems</li> </ul>"},{"location":"contribution/learning-path/#make-your-first-contribution","title":"Make Your First Contribution","text":"<ul> <li> 1.5 Send a PR to the documentation repository to improve documentation</li> </ul>"},{"location":"contribution/learning-path/#phase-2-setting-up-development-environment","title":"Phase 2: Setting Up Development Environment","text":"<ul> <li> 2.1 Set up Xians Community Edition locally on your machine</li> <li> 2.2 Verify your local setup is working correctly</li> </ul>"},{"location":"contribution/learning-path/#phase-3-agent-development","title":"Phase 3: Agent Development","text":"<p>Build a few first agents and learn core concepts:</p> <p>For example,</p> <ul> <li>Agent with tools, MCPs</li> <li>Agent with Custom Workflows (Scheduling, A2A Communication)</li> <li>Etc.</li> </ul>"},{"location":"contribution/learning-path/#phase-4-platform-development","title":"Phase 4: Platform Development","text":"<p>Contribute to the core platform:</p>"},{"location":"contribution/learning-path/#setup-core-repositories","title":"Setup Core Repositories","text":"<ul> <li> 5.1 Clone and set up the following repositories locally:</li> <li>XiansAi.Server</li> <li>XiansAi.UI</li> <li>XiansAi.Lib</li> <li> 5.2 Configure your existing agent development projects to use the local Lib and Server</li> </ul>"},{"location":"contribution/learning-path/#contribute-to-platform","title":"Contribute to Platform","text":"<ul> <li> 5.3 Make improvements to the platform repositories (e.g., unit tests, UI enhancements)</li> <li> 5.4 Test your changes thoroughly</li> <li> 5.5 Submit a Pull Request with your improvements</li> </ul>"},{"location":"contribution/learning-path/#join-platform-development","title":"Join Platform Development","text":"<ul> <li> 5.6 Review tasks in the XiansAI Platform project board. Pick up a task and contribute to platform development</li> </ul>"},{"location":"contribution/learning-path/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, you'll be ready to:</p> <ul> <li>Build production-ready AI agents</li> <li>Contribute to the Xians AI Platform</li> <li>Help others in their learning journey</li> <li>Design and implement complex multi-agent systems</li> </ul> <p>Happy coding! \ud83d\ude80</p>"},{"location":"contribution/platform-development/","title":"Developer Guide - Agentic AI","text":"<p>This guide provides step-by-step instructions to set up and run the Agentic AI platform. Follow the steps below to clone the repositories, configure the server, and set up the UI.</p>"},{"location":"contribution/platform-development/#1-clone-the-repositories","title":"1. Clone the Repositories","text":"<p>To begin, clone the following three repositories from GitHub:</p> <ol> <li> <p>XiansAI.Server    Repository URL: https://github.com/XiansAiPlatform/XiansAi.Server.git    Command to clone:    Bash<pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.Server.git\n</code></pre></p> </li> <li> <p>XiansAI.Lib    Repository URL: https://github.com/XiansAiPlatform/XiansAi.Lib.git    Command to clone:    Bash<pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.Lib.git\n</code></pre></p> </li> <li> <p>XiansAI.UI    Repository URL: https://github.com/XiansAiPlatform/XiansAi.UI.git    Command to clone:    Bash<pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.UI.git\n</code></pre></p> </li> </ol>"},{"location":"contribution/platform-development/#2-setting-up-the-server","title":"2. Setting Up the Server","text":"<p>To configure and run the server, follow these steps:</p> <ol> <li> <p>Obtain Configuration Files</p> <p>Request the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files from a team member. These files contain the necessary configuration settings for the server.</p> </li> <li> <p>Place Configuration Files</p> <p>Copy the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files into the <code>src</code> folder of the <code>XiansAI.Server</code> repository.</p> <p>Example path: Text Only<pre><code>XiansAI.Server/src/\n</code></pre></p> </li> <li> <p>Run the Server</p> <p>Follow the specific instructions provided in the <code>XiansAI.Server</code> repository's README file to build and run the server.</p> </li> </ol>"},{"location":"contribution/platform-development/#3-setting-up-the-ui","title":"3. Setting Up the UI","text":"<p>To configure and run the UI, follow these steps:</p> <ol> <li> <p>Create a <code>.env</code> File </p> <ul> <li>Navigate to the root directory of the <code>XiansAI.UI</code> repository.  </li> <li>Create a new file named <code>.env</code>.</li> </ul> </li> <li> <p>Copy Environment Variables </p> <ul> <li>Open the <code>XiansAI.UI</code> repository and locate the <code>.env.development</code> file.  </li> <li>Copy the contents of the <code>.env.development</code> file into the newly created <code>.env</code> file.</li> </ul> </li> <li> <p>Install Dependencies </p> <ul> <li>Run the following command to install all required dependencies:   Bash<pre><code>npm install\n</code></pre></li> </ul> </li> <li> <p>Start the UI </p> <ul> <li> <p>Start the development server by running:   Bash<pre><code>npm start\n</code></pre></p> </li> <li> <p>The UI should now be accessible in your browser. The default URL is typically <code>http://localhost:3000</code>, but refer to the project documentation for confirmation.</p> </li> </ul> </li> </ol>"},{"location":"contribution/platform-development/#4-setting-up-the-library-xiansailib","title":"4. Setting Up the Library (XiansAI.Lib)","text":"<p>To configure and use the <code>XiansAI.Lib</code> library, follow these steps:</p> <ol> <li> <p>Run the Library </p> <ul> <li>After cloning the <code>XiansAI.Lib</code> repository, navigate to its root directory and run the following command to build and execute the library in release mode:   Bash<pre><code>dotnet run -c Release\n</code></pre></li> </ul> </li> <li> <p>Making Changes to the Library </p> <ul> <li>If you make any changes to the <code>XiansAI.Lib</code> codebase, you need to update its reference in the agent's package dependency list:</li> <li>Locate the <code>.csproj</code> file of the <code>XiansAI.Lib</code> project.</li> <li>Copy the file path of the <code>.csproj</code> file.</li> <li>Update the agent's package dependency list to reference the updated <code>.csproj</code> file location.</li> </ul> <p>Example of referencing the <code>.csproj</code> file in another project:   XML<pre><code>&lt;ProjectReference Include=\"path/to/XiansAI.Lib.csproj\" /&gt;\n</code></pre></p> </li> <li> <p>Rebuild the Dependent Project </p> <ul> <li>After updating the reference, rebuild the dependent project to ensure the changes in the library are applied.</li> </ul> </li> </ol>"},{"location":"contribution/platform-development/#notes","title":"Notes","text":"<ul> <li>Ensure you have the required versions of .NET SDK installed on your system before setting up the library. Refer to the <code>XiansAI.Lib</code> repository's README for version requirements.</li> <li>For the server and library, ensure you have the necessary runtime environment (e.g., .NET Core) installed. Check the respective repositories for specific prerequisites.</li> <li>If you encounter any issues during setup, consult the respective repository's documentation or reach out to your team for assistance.</li> </ul> <p>By following these steps, you should be able to successfully set up and run the Agentic AI platform.</p>"},{"location":"getting-started/chat-history/","title":"Chat History","text":""},{"location":"getting-started/chat-history/#the-problem-with-memory-loss","title":"The Problem with Memory Loss","text":"<p>Remember the MAF agent we built in the previous step? It has a significant limitation: no chat history. Every message is treated as an isolated conversation, as if the agent has amnesia between each interaction. This isn't how useful agents work in the real world!</p> <p>Imagine asking an agent \"What's the weather like?\" followed by \"How about tomorrow?\" - without context, the agent wouldn't know you're still talking about weather. Frustrating, right?</p>"},{"location":"getting-started/chat-history/#how-xians-manages-conversation-memory","title":"How Xians Manages Conversation Memory","text":"<p>The good news? Xians automatically stores all messages with proper isolation across:</p> <ul> <li>Tenants - keeping different organizations separate</li> <li>Agent-User pairs - each user gets their own conversation history</li> <li>Topics/Scopes - conversations can be organized by subject</li> </ul> <p>Secure &amp; Compliant Storage</p> <p>Xians stores all messages encrypted at rest, helping you build AI agents that are compliant with the EU AI Act and other data protection regulations. Your users' conversations are protected by default.</p> <p>The platform provides convenient methods to access this chat history for the current context, making your agents context-aware.</p>"},{"location":"getting-started/chat-history/#implementing-the-message-store","title":"Implementing the Message Store","text":"<p>To enable chat history in MAF (Microsoft Agent Framework), we need to implement a message store class. This bridges Xians' message storage with MAF's expectations.</p>"},{"location":"getting-started/chat-history/#step-1-create-the-xianschatmessagestore","title":"Step 1: Create the XiansChatMessageStore","text":"<p>Create a new class that implements MAF's <code>ChatMessageStore</code> interface:</p> C#<pre><code>using System.Text.Json;\nusing Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing Xians.Lib.Agents.Messaging;\n\ninternal sealed class XiansChatMessageStore : ChatMessageStore\n{\n    private readonly UserMessageContext _context;\n\n    public XiansChatMessageStore(UserMessageContext context)\n    {\n        _context = context;\n    }\n\n    public override async ValueTask&lt;IEnumerable&lt;ChatMessage&gt;&gt; InvokingAsync(\n        InvokingContext context,\n        CancellationToken cancellationToken)\n    {\n        // Get chat history from Xians\n        var xiansMessages = await _context.GetChatHistoryAsync(page: 1, pageSize: 10);\n\n        // Convert to ChatMessage format\n        var chatMessages = xiansMessages\n            .Where(msg =&gt; !string.IsNullOrEmpty(msg.Text))\n            .Select(msg =&gt; new ChatMessage(\n                msg.Direction.ToLowerInvariant() == \"outgoing\" ? ChatRole.Assistant : ChatRole.User,\n                msg.Text!))\n            .Reverse() // Xians returns newest first, we need oldest first\n            .ToList();\n\n        return chatMessages;\n    }\n\n    public override ValueTask InvokedAsync(\n        InvokedContext context,\n        CancellationToken cancellationToken)\n    {\n        // No-op: Xians automatically stores messages\n        return ValueTask.CompletedTask;\n    }\n\n    public override JsonElement Serialize(JsonSerializerOptions? jsonSerializerOptions = null)\n    {\n        // Serialize the thread ID for state persistence\n        return JsonSerializer.SerializeToElement(_context.Message.ThreadId);\n    }\n}\n</code></pre>"},{"location":"getting-started/chat-history/#understanding-the-key-methods","title":"Understanding the Key Methods","text":"<p>GetMessagesAsync: This retrieves the conversation history from Xians using <code>_context.GetChatHistoryAsync()</code>. The method:</p> <ul> <li>Fetches the most recent 10 messages (you can adjust <code>pageSize</code> as needed)</li> <li>Filters out empty messages</li> <li>Converts Xians message format to MAF's <code>ChatMessage</code> format</li> <li>Reverses the order (Xians returns newest first, but MAF expects oldest first)</li> </ul> <p>Scoped Conversations</p> <p>If the current conversation has a scope (topic), you'll only get messages from that scope. Messages without a scope use the default scope (<code>null</code>).</p> <p>AddMessagesAsync: This is a no-op because Xians automatically stores all messages for you - no manual saving required!</p> <p>Serialize: Persists the thread ID for state management across agent sessions.</p>"},{"location":"getting-started/chat-history/#step-2-update-your-maf-agent","title":"Step 2: Update Your MAF Agent","text":"<p>Now let's wire up the message store to your MAF agent. Notice we're now passing the entire <code>UserMessageContext</code> instead of just the message text:</p> C#<pre><code>using Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing OpenAI;\nusing OpenAI.Chat;\nusing Xians.Lib.Agents.Core;\nusing Xians.Lib.Agents.Messaging;\n\npublic class MafSubAgent\n{\n    private readonly ChatClient _chatClient;\n    public MafSubAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        _chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n    }\n\n    private async Task&lt;string&gt; GetSystemPromptAsync(UserMessageContext context)\n    {\n        // You need to create a KnowledgeItem with the name \"System Prompt\" in the Xians platform.\n        var systemPrompt = await XiansContext.CurrentAgent.Knowledge.GetAsync(\"System Prompt\");\n        return systemPrompt?.Content ?? \"You are a helpful assistant.\";\n    }\n\n    public async Task&lt;string&gt; RunAsync(UserMessageContext context)\n    {\n        if (string.IsNullOrWhiteSpace(context.Message.Text))\n        {\n            return \"I didn't receive any message. Please send a message.\";\n        }\n\n        // Configure the AI agent with tools\n        var agent = _chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = await GetSystemPromptAsync(context)\n            },\n            // Use Xians chat message store for conversation history\n            ChatMessageStoreFactory = ctx =&gt; new XiansChatMessageStore(context)\n        });\n\n        // Run the agent and return the response\n        var response = await agent.RunAsync(context.Message.Text);\n        return response.Text;\n    }\n}\n</code></pre> <p>The key change is in <code>ChatMessageStoreFactory</code> - we're now providing our custom <code>XiansChatMessageStore</code> that knows how to retrieve conversation history from Xians.</p>"},{"location":"getting-started/chat-history/#step-3-update-your-message-handler","title":"Step 3: Update Your Message Handler","text":"<p>Finally, update your <code>Program.cs</code> to pass the full context object to the agent:</p> C#<pre><code>// Handle incoming user messages\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var response = await mafAgent.RunAsync(context);\n    await context.ReplyAsync(response);\n});\n</code></pre>"},{"location":"getting-started/chat-history/#whats-next","title":"What's Next?","text":"<p>Congratulations! Your agent now has memory and can maintain context across conversations. Try asking follow-up questions and watch your agent understand the conversation flow.</p> <p>In the next section, we'll explore more advanced features like tool integration and multi-agent workflows.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get started with Xians.ai by choosing the installation path that best fits your needs.</p>"},{"location":"getting-started/installation/#choose-your-path","title":"Choose Your Path","text":"<p>Xians.ai offers two deployment options:</p> <ol> <li>SaaS Platform - Quick start with hosted infrastructure (Recommended for 99x employees and customers)</li> <li>Community Edition - Self-hosted deployment for development and testing</li> </ol>"},{"location":"getting-started/installation/#option-1-saas-platform","title":"Option 1: SaaS Platform","text":"<p>If you already have an account, the fastest way to get started is using our hosted SaaS platform at agentri.ai.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Active account at agentri.ai</li> <li>API key for authentication</li> </ul>"},{"location":"getting-started/installation/#getting-started","title":"Getting Started","text":"<ol> <li>Sign in at agentri.ai</li> <li>Obtain your API key from the tenant settings page</li> <li>Start building - You're ready to create your first agent! Follow Quick Start.</li> </ol>"},{"location":"getting-started/installation/#option-2-community-edition-self-hosted","title":"Option 2: Community Edition (Self-Hosted)","text":"<p>For local development, testing, or self-hosted deployments, use the Community Edition.</p>"},{"location":"getting-started/installation/#prerequisites_1","title":"Prerequisites","text":"<p>Before setting up the Community Edition, ensure you have:</p> <ul> <li>Operating System: Windows, macOS, or Linux</li> <li>Docker &amp; Docker Compose: Latest versions installed</li> <li>System Resources: Minimum 8GB RAM recommended</li> <li>OpenAI API Key: Required for LLM capabilities (optional)</li> </ul>"},{"location":"getting-started/installation/#quick-setup-with-docker-compose","title":"Quick Setup with Docker Compose","text":"<p>The Community Edition provides a one-command setup that includes all essential components:</p> <ul> <li>Xians Server - Core platform API and orchestration</li> <li>Xians UI - Web-based management interface</li> <li>Temporal - Workflow orchestration engine</li> <li>Keycloak - Authentication and authorization</li> <li>Database Components - Data persistence layer</li> </ul>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":"<p>For detailed setup instructions, configuration options, and troubleshooting, visit:</p> <p>\ud83d\udcda XiansAi Platform - Community Edition</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once your platform is running locally, proceed to the Quick Start guide to create your first agent.</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues:</p> <ul> <li>Community Edition: See the Git Repo</li> <li>Issues: Open an issue on GitHub</li> </ul>"},{"location":"getting-started/overview/","title":"Getting Started","text":"<p>Get up and running with Xians.ai in minutes. This section guides you through installation, creating your first agent, and enhancing it with essential features.</p> Page Description Installation Choose between SaaS platform or Community Edition self-hosted deployment Quick Start Create your first conversational agent using MAF and connect it to Xians platform Chat History Add conversation memory to your agent so it maintains context across interactions Tool Execution Integrate tools with your agent to access documents, knowledge, and workflows"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with your first Xians agent in minutes. This guide walks you through creating a simple conversational agent and connecting it to the Xians platform.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>.NET 9 SDK - Download here</li> <li>OpenAI API Key - Get one from OpenAI Platform</li> </ul>"},{"location":"getting-started/quick-start/#step-1-create-your-project","title":"Step 1: Create Your Project","text":"<p>Xians agents run as standard .NET applications that can be executed locally or deployed to any server environment. Start by creating a new console project:</p> Bash<pre><code>dotnet new console -n MyAgent\ncd MyAgent\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-build-a-simple-agent-with-maf","title":"Step 2: Build a Simple Agent with MAF","text":"<p>You can use any framework that supports .NET Core to create your agent. In this guide, we'll use the Microsoft Agent Framework (MAF).</p>"},{"location":"getting-started/quick-start/#install-required-packages","title":"Install Required Packages","text":"<p>Note: Please check if stable releases are available from Microsoft and use accordingly.</p> Bash<pre><code>dotnet add package Azure.AI.OpenAI --prerelease\ndotnet add package Azure.Identity\ndotnet add package Microsoft.Agents.AI.OpenAI --prerelease\ndotnet add package DotNetEnv\n</code></pre>"},{"location":"getting-started/quick-start/#configure-environment-variables","title":"Configure Environment Variables","text":"<p>For better security and maintainability, use a <code>.env</code> file to manage your API keys. This prevents accidentally committing sensitive credentials to version control.</p> <p>Create a <code>.env</code> file in the root of your project:</p> Bash<pre><code># OpenAI Configuration\nOPENAI_API_KEY=your-openai-api-key\n</code></pre> <p>Add <code>.env</code> to your <code>.gitignore</code> to prevent committing secrets:</p> Bash<pre><code>echo \".env\" &gt;&gt; .gitignore\n</code></pre> <p>Security Tip: Never commit your <code>.env</code> file to version control. Always add it to <code>.gitignore</code> to protect your API keys.</p>"},{"location":"getting-started/quick-start/#create-the-maf-agent-class","title":"Create the MAF Agent Class","text":"<p>Create a new file called <code>MafSubAgent.cs</code>:</p> <p>Note: We call this class <code>MafSubAgent</code>, not <code>MafAgent</code>, because production-grade agentic applications typically comprise multiple sub-agents. When you create an agent with Xians, it can have multiple workflows attached to different sub-agents. You'll see this pattern in the following examples.</p> Bash<pre><code>touch MafSubAgent.cs\n</code></pre> <p>Add the following code to <code>MafSubAgent.cs</code>:</p> C#<pre><code>using Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing OpenAI;\nusing OpenAI.Chat;\n\npublic class MafSubAgent\n{\n    private readonly ChatClient _chatClient;\n\n    public MafSubAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        _chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n    }\n\n    public async Task&lt;string&gt; RunAsync(string message)\n    {\n        var agent = _chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = \"You are a helpful assistant.\"\n            }\n        });\n\n        var response = await agent.RunAsync(message);\n        return response.Text;\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#update-programcs","title":"Update Program.cs","text":"<p>Replace the contents of <code>Program.cs</code> with:</p> C#<pre><code>using DotNetEnv;\n\n// Load environment variables from .env file\nEnv.Load();\n\n// Get OpenAI API key from environment\nvar openAiApiKey = Environment.GetEnvironmentVariable(\"OPENAI_API_KEY\") \n    ?? throw new InvalidOperationException(\"OPENAI_API_KEY not found in .env file\");\n\n// Create the agent\nvar agent = new MafSubAgent(openAiApiKey);\n\n// Process a user message\nvar response = await agent.RunAsync(\"Hello! Can you write a one sentence story about a cat?\");\nConsole.WriteLine($\"Agent: {response}\");\n</code></pre> <p>Note: The <code>Env.Load()</code> call reads your <code>.env</code> file and makes the variables available through <code>Environment.GetEnvironmentVariable()</code>.</p>"},{"location":"getting-started/quick-start/#test-your-agent","title":"Test Your Agent","text":"<p>Build and run your agent to verify it works:</p> Bash<pre><code>dotnet build\ndotnet run\n</code></pre> <p>You should see a creative response from your agent!</p> <p>Note: At this point, we've built a simple agent using MAF without any Xians SDK constructs. This demonstrates the core principle of Xians: work with your existing agent frameworks. Next, we'll enhance this agent with the power of the Xians platform.</p>"},{"location":"getting-started/quick-start/#step-3-connect-your-agent-to-xians","title":"Step 3: Connect Your Agent to Xians","text":"<p>While a standalone agent is great for demos, production systems require multi-tenancy, user management, conversation threading, and more. Building this infrastructure from scratch is time-consuming, but Xians provides all of this out of the box.</p>"},{"location":"getting-started/quick-start/#install-the-xians-sdk","title":"Install the Xians SDK","text":"Bash<pre><code>dotnet add package Xians.Lib\n</code></pre> <p>Note: Xians.Lib version 3+ is published under <code>Xians.Lib</code>, not <code>XiansAi.Lib</code> like previous versions.</p>"},{"location":"getting-started/quick-start/#get-your-xians-api-key","title":"Get Your Xians API Key","text":"<p>Before proceeding, you need to:</p> <ol> <li>Set up your Xians platform instance</li> <li>Navigate to Tenant Settings in the platform UI</li> <li>Copy your Agent Certificate and Server URL</li> </ol> <p></p>"},{"location":"getting-started/quick-start/#update-your-environment-configuration","title":"Update Your Environment Configuration","text":"<p>Now that you have your Xians credentials, add them to your existing <code>.env</code> file:</p> Bash<pre><code># OpenAI Configuration\nOPENAI_API_KEY=your-openai-api-key\n\n# Xians Platform Configuration\nXIANS_SERVER_URL=https://your-xians-server.com\nXIANS_API_KEY=your-xians-certificate\n</code></pre> <p>Note: Replace the placeholder values with your actual server URL and agent certificate from the previous step.</p>"},{"location":"getting-started/quick-start/#configure-and-connect-to-xians","title":"Configure and Connect to Xians","text":"<p>Replace the entire contents of <code>Program.cs</code> with the following:</p> C#<pre><code>using DotNetEnv;\nusing Xians.Lib.Agents.Core;\n\n// Load environment variables from .env file\nEnv.Load();\n\n// Get configuration from environment variables\nvar openAiApiKey = Environment.GetEnvironmentVariable(\"OPENAI_API_KEY\") \n    ?? throw new InvalidOperationException(\"OPENAI_API_KEY not found in environment variables\");\nvar serverUrl = Environment.GetEnvironmentVariable(\"XIANS_SERVER_URL\") \n    ?? throw new InvalidOperationException(\"XIANS_SERVER_URL not found in environment variables\");\nvar xiansApiKey = Environment.GetEnvironmentVariable(\"XIANS_API_KEY\") \n    ?? throw new InvalidOperationException(\"XIANS_API_KEY not found in environment variables\");\n\n// Initialize Xians Platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new ()\n{\n    ServerUrl = serverUrl,\n    ApiKey = xiansApiKey\n});\n\n// Register a new agent with Xians\nvar xiansAgent = xiansPlatform.Agents.Register(new ()\n{\n    Name = \"My Conversational Agent\",\n    IsTemplate = false  // See important notes below\n});\n\n// Define a built-in conversational workflow\nvar conversationalWorkflow = xiansAgent.Workflows.DefineBuiltIn(name: \"Conversational\");\n\n// Create your MAF agent instance\nvar mafSubAgent = new MafSubAgent(openAiApiKey);\n\n// Handle incoming user messages\nconversationalWorkflow.OnUserChatMessage(async (context) =&gt;\n{\n    var response = await mafSubAgent.RunAsync(context.Message.Text);\n    await context.ReplyAsync(response);\n});\n\n// Start the agent and all workflows\nawait xiansAgent.RunAllAsync();\n</code></pre> <p>Alternative: If you prefer not to use a <code>.env</code> file, you can replace the <code>Env.Load()</code> and environment variable calls with hardcoded values, though this is not recommended for production use.</p>"},{"location":"getting-started/quick-start/#important-configuration-notes","title":"Important Configuration Notes","text":"<p>IsTemplate Setting:</p> <ul> <li> <p><code>IsTemplate = true</code>: Adds the agent to the global Agent Templates library, making it available for any tenant admin to deploy. This option is only available if you're a system administrator.</p> </li> <li> <p><code>IsTemplate = false</code> (default): Immediately deploys the agent to your current tenant. Use this if you only have tenant-level permissions.</p> </li> </ul> <p>Understanding Workflows:</p> <ul> <li>A Xians agent is a definition that represents your agent in the platform</li> <li>The actual AI logic runs in your MAF agent (or any other framework you choose)</li> <li>Built-in workflows connect Xians' conversation handling capabilities to your agent logic</li> <li>One Xians agent can contain multiple built-in workflows, each connected to different AI agent implementations</li> </ul>"},{"location":"getting-started/quick-start/#step-4-deploy-your-agent","title":"Step 4: Deploy Your Agent","text":""},{"location":"getting-started/quick-start/#for-system-scoped-agents","title":"For System-Scoped Agents","text":"<p>If you registered your agent with <code>IsTemplate = true</code>, you'll find it in the Agent Templates section:</p> <p></p> <p>Tenant administrators can then deploy instances of this template to their tenants.</p>"},{"location":"getting-started/quick-start/#for-tenant-scoped-agents","title":"For Tenant-Scoped Agents","text":"<p>If you used <code>IsTemplate = false</code>, or after deploying a system template, your agent appears under Deployed Agents:</p> <p></p> <p>What You've Achieved: Xians has transformed your simple MAF agent into a multi-tenant, enterprise-ready solution. You can now manage agent lifecycles across different tenant scopes through the platform UI.</p>"},{"location":"getting-started/quick-start/#step-5-start-a-conversation","title":"Step 5: Start a Conversation","text":"<p>Now for the exciting part - talking to your agent!</p> <ol> <li>Navigate to Conversations in the platform UI</li> <li>Select your deployed agent from the list</li> <li>Click the + button to create a new conversation</li> <li>Start chatting with your agent!</li> </ol> <p></p>"},{"location":"getting-started/quick-start/#step-6-visualizing-the-flows-logic","title":"Step 6: Visualizing the Flow's Logic","text":"<p>You may have noticed a disabled Visualize button in the Xians Manager portal when viewing your agent's workflow.</p>"},{"location":"getting-started/quick-start/#when-is-the-visualize-button-enabled","title":"When is the Visualize button enabled?","text":"<p>The Visualize button is only available for custom workflows. Built-in workflows do not support visualization because they are created dynamically at runtime.</p>"},{"location":"getting-started/quick-start/#enabling-visualization-with-a-custom-workflow","title":"Enabling visualization with a custom workflow","text":"<p>To enable the Visualize button, you need to create a custom workflow. Follow these steps:</p> <p>1. Update <code>Program.cs</code> with the following changes \u2013 Replace the <code>// Define a built-in conversational workflow</code> and <code>// Handle incoming user messages</code> sections with:</p> C#<pre><code>// Define a CUSTOM conversational workflow (enables visualization)\nvar conversationalWorkflow = xiansAgent.Workflows.DefineCustom&lt;MyAgent.ConversationalWorkflow&gt;();\n\n// Register chat handler for the CUSTOM workflow\nvar tenantId = xiansPlatform.Options?.CertificateTenantId;\nBuiltinWorkflow.RegisterChatHandler(\n    workflowType: \"My New Agent:Conversational\",\n    handler: async (context) =&gt;\n    {\n        var response = await mafSubAgent.RunAsync(context.Message.Text);\n        await context.ReplyAsync(response);\n    },\n    agentName: xiansAgent.Name,\n    tenantId: xiansAgent.SystemScoped ? null : tenantId,\n    systemScoped: xiansAgent.SystemScoped);\n\n// Upload workflow definitions (includes source code for visualization)\nawait xiansAgent.UploadWorkflowDefinitionsAsync();\n</code></pre> <p>Note: The <code>workflowType</code> must match the <code>[Workflow(\"...\")]</code> attribute on your custom workflow class (e.g. <code>\"My New Agent:Conversational\"</code>).</p> <p>2. Create <code>ConversationalWorkflow.cs</code> \u2013 Add a new file with your custom workflow class:</p> C#<pre><code>using Temporalio.Workflows;\nusing Xians.Lib.Temporal.Workflows;\n\nnamespace MyAgent\n{\n    /// &lt;summary&gt;\n    /// Custom conversational workflow that extends BuiltinWorkflow.\n    /// This workflow can be visualized because it has a source file that can be embedded.\n    /// &lt;/summary&gt;\n    [Workflow(\"My New Agent:Conversational\")]\n    public class ConversationalWorkflow : BuiltinWorkflow\n    {\n        /// &lt;summary&gt;\n        /// Main workflow execution method.\n        /// This calls the base implementation which handles message processing.\n        /// &lt;/summary&gt;\n        [WorkflowRun]\n        public override async Task RunAsync()\n        {\n            // Call base implementation to handle message processing\n            await base.RunAsync();\n        }\n    }\n}\n</code></pre> <p>3. Update your <code>.csproj</code> file \u2013 Embed the workflow source file as a resource:</p> XML<pre><code>&lt;!-- Embed workflow source for visualization --&gt;\n&lt;ItemGroup&gt;\n  &lt;EmbeddedResource Include=\"ConversationalWorkflow.cs\"&gt;\n    &lt;LogicalName&gt;%(Filename)%(Extension)&lt;/LogicalName&gt;\n  &lt;/EmbeddedResource&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>After these changes, rebuild your project and run the agent. The Visualize button will now be enabled for your custom workflow.</p>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Visualize button disabled (built-in workflow) This is expected. Built-in workflows do not support visualization. Use a custom workflow (<code>DefineCustom&lt;T&gt;</code>) instead. Visualize button disabled (custom workflow) Check: (1) workflow <code>.cs</code> is embedded (<code>EmbeddedResource</code> with <code>LogicalName</code> in <code>.csproj</code>), (2) rebuild the project after changing <code>.csproj</code>."},{"location":"getting-started/quick-start/#how-to-view-the-flow-diagram","title":"How to view the flow diagram","text":"<p>In the Xians Manager portal, select your agent and click the enabled Visualize button.</p> <p></p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've successfully created and deployed your first Xians agent. Here's what you can explore next:</p> <ul> <li>Add Tools &amp; Functions - Extend your agent with custom capabilities</li> <li>Implement Chat History - Connect chat history for context-aware responses</li> </ul> <p>Ready to dive deeper? Check out our Core Concepts or explore Advanced Workflows.</p>"},{"location":"getting-started/tool-execution/","title":"Agents with Tools","text":"<p>Xians provides flexible tool integration that works seamlessly with your preferred agent framework. This guide shows you how to create and use tools within the Xians platform.</p>"},{"location":"getting-started/tool-execution/#overview","title":"Overview","text":"<p>Xians does not dictate or enforce a specific format for attaching tools to your agents. Instead, you can develop tools according to the recommendations of your chosen agent framework (such as Semantic Kernel, LangChain, or AutoGen).</p> <p>Within your tools, you can access Xians APIs for:</p> <ul> <li>Document DB access - Store and retrieve structured data</li> <li>Knowledge file access - Query knowledge bases and files</li> <li>Workflow orchestration - Start sub-workflows and manage execution</li> <li>Message handling - Send replies and manage conversations</li> <li>etc.</li> </ul>"},{"location":"getting-started/tool-execution/#accessing-xians-functionality","title":"Accessing Xians Functionality","text":""},{"location":"getting-started/tool-execution/#usermessagecontext","title":"UserMessageContext","text":"<p>For user message-related functionality, use the <code>UserMessageContext</code> class. This context object exposes SDKs for all operations related to the current user message.</p>"},{"location":"getting-started/tool-execution/#xianscontext","title":"XiansContext","text":"<p>For agent and workflow-level functionality, use the <code>XiansContext</code> static class:</p> <ul> <li><code>XiansContext.CurrentAgent.*</code> - Access agent-level SDKs and configuration</li> <li><code>XiansContext.CurrentWorkflow.*</code> - Access workflow-level SDKs and state</li> </ul>"},{"location":"getting-started/tool-execution/#example-creating-tool-classes","title":"Example: Creating Tool Classes","text":"<p>Here's a complete example showing how to create a tool class that integrates with Xians:</p> C#<pre><code>using System.ComponentModel;\nusing Xians.Lib.Agents.Messaging;\n\npublic class MafSubAgentTools\n{\n    private readonly UserMessageContext _context;\n\n    public MafSubAgentTools(UserMessageContext context)\n    {\n        _context = context;\n    }\n\n    [Description(\"Get the current date and time.\")]\n    public async Task&lt;string&gt; GetCurrentDateTime()\n    {\n        // User message related functionality\n        await _context.ReplyAsync($\"The current date and time is: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\");\n        var now = DateTime.Now;\n        return $\"The current date and time is: {now:yyyy-MM-dd HH:mm:ss}\";\n    }\n\n    [Description(\"Get the order data.\")]\n    public async Task&lt;string&gt; GetOrderData(int orderNumber)\n    {\n        await Task.CompletedTask;\n        // Returning elaborated dummy info for demonstration\n        return $\"Order #{orderNumber}:\\n\" +\n               $\"- Customer: John Doe\\n\" +\n               $\"- Item: Widget Pro X100\\n\" +\n               $\"- Quantity: 3\\n\" +\n               $\"- Status: Shipped\\n\" +\n               $\"- Estimated Delivery: {DateTime.Today.AddDays(3):yyyy-MM-dd}\\n\" +\n               $\"- Total: $299.97\";\n    }\n}\n</code></pre>"},{"location":"getting-started/tool-execution/#associating-tools-with-your-agent","title":"Associating Tools with Your Agent","text":"<p>Once you've created your tool class, you need to associate it with your agent. The following example demonstrates how to integrate the <code>MafSubAgentTools</code> class with an agent using Microsoft's AI Extensions framework:</p> C#<pre><code>using Microsoft.Agents.AI;\nusing Microsoft.Extensions.AI;\nusing OpenAI;\nusing OpenAI.Chat;\nusing Xians.Lib.Agents.Core;\nusing Xians.Lib.Agents.Messaging;\n\npublic class MafSubAgent\n{\n    private readonly ChatClient _chatClient;\n    public MafSubAgent(string openAiApiKey, string modelName = \"gpt-4o-mini\")\n    {\n        _chatClient = new OpenAIClient(openAiApiKey).GetChatClient(modelName);\n    }\n\n    private async Task&lt;string&gt; GetSystemPromptAsync(UserMessageContext context)\n    {\n        // You need to create a KnowledgeItem with the name \"System Prompt\" in the Xians platform.\n        var systemPrompt = await XiansContext.CurrentAgent.Knowledge.GetAsync(\"System Prompt\");\n        return systemPrompt?.Content ?? \"You are a helpful assistant.\";\n    }\n\n    public async Task&lt;string&gt; RunAsync(UserMessageContext context)\n    {\n        if (string.IsNullOrWhiteSpace(context.Message.Text))\n        {\n            return \"I didn't receive any message. Please send a message.\";\n        }\n\n        // Create tools instance with the UserMessageContext\n        var tools = new MafSubAgentTools(context);\n\n        // Configure the AI agent with tools\n        var agent = _chatClient.CreateAIAgent(new ChatClientAgentOptions\n        {\n            ChatOptions = new ChatOptions\n            {\n                Instructions = await GetSystemPromptAsync(context),\n                Tools =\n                [\n                    AIFunctionFactory.Create(tools.GetCurrentDateTime),\n                    AIFunctionFactory.Create(tools.GetOrderData)\n                ]\n            },\n            // Use Xians chat message store for conversation history\n            ChatMessageStoreFactory = ctx =&gt; new XiansChatMessageStore(context)\n        });\n\n        // Run the agent and return the response\n        var response = await agent.RunAsync(context.Message.Text);\n        return response.Text;\n    }\n}\n</code></pre>"},{"location":"getting-started/workflows/","title":"Getting Started: Temporal Workflows for Business Process Execution","text":"<p>Use Temporal workflows to run durable, fault-tolerant business processes with Xians. Workflows orchestrate activities\u2014units of work that can call external APIs, access databases, or perform other non-deterministic operations.</p> <p>This guide shows a minimal setup: one workflow, one activity, and all configuration in <code>Program.cs</code>.</p>"},{"location":"getting-started/workflows/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 9 SDK</li> <li>Xians platform instance (server URL and agent certificate)</li> <li>See Quick Start for project creation and Xians connection</li> </ul>"},{"location":"getting-started/workflows/#project-setup","title":"Project Setup","text":"<p>Add the required packages:</p> Bash<pre><code>dotnet add package DotNetEnv\ndotnet add package Xians.Lib\n</code></pre> <p>Add a project reference to Xians.Lib if using a local build, or the NuGet package as shown above.</p>"},{"location":"getting-started/workflows/#1-create-the-activity-class","title":"1. Create the Activity Class","text":"<p>Activities perform the actual work. They can call APIs, access databases, or do any I/O. Mark methods with <code>[Activity]</code>:</p> <p><code>GreetingActivities.cs</code></p> C#<pre><code>using Temporalio.Activities;\n\npublic class GreetingActivities\n{\n    [Activity]\n    public Task&lt;string&gt; BuildGreetingAsync(string name)\n    {\n        return Task.FromResult($\"Hello, {name}!\");\n    }\n}\n</code></pre>"},{"location":"getting-started/workflows/#2-create-the-workflow-class","title":"2. Create the Workflow Class","text":"<p>Workflows orchestrate activities. They must be deterministic (no direct I/O, no <code>DateTime.UtcNow</code>, etc.). Use <code>Workflow.ExecuteActivityAsync</code> to call activities:</p> <p><code>GreetingWf.cs</code></p> C#<pre><code>using Temporalio.Exceptions;\nusing Temporalio.Workflows;\n\n[Workflow(\"MyAgent:Greeting Workflow\")]\npublic class GreetingWf\n{\n    private static readonly ActivityOptions Options = new()\n    {\n        StartToCloseTimeout = TimeSpan.FromMinutes(1),\n        RetryPolicy = new RetryPolicy { MaximumAttempts = 3, BackoffCoefficient = 2 },\n    };\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; RunAsync(string name)\n    {\n        try\n        {\n            var greeting = await Workflow.ExecuteActivityAsync(\n                (GreetingActivities a) =&gt; a.BuildGreetingAsync(name),\n                Options);\n            return greeting;\n        }\n        catch (Exception ex)\n        {\n            Workflow.Logger.LogError($\"Greeting workflow failed: {ex.Message}\", ex);\n            throw new ApplicationFailureException($\"Greeting workflow failed: {ex.Message}\");\n        }\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li><code>[Workflow(\"AgentName:Workflow Name\")]</code> \u2014 Must match the agent name you register.</li> <li><code>[WorkflowRun]</code> \u2014 Marks the workflow entry point.</li> <li><code>Workflow.ExecuteActivityAsync</code> \u2014 Invokes an activity; use lambda syntax for type-safe calls.</li> </ul>"},{"location":"getting-started/workflows/#3-set-up-programcs","title":"3. Set Up Program.cs","text":"<p>Initialize the platform, register the agent, define the workflow with its activities, and start the worker:</p> <p><code>Program.cs</code></p> C#<pre><code>using DotNetEnv;\nusing Microsoft.Extensions.Logging;\nusing Xians.Lib.Agents.Core;\n\nEnv.Load();\n\nvar serverUrl = Environment.GetEnvironmentVariable(\"XIANS_SERVER_URL\")\n    ?? throw new InvalidOperationException(\"XIANS_SERVER_URL required\");\nvar apiKey = Environment.GetEnvironmentVariable(\"XIANS_API_KEY\")\n    ?? throw new InvalidOperationException(\"XIANS_API_KEY required\");\n\n// Initialize Xians Platform\nvar xiansPlatform = await XiansPlatform.InitializeAsync(new()\n{\n    ServerUrl = serverUrl,\n    ApiKey = apiKey,\n    ConsoleLogLevel = LogLevel.Information,\n    ServerLogLevel = LogLevel.Information,\n});\n\n// Register agent\nvar agent = xiansPlatform.Agents.Register(new()\n{\n    Name = \"MyAgent\",\n    IsTemplate = false,\n});\n\n// Define workflow and attach activities\nagent.Workflows\n    .DefineCustom&lt;GreetingWf&gt;(new WorkflowOptions { Activable = true })\n    .AddActivity(new GreetingActivities());\n\n// Start the agent (connects to Temporal and runs workers)\nConsole.WriteLine(\"Starting agent...\");\nawait agent.RunAllAsync(CancellationToken.None);\n</code></pre>"},{"location":"getting-started/workflows/#4-configure-environment","title":"4. Configure Environment","text":"<p>Create a <code>.env</code> file:</p> Bash<pre><code>XIANS_SERVER_URL=https://your-xians-server.com\nXIANS_API_KEY=your-agent-certificate\n</code></pre>"},{"location":"getting-started/workflows/#how-it-works","title":"How It Works","text":"<ol> <li>XiansPlatform.InitializeAsync \u2014 Connects to the Xians server and fetches Temporal configuration.</li> <li>Agents.Register \u2014 Registers your agent with the platform.</li> <li>DefineCustom&lt;GreetingWf&gt; \u2014 Registers the workflow type; <code>Activable = true</code> allows users to start it from the UI.</li> <li>AddActivity \u2014 Binds the activity instance to the workflow so Temporal can execute it.</li> <li>RunAllAsync \u2014 Starts Temporal workers that poll for and execute workflow tasks.</li> </ol> <p>Workflows run in Temporal\u2019s durable execution environment. If a worker crashes or restarts, workflows resume from the last successful activity. Activities can retry on failure based on <code>RetryPolicy</code>.</p>"},{"location":"getting-started/workflows/#further-reading","title":"Further Reading","text":"<ul> <li>Child Workflows \u2014 Start workflows from other workflows using <code>XiansContext.Workflows.StartAsync</code> (fire-and-forget) or <code>ExecuteAsync</code> (wait for result). Includes workflow ID generation and context scoping.</li> <li>Unit Testing Temporal Workflows \u2014 Test workflows in isolation with Temporal's time-skipping environment and Xians Local Mode. Includes setup, embedding knowledge, and running tests.</li> <li>Scheduling Workflows \u2014 Run workflows on a schedule (cron, interval, or one-shot). Configure schedules per workflow and manage them programmatically or via the platform UI.</li> </ul> <p>See also Logging for workflow and activity logging.</p>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":""},{"location":"introduction/features/","title":"Agent Control Plane Features","text":"<p>Xians is the open source Agent Control Plane (ACP) for production AI agents. It sits alongside your agent framework - not replacing it. It handles everything that becomes painful once agents graduate from demos to production: multi-tenant governance, business process orchestration, scalability, monitoring, and data management.</p> <p>When you register an agent (built with any framework like Azure AI Projects, LangChain, Semantic Kernel, or OpenAI SDK) with Xians, it gains enterprise-grade control plane capabilities organized around five core functions:</p>"},{"location":"introduction/features/#1-governance--multi-tenancy","title":"1. Governance &amp; Multi-Tenancy","text":"<ul> <li>Agent Registry - Centralized registration, versioning, and lifecycle management</li> <li>Multi-Tenancy - Complete tenant isolation with centralized multi-user coordination</li> <li>Template-Based Deployment - Rollout agents to multiple tenants from a single control point</li> </ul>"},{"location":"introduction/features/#2-business-process-automation","title":"2. Business Process Automation","text":"<ul> <li>Durable Workflows - Fault-tolerant processes that survive failures and span days, months, or years</li> <li>Scheduling - Time-based automation with cron, intervals, and calendar schedules</li> <li>Human-in-the-Loop - Automated workflows that pause for human review and approval</li> <li>Sub-Workflows - Composable, reusable workflow components</li> <li>Webhooks - Event-driven triggers for business process automation</li> </ul>"},{"location":"introduction/features/#3-knowledge--data-management","title":"3. Knowledge &amp; Data Management","text":"<ul> <li>Prompt Management - Centralized prompt and knowledge storage accessible from code and UI</li> <li>Document Storage - Tenant-scoped persistent storage for agent state and memory</li> <li>Conversation History - Hierarchical message organization with complete context preservation</li> </ul>"},{"location":"introduction/features/#4-visibility--monitoring","title":"4. Visibility &amp; Monitoring","text":"<ul> <li>Observability - Real-time logs, distributed tracing, and audit trails</li> <li>Performance Metrics - Response times, throughput, success rates, and bottleneck detection</li> <li>Cost Tracking - Token usage and API call monitoring across all agents and tenants</li> </ul>"},{"location":"introduction/features/#5-scalability--resilience","title":"5. Scalability &amp; Resilience","text":"<ul> <li>Horizontal Scaling - Add agent workers dynamically with automatic load distribution</li> <li>Subnet Isolation - Workers run with no incoming ports, only outbound connections</li> <li>Fault Tolerance - Automatic retries, timeouts, and failure recovery</li> <li>Framework Agnostic - Mix agents built on different stacks in the same system</li> </ul> <p>No changes to your agent's code. Because Xians is framework-agnostic, you can mix agents built on different stacks in the same system, all governed by a unified control plane.</p>"},{"location":"introduction/features/#agent-registry","title":"Agent Registry","text":"<p>Part of: Governance &amp; Multi-Tenancy</p> <p>The control plane's agent registry provides centralized lifecycle management and coordination for your entire fleet.</p> <p>Build with any framework - Microsoft Agent Framework, LangChain, Semantic Kernel, or raw OpenAI SDK - and register it with Xians. Each agent receives a unique identity and automatic integration with the control plane's governance, monitoring, and orchestration capabilities.</p> <p>Key capabilities:</p> <ul> <li>Framework-agnostic: Bring your own agent implementation - the control plane doesn't care</li> <li>Centralized registry: Single source of truth for all agents across all tenants</li> <li>Version control: Track agent versions, configurations, and deployment history</li> <li>Lifecycle management: Publish, deploy, update, rollback, and decommission agents from one control point</li> </ul>"},{"location":"introduction/features/#template-based-deployment","title":"Template-Based Deployment","text":"<p>Part of: Governance &amp; Multi-Tenancy</p> <p>Publish agents as reusable templates and rollout to multiple tenants with consistent configurations from a centralized control point.</p> <p>Key capabilities:</p> <ul> <li>Agent templates: Define once, deploy to many tenants</li> <li>Configuration per tenant: Same agent, different prompts and configurations per tenant</li> <li>Centralized updates: Update templates and propagate changes across all deployments</li> <li>Deployment tracking: Monitor which tenants have which agent versions</li> <li>Rollback capability: Revert to previous versions if issues arise</li> </ul>"},{"location":"introduction/features/#multi-tenancy","title":"Multi-Tenancy","text":"<p>Part of: Governance &amp; Multi-Tenancy</p> <p>The control plane provides complete isolation of agents, workflows, data, and conversations across tenants while sharing infrastructure efficiently. Coordinate multi-user operations within tenants and enforce governance across your entire organization. Two deployment models:</p> Deployment Model What It Means When to Use System-Scoped One runtime serves all tenants Common agents rolled out to multiple tenants Tenant-Scoped Dedicated runtime per tenant Custom logic, dedicated resources, specialized agents <p>Key capabilities:</p> <ul> <li>Tenant isolation: Each tenant's workflows, data, and conversations are completely separated</li> <li>Multi-user coordination: Multiple users within a tenant can interact with agents simultaneously</li> <li>Resource governance: Implement per-tenant quotas and rate limits</li> <li>Custom configurations: Same agent using different prompts or configurations per tenant</li> <li>Centralized management: Manage all tenants from a single control plane instance</li> </ul> <p>Deploy system agents for common use cases, create tenant-scoped agents for custom requirements or resource isolation.</p>"},{"location":"introduction/features/#agent-user-collaboration","title":"Agent-User Collaboration","text":"<p>Part of: Knowledge &amp; Data Management</p> <p>The control plane provides rich, asynchronous messaging between users and agents with persistent conversation history and hierarchical context management.</p> <p>Messages aren't just text - they're the conversational memory that makes agents intelligent and contextual. Each message thread maintains state across sessions, enabling multi-turn dialogues where agents remember context, preferences, and history.</p> <p>Xians provides a sophisticated message hierarchy with complete isolation at every level, allowing agents and users to scope conversations for their specific work:</p> <pre><code>graph TD\n    T[Tenant] --&gt;|has many| A[Agents]\n    A --&gt;|has many| W[Workflows]\n    W --&gt;|has many| TH[Conversation Threads]\n    TH --&gt;|has many| S[Topics/Scopes]\n    S --&gt;|has many| M[Messages]\n\n    style T fill:#eea52d,stroke:#333,stroke-width:2px,color:#1b1f2f\n    style A fill:#538cfc,stroke:#333,stroke-width:2px,color:#fff\n    style W fill:#41c18a,stroke:#333,stroke-width:2px,color:#fff\n    style TH fill:#9b59b6,stroke:#333,stroke-width:2px,color:#fff\n    style S fill:#e74c3c,stroke:#333,stroke-width:2px,color:#fff\n    style M fill:#95a5a6,stroke:#333,stroke-width:2px,color:#fff</code></pre> <p>This hierarchy enables powerful conversation organization: a single tenant can have multiple agents, each with different workflows handling various interactions. Within each workflow, users can maintain separate conversation threads, and even within a thread, organize messages by topic for cleaner context management</p> <p>Key capabilities:</p> <ul> <li>Conversation hierachy: Automatic context preservation across sessions</li> <li>Multiple transports: WebSocket, Server-Sent Events (SSE), REST APIs</li> <li>Rich messages: Text, structured data, and HITL Tasks</li> <li>Security: Message encryption, EU AI Act compliant</li> <li>Authentication: API keys or OIDC/OAuth 2.0 integration</li> </ul> <p>Users can interact with agents across different conversation threads, with full history and context automatically managed.</p>"},{"location":"introduction/features/#agent-agent-collaboration","title":"Agent-Agent Collaboration","text":"<p>Part of: Business Process Automation</p> <p>The control plane orchestrates multiple agents working together to solve complex business problems through the Agent-to-Agent (A2A) protocol and workflow coordination.</p> <p>Complex agentic systems often require multiple specialized agents collaborating as a team - one agent conversing with users, another analyzing data, one searching and reading the web, another making decisions. Xians enables sophisticated multi-agent architectures through two key mechanisms:</p> <p>Multi-Workflow Agents: A single agent can contain multiple specialized workflows, each handling a specific responsibility (conversation, research, analysis, decision-making). These workflows operate as a coordinated team behind a unified agent interface.</p> <p>Agent-to-Agent Protocol (A2A): Agents communicate with each other using Xians' A2A protocol SDK, which provides in-process communication for speed and resource optimization. Messages are routed, context is shared, and results are aggregated automatically.</p> <pre><code>graph TB\n    U[User] --&gt;|Message| A1[Customer Support Agent]\n\n    subgraph A1_Team[Customer Support Agent - Multi-Workflow]\n        A1W1[Conversation Workflow]\n        A1W2[Analysis Workflow]\n        A1W3[Action Workflow]\n    end\n\n    A1 --&gt; A1W1\n    A1W1 --&gt;|A2A Protocol| A1W2\n    A1W2 --&gt;|A2A Protocol| A1W3\n\n    A1W3 --&gt;|A2A Protocol| A2[Knowledge Agent]\n    A1W3 --&gt;|A2A Protocol| A3[Data Agent]\n\n    subgraph A2_Team[Knowledge Agent - Multi-Workflow]\n        A2W1[Search Workflow]\n        A2W2[RAG Workflow]\n    end\n\n    A2 --&gt; A2W1\n    A2W1 --&gt; A2W2\n    A2W2 --&gt;|Results| A1W3\n    A3 --&gt;|Results| A1W3\n\n    A1W3 --&gt; A1W1\n    A1W1 --&gt;|Response| U\n\n    style A1 fill:#538cfc,stroke:#333,stroke-width:3px,color:#fff\n    style A2 fill:#41c18a,stroke:#333,stroke-width:3px,color:#fff\n    style A3 fill:#e74c3c,stroke:#333,stroke-width:3px,color:#fff\n    style A1W1 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A1W2 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A1W3 fill:#7fb3ff,stroke:#333,stroke-width:1px,color:#000\n    style A2W1 fill:#6dd5a5,stroke:#333,stroke-width:1px,color:#000\n    style A2W2 fill:#6dd5a5,stroke:#333,stroke-width:1px,color:#000</code></pre> <p>This architecture enables building sophisticated agent teams where each agent specializes in a domain (customer support, data analysis, web research) and each workflow within an agent handles a specific task type.</p>"},{"location":"introduction/features/#human-in-the-loop","title":"Human-in-the-Loop","text":"<p>Part of: Business Process Automation</p> <p>The control plane enables automated business workflows that pause for hours, days, or weeks waiting for human input, then automatically resume.</p> <pre><code>sequenceDiagram\n    participant W as Agent Workflow\n    participant T as Task\n    participant H as Human Reviewer\n\n    W-&gt;&gt;T: Create Task with Draft\n    T-&gt;&gt;H: Assigned To\n    Note over W: Workflow pauses&lt;br/&gt;(can wait hours/days/weeks)\n    H-&gt;&gt;T: Review &amp; Edit Draft in Task\n    H-&gt;&gt;T: Approve/Reject Decision\n    T-&gt;&gt;W: Resume with Feedback\n    Note over W: Workflow continues\n    W-&gt;&gt;W: Process Next Steps</code></pre> <p>Key capabilities:</p> <ul> <li>Task creation: Agents create tasks requiring human judgment</li> <li>Draft review: Human reviewers edit and approve agent outputs</li> <li>Flexible timing: Workflows can wait indefinitely for human input</li> <li>Approval chains: Multi-step review processes with multiple tasks</li> <li>Audit trails: Complete history of reviews and decisions</li> </ul> <p>Agents create tasks, attach drafts, and wait for approval. Humans review, edit, approve, or reject. Workflow continues with the feedback. Everything tracked in the audit trail.</p>"},{"location":"introduction/features/#long-running-workflows","title":"Long-Running Workflows","text":"<p>Part of: Business Process Automation</p> <p>Built on Temporal, the control plane orchestrates fault-tolerant, durable workflows that handle complex business processes spanning days, months, or years with automatic state management and recovery.</p> <p>Traditional automation breaks on long-running processes. Xians workflows are durable, maintaining state across restarts, failures, and deployments. A customer onboarding workflow can span weeks; an annual compliance workflow runs for months; a scheduled report runs every day for years - all reliably managed.</p> <p>Key capabilities:</p> <ul> <li>Fault tolerance: Workflows survive agent failures, infrastructure restarts, and network outages</li> <li>Automatic retries: Transient failures are automatically retried with configurable policies</li> <li>State persistence: Maintain complete context across distributed operations and long time spans</li> <li>Composition: Orchestrate complex multi-step business processes with sub-workflows</li> <li>Timeout handling: Configure timeouts at every step to handle stuck processes</li> </ul> <p>Each agent can have multiple workflows for different business processes: conversations, scheduled tasks, event handlers, or custom workflows. The \"Default Workflow\" gives you all platform functions out-of-the-box.</p>"},{"location":"introduction/features/#fault-tolerance","title":"Fault Tolerance","text":"<p>Part of: Scalability &amp; Resilience</p> <p>The control plane's fault tolerance ensures business processes continue even when individual components fail.</p> <p>Key capabilities:</p> <ul> <li>Automatic retries: Failed operations are retried automatically with exponential backoff</li> <li>Timeout policies: Prevent workflows from hanging indefinitely with configurable timeouts</li> <li>Graceful degradation: Workflows continue even when external services are temporarily unavailable</li> <li>State recovery: Workflow state is persisted and recovered automatically after crashes</li> <li>Partial failure handling: Handle failures in sub-workflows without failing the entire process</li> </ul>"},{"location":"introduction/features/#scheduling","title":"Scheduling","text":"<p>Part of: Business Process Automation</p> <p>The control plane provides time-based business process automation with a modern, fluent API that works the same everywhere - in regular code, agent tools, and even inside workflows themselves.</p> <p>Time-based automation enables autonomous business processes - generating reports at 9 AM, processing overnight data, sending weekly summaries, running monthly analytics - without manual triggers.</p> <p>Key capabilities:</p> <ul> <li>Flexible scheduling: Cron expressions, intervals, daily/weekly/monthly helpers, or one-time calendar schedules</li> <li>Timezone support: Schedule in any timezone using IANA timezone database</li> <li>Workflow-aware: Same API works both inside and outside workflows with automatic determinism</li> <li>Full lifecycle management: Create, pause, resume, trigger, update, and delete schedules programmatically</li> <li>Dynamic creation: Agents create schedules based on conversations or business logic</li> <li>Multi-tenant isolation: Automatic tenant scoping and isolation</li> <li>Durable execution: Schedules survive restarts and system failures</li> </ul> <p>Manage everything programmatically via SDK or through the UI. Built on Temporal's durable execution for reliability.</p>"},{"location":"introduction/features/#webhooks","title":"Webhooks","text":"<p>Part of: Business Process Automation</p> <p>Event-driven triggers enable agents to respond to external events and integrate into broader business process automation.</p> <p>Key capabilities:</p> <ul> <li>Inbound webhooks: Receive events from external systems to trigger agent workflows</li> <li>Outbound webhooks: Send agent events and results to external systems for process continuation</li> <li>Cross-platform integration: Connect agents with Microsoft 365, Kubernetes, third-party tools, and custom applications</li> <li>Event routing: Route events to the appropriate agents and workflows based on content and metadata</li> <li>Async processing: Webhook requests are queued and processed asynchronously for scalability</li> </ul>"},{"location":"introduction/features/#document-storage","title":"Document Storage","text":"<p>Part of: Knowledge &amp; Data Management</p> <p>The control plane provides persistent, tenant-scoped JSON document storage for agent state, memory, and data. Save user preferences, conversation memory, session state, analytics - any data your agents need to remember across workflow executions.</p> <p>Agents need structured memory beyond conversations. Document storage provides flexible JSON persistence with semantic keys, metadata filtering, and automatic cleanup - without database complexity.</p> <p>Key capabilities:</p> <ul> <li>JSON storage: Store any JSON-serializable object with no schema constraints</li> <li>Semantic keys: Use meaningful identifiers like \"user-123-preferences\" instead of random IDs</li> <li>Metadata filtering: Query by type, metadata fields, and date ranges</li> <li>TTL support: Auto-delete documents after expiration (sessions, caches, temporary data)</li> <li>Dual access: Available at agent-level and from within workflow contexts</li> <li>Tenant isolation: Automatic data separation per tenant - no cross-tenant data leakage</li> </ul> <p>Common use cases: conversation memory, user preferences, session state, analytics tracking, API response caching, business process state. Simple, fast, and purpose-built for agent workflows.</p>"},{"location":"introduction/features/#configuration-management","title":"Configuration Management","text":"<p>Part of: Knowledge &amp; Data Management</p> <p>Centralized prompt and knowledge management through the control plane. Both agents (via code) and humans (via UI) can read and write the same knowledge, enabling no-code updates to agent behavior.</p> <p>Also known as Knowledge Management or Prompt Management.</p> <p>Agents need more than just code - they need prompts, instructions, configs, and reference data that can be updated without redeployment. The control plane provides a centralized knowledge store accessible to both code and humans.</p> <p>Key capabilities:</p> <ul> <li>Dual access: Agents use SDK methods, humans use UI portal - same data, synchronized</li> <li>Automatic scoping: Per-agent and per-tenant isolation</li> <li>Multiple content types: AI prompts, instructions, JSON configs, markdown docs, preferences</li> <li>Version tracking: Track changes to prompts and configurations over time</li> <li>Simple CRUD: Get, update, delete, and list operations via SDK or UI</li> <li>Fast retrieval: Automatic caching for performance</li> <li>No schema constraints: Store any text content</li> </ul> <p>Common uses: AI prompts editable via UI, user preferences, feature flags, instructions, API configurations, templates, FAQ content. Update agent behavior without redeployment by changing prompts in the UI.</p>"},{"location":"introduction/features/#sub-workflows","title":"Sub-Workflows","text":"<p>Part of: Business Process Automation</p> <p>The control plane supports composable workflow components that can be reused across different parent workflows to build modular business processes.</p> <p>Complex business processes benefit from modularity. Sub-workflows are reusable building blocks - a \"send email\" sub-workflow, a \"verify identity\" sub-workflow, a \"generate report\" sub-workflow - that compose into larger processes.</p> <p>Key capabilities:</p> <ul> <li>Reusability: Define once, use across multiple parent workflows and business processes</li> <li>Composition: Nest workflows for clean, maintainable architecture</li> <li>Independent scaling: Sub-workflows can have different worker pools for resource optimization</li> <li>Isolated testing: Test sub-workflows independently before composing</li> <li>Failure isolation: Sub-workflow failures can be handled without cascading to parent workflow</li> </ul> <p>Build a library of business process components. Compose them into sophisticated multi-step processes. Maintain and test each piece separately.</p>"},{"location":"introduction/features/#observability","title":"Observability","text":"<p>Part of: Visibility &amp; Monitoring</p> <p>The control plane provides comprehensive logs, distributed tracing, and audit trails to monitor agent operations and debug issues across your entire fleet.</p> <p>Key capabilities:</p> <ul> <li>Structured logs: Auto-captured with stack traces, searchable by agent/tenant/workflow/time in the UI</li> <li>Distributed tracing: OpenTelemetry support with correlation IDs to trace requests across agents and workflows</li> <li>Workflow history: Complete execution history for every workflow with state transitions</li> <li>Audit trails: Immutable execution history - every workflow, action, and decision timestamped</li> <li>Real-time monitoring: View logs and traces in real-time as workflows execute</li> <li>Integration: Export to Datadog, New Relic, Grafana, and other observability platforms</li> </ul> <p>Debug complex multi-agent workflows by tracing requests across the entire system. View complete execution history to understand what happened and when.</p>"},{"location":"introduction/features/#metrics--usage-tracking","title":"Metrics &amp; Usage Tracking","text":"<p>Part of: Visibility &amp; Monitoring</p> <p>The control plane provides comprehensive metrics tracking for everything your agents do - from LLM token usage to business outcomes - with zero configuration required.</p> <p>Track agent work across technical (tokens, API calls), business (approvals, documents), and operational (HITL tasks) layers. The metrics system auto-captures context (tenant, user, workflow) so you focus on tracking what matters to your business.</p> <p>Key capabilities:</p> <ul> <li>Automatic context: Every metric includes tenant, user, workflow, and agent attribution automatically</li> <li>Flexible tracking: Track any metric with any label - tokens, business outcomes, performance data</li> <li>Universal API: Same metrics API works in workflows, activities, and message handlers</li> <li>Smart routing: A2A-aware and workflow-aware with automatic determinism handling</li> <li>Custom correlation: Link metrics to your external systems with custom identifiers</li> </ul> <p>Common patterns:</p> C#<pre><code>// Track LLM usage\nawait context.Metrics\n    .ForModel(\"gpt-4\")\n    .WithMetrics(\n        (\"tokens\", \"prompt\", 45, \"tokens\"),\n        (\"tokens\", \"completion\", 105, \"tokens\")\n    )\n    .ReportAsync();\n\n// Track business outcomes  \nawait context.Metrics\n    .WithMetrics(\n        (\"approvals\", \"submitted\", 1, \"count\"),\n        (\"documents\", \"generated\", 1, \"count\"),\n        (\"emails\", \"sent\", 3, \"count\")\n    )\n    .ReportAsync();\n</code></pre> <p>\u2192 Complete Metrics Guide for detailed usage patterns and advanced features.</p>"},{"location":"introduction/features/#performance-metrics","title":"Performance Metrics","text":"<p>Part of: Visibility &amp; Monitoring</p> <p>Track operational performance in real-time to identify bottlenecks, optimize resource usage, and ensure SLAs are met.</p> What We Track Why Response times, latency Find bottlenecks and optimize performance Throughput (workflows/sec) Monitor load and capacity planning Success/failure rates Catch issues and track reliability Queue depths Detect backlog and scaling needs Worker utilization Optimize worker pool sizes <p>Key capabilities:</p> <ul> <li>Real-time dashboards: Visualize performance across all agents and tenants</li> <li>Anomaly detection: Identify performance degradation and failures automatically</li> <li>SLA monitoring: Track agent reliability against service level objectives</li> <li>Bottleneck identification: Find slow workflows and optimize them</li> </ul>"},{"location":"introduction/features/#cost-tracking","title":"Cost Tracking","text":"<p>Part of: Visibility &amp; Monitoring</p> <p>The control plane tracks resource consumption and costs across your agent fleet in real-time, enabling cost optimization and chargeback.</p> What We Track Why Token usage per agent/tenant Control LLM costs and attribute to customers API calls and volumes Monitor consumption patterns Cost per workflow Identify expensive operations Resource utilization Optimize infrastructure costs <p>Key capabilities:</p> <ul> <li>Per-tenant tracking: Attribute costs to specific tenants for chargeback and budgeting</li> <li>Budget alerts: Set spending limits and receive alerts when exceeded (planned)</li> <li>Cost optimization: Identify expensive agents and workflows for optimization</li> <li>Usage trends: Analyze cost trends over time to forecast spending</li> </ul>"},{"location":"introduction/features/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Part of: Scalability &amp; Resilience</p> <p>The control plane enables horizontal scaling by distributing work across multiple agent worker containers automatically.</p> <p>Key capabilities:</p> <ul> <li>Dynamic worker pools: Add or remove worker containers on demand - work is automatically distributed</li> <li>Automatic load balancing: Temporal distributes tasks across available workers based on capacity</li> <li>No manual configuration: Workers auto-register when they start - no service discovery needed</li> <li>Per-tenant scaling: Scale different worker pools for different tenants or agent types</li> <li>Resource optimization: Scale workers independently from the control plane server</li> </ul> <p>Simply deploy more worker containers and watch throughput increase linearly. Scale down during off-hours to save costs.</p>"},{"location":"introduction/features/#subnet-isolation","title":"Subnet Isolation","text":"<p>Part of: Scalability &amp; Resilience</p> <p>Agent workers can run in private subnets with no incoming ports, only making outbound connections to pull tasks from the control plane.</p> <p>Key capabilities:</p> <ul> <li>No incoming ports: Workers never accept inbound connections - they only pull tasks via outbound connections</li> <li>Simplified security: No need to expose agent workers to the internet or configure inbound firewall rules</li> <li>Pull-based architecture: Workers poll the Temporal queue for tasks, eliminating the need for service discovery</li> <li>Network isolation: Run workers in isolated subnets or VPCs with restricted network access</li> <li>Defense in depth: Reduced attack surface since workers can't be directly accessed</li> </ul> <p>This architecture is ideal for security-conscious deployments where agents need to be isolated from external access.</p>"},{"location":"introduction/features/#framework-agnostic","title":"Framework Agnostic","text":"<p>Part of: Scalability &amp; Resilience</p> <p>The control plane works with any agent framework or implementation approach, enabling you to choose the best tool for each job.</p> <p>Key capabilities:</p> <ul> <li>No framework lock-in: Use Microsoft Agent Framework, LangChain, Semantic Kernel, OpenAI SDK, or custom implementations</li> <li>Mix and match: Run agents built on different frameworks within the same control plane</li> <li>Bring your own LLM: Use OpenAI, Azure OpenAI, Anthropic, local models, or any LLM provider</li> <li>Language support: Currently supports .NET agents, with Python and TypeScript SDKs planned</li> <li>Migration friendly: Migrate from one framework to another without changing the control plane</li> </ul> <p>Build each agent with the framework that makes the most sense, then govern them all through a unified control plane.</p>"},{"location":"introduction/features/#the-control-plane-advantage","title":"The Control Plane Advantage","text":"<p>Xians is the Agent Control Plane that transforms AI agents from demos to production-grade systems. Keep your agent code focused on AI logic. Let the control plane handle multi-tenant governance, business process orchestration, horizontal scalability, monitoring, and data management.</p> <p>Not another agent framework. The open source control plane that provides centralized, proactive control over your entire agent fleet - enabling reliable, scalable, and observable deployment of AI-powered business processes across your organization.</p>"},{"location":"introduction/overview/","title":"Introduction","text":"<p>Welcome to Xians.ai - the open source Agent Control Plane (ACP) for governing, monitoring, securing, and managing fleets of AI agents at enterprise scale.</p>"},{"location":"introduction/overview/#what-is-an-agent-control-plane","title":"What is an Agent Control Plane?","text":"<p>An Agent Control Plane (ACP) is a centralized platform that acts as a \"control tower\" for autonomous AI systems. Instead of reactive guardrails, Xians provides proactive, architectural control for orchestrating business processes, governing multi-tenant operations, and managing agent fleets at scale across your entire organization.</p> <p>Xians sits alongside your agent framework - not replacing it. Build agents with any framework (Microsoft Agent Framework, LangChain, Semantic Kernel, or raw OpenAI SDK), then register them with Xians to get enterprise-grade orchestration, governance, monitoring, scalability, and data management.</p>"},{"location":"introduction/overview/#core-acp-functions","title":"Core ACP Functions","text":"Function What Xians Provides Governance &amp; Multi-Tenancy Centralized multi-tenant isolation, multi-user coordination, agent registry, policy enforcement, template-based deployment across tenants Business Process Automation Fault-tolerant durable workflows, scheduled automation, event-driven triggers, human-in-the-loop processes, long-running orchestration Knowledge &amp; Data Management Centralized prompt/knowledge management, document storage, conversation history, tenant-scoped data isolation Visibility &amp; Monitoring Real-time logs, distributed tracing, performance metrics, cost tracking, health monitoring, audit trails Scalability &amp; Resilience Horizontal agent worker scaling, subnet-isolated deployments (no incoming ports), automatic failover, distributed execution Page Description Where Does it Fit Learn how Xians integrates as your Agent Control Plane - architecture, scalability, and deployment models Features Explore the complete ACP feature set: governance, business processes, knowledge management, monitoring, and scalability"},{"location":"introduction/where-does-it-fit/","title":"Where Does it Fit?","text":"<p>Xians is an Agent Control Plane (ACP) that provides centralized governance, orchestration, and monitoring for your entire fleet of AI agents. It integrates into your architecture as a dedicated Agent Microservice, sitting between your web server and AI agents to coordinate multi-tenant operations, orchestrate business processes, and scale agent workloads across your infrastructure.</p>"},{"location":"introduction/where-does-it-fit/#architecture-overview","title":"Architecture Overview","text":"<p>The diagram above illustrates how Xians operates as a control plane in a typical microservices architecture:</p> <ol> <li>Your Product UI - Your frontend application where users interact with your product</li> <li>Your Web Server - Your backend/BFF (Backend for Frontend) layer that handles UI logic</li> <li>Agent Control Plane (Xians Server) - The centralized platform governing all AI agents</li> <li>Your Agents - The AI agents registered with and controlled by Xians</li> </ol>"},{"location":"introduction/where-does-it-fit/#centralized-governance--orchestration","title":"Centralized Governance &amp; Orchestration","text":"<p>As a control plane, Xians provides a single point of governance and coordination for your entire agent fleet:</p> <ul> <li>Multi-Tenant Governance: Complete tenant isolation with centralized management - deploy agents across tenants from a single control point</li> <li>Business Process Orchestration: Coordinate complex, long-running workflows with fault tolerance and automatic retries</li> <li>Unified Visibility: Monitor health, performance, costs, and operations across all agents and tenants from one platform</li> <li>Lifecycle Management: Register, deploy, version, configure, and decommission agents centrally with template-based rollouts</li> <li>Knowledge Management: Centralize prompts, configurations, and agent knowledge accessible to both code and UI</li> </ul>"},{"location":"introduction/where-does-it-fit/#direct-integration-option","title":"Direct Integration Option","text":"<p>The Xians Server can use OIDC to connect directly with your web UI in scenarios where a BFF/Web Server layer is not mediating the communication. Developers may use the Xians TypeScript SDK (Optional) to easily integrate with the server's APIs and leverage the control plane's capabilities.</p>"},{"location":"introduction/where-does-it-fit/#control-plane-components","title":"Control Plane Components","text":"<p>Xians is built with a modular architecture comprising the following major components:</p> <p></p> <ol> <li>Xians Server - The core control plane engine that provides APIs for policy enforcement, monitoring, and agent orchestration. Includes both Web and Temporal servers.</li> <li>Xians UI - A comprehensive management console for governing agents, monitoring operations, viewing metrics, configuring policies, and managing lifecycles across your entire fleet</li> <li>Xians Lib - A .NET Core class library that agents use to register with the control plane and communicate securely with Xians Server</li> <li>Xians Agent Studio \u2013 An optional, standalone UI that allows you to quickly onboard human users and enable collaboration with AI agents through chat conversations and human-in-the-loop tasks, right out of the box.</li> </ol>"},{"location":"introduction/where-does-it-fit/#layered-architecture-view","title":"Layered Architecture View","text":"<p>Understanding where an Agent Control Plane fits in your architecture helps clarify its role and value. The diagram below illustrates Xians' position in a layered view:</p> <p></p> <p>The ACP sits between your agents and the external world - mediating all interactions with users, systems, and external services. This architectural position enables the control plane to:</p> <p>Orchestrate External Interactions:</p> <ul> <li>Route messages between users and agents through conversation APIs</li> <li>Handle webhook events from external systems to trigger workflows</li> <li>Coordinate multi-agent collaboration for A2A</li> <li>Manage integrations with third-party platforms and services</li> </ul> <p>Provide Agent Utilities:</p> <ul> <li>Tenant-scoped data storage for state and memory</li> <li>Centralized prompt and knowledge management</li> <li>Scheduling infrastructure for time-based automation</li> <li>Conversation history with hierarchical organization</li> </ul> <p>Governance &amp; Observability:</p> <ul> <li>Multi-tenant isolation with centralized policy enforcement</li> <li>Real-time monitoring with logs, metrics, and distributed tracing</li> <li>Cost tracking across agents and tenants</li> <li>Audit trails for compliance and debugging</li> </ul> <p>Infrastructure Abstraction:</p> <ul> <li>Distributed networking and load balancing across agent workers</li> <li>Fault tolerance with automatic retries and state recovery</li> <li>Horizontal scalability with dynamic worker pools</li> <li>Network isolation (agents run in private subnets with no incoming ports)</li> </ul> <p>By handling these cross-cutting concerns, the control plane allows your agents to focus purely on business logic while the platform manages multi-tenancy, orchestration, scalability, monitoring, and infrastructure complexity.</p>"},{"location":"introduction/where-does-it-fit/#built-on-temporal-for-durable-orchestration","title":"Built on Temporal for Durable Orchestration","text":"<p>Xians leverages the industry-proven open source Temporal workflow server as its orchestration foundation. This enables the control plane to reliably manage business processes and agent workflows at scale:</p> <ul> <li>Distributed Execution - Agents run as independent worker processes focused on business logic, while the control plane handles orchestration and coordination</li> <li>Fault Tolerance - Built-in timeout and retry policies ensure resilient execution even when agents fail or infrastructure restarts</li> <li>Long-running Processes - Orchestrate durable, multi-step business workflows that can span minutes, hours, days, or even years with state managed reliably</li> <li>Scheduled Workflows - Time-based automation with cron expressions, intervals, and calendar schedules for recurring business processes</li> <li>Horizontal Scalability - Simply add more agent worker containers and watch Xians automatically distribute the workload</li> <li>Audit Trail - Every workflow execution is recorded with complete history for debugging and compliance tracking</li> </ul>"},{"location":"introduction/where-does-it-fit/#scalable--secure-worker-architecture","title":"Scalable &amp; Secure Worker Architecture","text":"<p>Agent workers operate in a pull-based architecture that enables massive scalability and secure deployment:</p> <pre><code>graph LR\n    CP[Xians Control Plane&lt;br/&gt;Public Endpoint] --&gt;|Task Queue| TQ[Temporal Queue]\n\n    subgraph Private Subnet - No Incoming Ports\n        TQ -.-&gt;|Pull Tasks| W1[Agent Worker 1]\n        TQ -.-&gt;|Pull Tasks| W2[Agent Worker 2]\n        TQ -.-&gt;|Pull Tasks| W3[Agent Worker N]\n    end\n\n    style CP fill:#538cfc,stroke:#333,stroke-width:2px,color:#fff\n    style TQ fill:#41c18a,stroke:#333,stroke-width:2px,color:#fff\n    style W1 fill:#eea52d,stroke:#333,stroke-width:2px,color:#1b1f2f\n    style W2 fill:#eea52d,stroke:#333,stroke-width:2px,color:#1b1f2f\n    style W3 fill:#eea52d,stroke:#333,stroke-width:2px,color:#1b1f2f</code></pre> <p>Key benefits:</p> <ul> <li>Subnet Isolation: Agent workers run in private subnets with no incoming ports - they only make outbound connections to pull tasks</li> <li>Horizontal Scaling: Add or remove worker containers dynamically based on load - Temporal automatically balances work distribution</li> <li>Network Security: Workers never accept inbound connections, reducing attack surface and simplifying firewall rules</li> <li>Multi-Tenant Isolation: Different worker pools can serve different tenants or security zones</li> <li>Auto-Discovery: Workers automatically register with the control plane when they start - no manual configuration needed</li> </ul>"},{"location":"introduction/where-does-it-fit/#asynchronous-processing--scalability","title":"Asynchronous Processing &amp; Scalability","text":"<p>The control plane manages agent interactions through a fully asynchronous message queue architecture, ensuring massive scalability and resilience:</p> <pre><code>sequenceDiagram\n    participant External as External System\n    participant XServer as Xians Control Plane\n    participant Queue as Temporal Queue\n    participant Agent as Agent Worker (Xians Lib)\n\n    External-&gt;&gt;XServer: HTTP Request (e.g., Webhook)\n    Note over XServer: Route &amp; Queue\n    XServer-&gt;&gt;Queue: Enqueue Task\n    Note over Queue: Work Distribution\n    Queue-&gt;&gt;Agent: Pull Task (Outbound Only)\n    Note over Agent: Execute Business Logic\n    Agent-&gt;&gt;XServer: Return Response\n    Note over XServer: Log &amp; Metrics\n    XServer-&gt;&gt;External: HTTP Response</code></pre> <p>Even when you send a synchronous HTTP webhook request, the control plane processes it asynchronously using queues with configurable timeouts. This architecture enables:</p> <ul> <li>Massive Scalability - Handle high loads by distributing work across hundreds or thousands of agent workers</li> <li>Stateless Execution - Each task is processed independently, making workers easy to scale horizontally without shared state</li> <li>Resilient Operations - Automatic retries, timeouts, and failure handling ensure reliable execution even during outages</li> <li>Load Balancing - Temporal automatically distributes tasks to available workers based on capacity</li> <li>Complete Observability - Every interaction is logged with distributed tracing for debugging and performance analysis</li> </ul>"},{"location":"other/privacy-policy/","title":"Privacy Policy","text":"<p>Last Updated: January 23, 2026</p>"},{"location":"other/privacy-policy/#overview","title":"Overview","text":"<p>This privacy policy applies to:</p> <ul> <li>Xians Open Source Components: Self-hosted installations (covered under MIT License)</li> <li>agentri.ai Hosted Service: Our managed cloud service</li> </ul>"},{"location":"other/privacy-policy/#open-source-components-self-hosted","title":"Open Source Components (Self-Hosted)","text":"<p>When you self-host Xians components:</p> <ul> <li>We do not collect any data from your self-hosted installation</li> <li>You have full control over all data processed by the system</li> <li>You are responsible for your own data privacy and security practices</li> <li>Standard telemetry and analytics are disabled by default</li> </ul>"},{"location":"other/privacy-policy/#agentriai-hosted-service","title":"agentri.ai Hosted Service","text":"<p>\u26a0\ufe0f IMPORTANT - FREE TESTING SERVICE:</p> <ul> <li>This is a free testing service with NO guarantees</li> <li>Use at your own risk - we can stop the service at any time</li> <li>Do NOT store sensitive, confidential, or production data</li> <li>Data may be deleted at any time without notice</li> <li>No SLA or data retention guarantees</li> </ul>"},{"location":"other/privacy-policy/#information-we-collect","title":"Information We Collect","text":"<p>Account Information:</p> <ul> <li>Email address</li> <li>Organization name</li> <li>Authentication credentials</li> </ul> <p>Usage Data:</p> <ul> <li>API usage metrics</li> <li>Service performance logs</li> <li>Error reports</li> <li>API request and response data</li> </ul> <p>Agent Data:</p> <ul> <li>Agent configurations and settings</li> <li>Agent templates and workflows</li> <li>Agent actions and executions</li> <li>Agent performance metrics</li> <li>Scheduled tasks and automations</li> <li>Human-in-the-loop (HITL) task data</li> </ul> <p>Content Data:</p> <ul> <li>Conversation histories and messages</li> <li>User prompts and agent responses</li> <li>Documents and knowledge base content you upload</li> <li>Context and memory data</li> <li>Tool execution results</li> </ul> <p>Secrets and Credentials:</p> <ul> <li>API keys and tokens created on the platform</li> <li>Webhook URLs and configurations</li> <li>Third-party service credentials you provide</li> <li>Integration authentication data</li> </ul> <p>\u26a0\ufe0f IMPORTANT: All data is stored on our testing infrastructure with no guarantees of security or retention.</p>"},{"location":"other/privacy-policy/#how-we-use-your-information","title":"How We Use Your Information","text":"<ul> <li>Provide and maintain the service</li> <li>Monitor service performance and reliability</li> <li>Improve our products and features</li> <li>Respond to support requests</li> <li>Send service-related notifications</li> </ul>"},{"location":"other/privacy-policy/#data-storage-and-security","title":"Data Storage and Security","text":"<ul> <li>Messages are encrypted in transit (TLS) and at rest</li> <li>We use industry-standard security practices</li> <li>Data is stored in secure cloud infrastructure</li> <li>Regular security audits and updates</li> </ul>"},{"location":"other/privacy-policy/#data-retention","title":"Data Retention","text":"<p>Testing Service Notice: As a free testing service, we provide no guarantees on data retention.</p> <ul> <li>Account data: Retained while your account is active (may be deleted without notice)</li> <li>Usage logs: Retained for up to 90 days</li> <li>Content data: May be deleted at any time as part of testing and maintenance</li> <li>Account deletion: Data deleted within 30 days</li> </ul>"},{"location":"other/privacy-policy/#your-rights","title":"Your Rights","text":"<p>You have the right to:</p> <ul> <li>Access your personal data</li> <li>Request data correction or deletion</li> <li>Export your data</li> <li>Opt out of non-essential communications</li> </ul>"},{"location":"other/privacy-policy/#third-party-services","title":"Third-Party Services","text":"<p>We may use third-party services for:</p> <ul> <li>Cloud infrastructure (hosting)</li> <li>Authentication services</li> <li>Analytics (anonymized)</li> </ul> <p>We do not sell your data to third parties.</p>"},{"location":"other/privacy-policy/#contact","title":"Contact","text":"<p>For Open Source Support:</p> <ul> <li>GitHub: https://github.com/XiansAiPlatform</li> </ul>"},{"location":"other/privacy-policy/#changes-to-this-policy","title":"Changes to This Policy","text":"<p>We may update this privacy policy from time to time. Material changes will be communicated via email or service notifications.</p>"},{"location":"other/terms-of-service/","title":"Terms of Service","text":"<p>Last Updated: January 23, 2026</p>"},{"location":"other/terms-of-service/#overview","title":"Overview","text":"<p>These terms apply to:</p> <ul> <li>Xians Open Source Components: Self-hosted installations</li> <li>agentri.ai Hosted Service: Our managed cloud service</li> </ul>"},{"location":"other/terms-of-service/#xians-open-source-components","title":"Xians Open Source Components","text":"<p>The Xians open source components are licensed under the MIT License.</p>"},{"location":"other/terms-of-service/#mit-license-summary","title":"MIT License Summary","text":"Text Only<pre><code>Copyright (c) 2026 Xians\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"other/terms-of-service/#agentriai-hosted-service","title":"agentri.ai Hosted Service","text":""},{"location":"other/terms-of-service/#acceptance-of-terms","title":"Acceptance of Terms","text":"<p>By using agentri.ai, you agree to these terms. If you disagree, do not use the service.</p>"},{"location":"other/terms-of-service/#service-description","title":"Service Description","text":"<p>agentri.ai provides a free, testing-only hosted platform for running AI agents using Xians technology.</p> <p>\u26a0\ufe0f IMPORTANT - READ CAREFULLY:</p> <ul> <li>This is a FREE TESTING SERVICE ONLY</li> <li>NO SLA, NO GUARANTEES, USE AT YOUR OWN RISK</li> <li>We can stop the service at any time without notice</li> <li>Not for production use - use the self-hosted open source version for production</li> <li>Service provided \"as-is\" with no warranties of any kind</li> </ul> <p>We provide on a best-effort basis only:</p> <ul> <li>Managed infrastructure (may be unavailable)</li> <li>API access (may be rate-limited or restricted)</li> <li>Community support (no guaranteed response times)</li> <li>Periodic updates (at our discretion)</li> </ul>"},{"location":"other/terms-of-service/#account-terms","title":"Account Terms","text":"<ul> <li>You must provide accurate account information</li> <li>You are responsible for account security</li> <li>One person or organization per account</li> <li>You must be 18+ years old to use the service</li> </ul>"},{"location":"other/terms-of-service/#fair-use-policy","title":"Fair Use Policy","text":"<p>This is a shared testing environment provided free of charge. To ensure fair access for all users:</p> <ul> <li>Resource Limits: We may impose rate limits, storage quotas, or usage restrictions at any time</li> <li>No Abuse: Excessive or abusive usage may result in immediate account suspension</li> <li>Shared Infrastructure: Do not monopolize resources or impact other users</li> <li>Testing Only: This service is intended for testing and evaluation purposes only</li> </ul> <p>We reserve the right to modify, limit, or terminate access for any user at any time without notice.</p>"},{"location":"other/terms-of-service/#acceptable-use","title":"Acceptable Use","text":"<p>You agree NOT to:</p> <ul> <li>Violate any laws or regulations</li> <li>Infringe on intellectual property rights</li> <li>Transmit malware or malicious code</li> <li>Attempt to gain unauthorized access</li> <li>Use the service to harm others</li> <li>Abuse or overload the service infrastructure</li> <li>Use for production, commercial, or mission-critical applications</li> </ul>"},{"location":"other/terms-of-service/#service-availability-and-disclaimers","title":"Service Availability and Disclaimers","text":"<p>NO SLA - NO GUARANTEES - USE AT YOUR OWN RISK:</p> <ul> <li>No Service Level Agreement (SLA) of any kind</li> <li>No uptime guarantees - service may be down at any time</li> <li>No performance guarantees - service may be slow or unreliable</li> <li>No data guarantees - data may be lost, corrupted, or deleted without notice</li> <li>We reserve the right to stop, suspend, or terminate the service at any time for any reason without notice</li> <li>Service may be interrupted, modified, or discontinued permanently at our sole discretion</li> <li>Not suitable for production use, commercial use, or any critical applications</li> <li>Use entirely at your own risk</li> </ul>"},{"location":"other/terms-of-service/#data-and-privacy","title":"Data and Privacy","text":"<ul> <li>You retain ownership of your content and data</li> <li>Testing Service Notice: Data may be deleted at any time as part of testing and maintenance</li> <li>Do not store sensitive, confidential, or production data on this service</li> <li>We may access your data only to provide support or maintain the service</li> <li>See our Privacy Policy for details</li> </ul>"},{"location":"other/terms-of-service/#payment-terms","title":"Payment Terms","text":"<p>This service is currently free for testing purposes.</p> <ul> <li>No payment is required</li> <li>We reserve the right to introduce paid plans in the future with advance notice</li> <li>Free testing accounts may have usage limits or restrictions</li> </ul>"},{"location":"other/terms-of-service/#termination","title":"Termination","text":"<p>You may:</p> <ul> <li>Cancel your account at any time</li> <li>Export your data before termination</li> </ul> <p>We may:</p> <ul> <li>Suspend or terminate accounts that violate these terms</li> <li>Discontinue the service at any time without notice</li> <li>Delete or reset testing data as needed</li> </ul>"},{"location":"other/terms-of-service/#limitation-of-liability-and-disclaimer","title":"Limitation of Liability and Disclaimer","text":"<p>TO THE MAXIMUM EXTENT PERMITTED BY LAW:</p> <ul> <li>THE SERVICE IS PROVIDED \"AS IS\" AND \"AS AVAILABLE\" WITHOUT WARRANTIES OF ANY KIND</li> <li>NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING MERCHANTABILITY OR FITNESS FOR PURPOSE</li> <li>THIS IS A FREE TESTING SERVICE - NO SLA, NO GUARANTEES WHATSOEVER</li> <li>USE ENTIRELY AT YOUR OWN RISK</li> <li>WE ARE NOT LIABLE FOR ANY DAMAGES, DATA LOSS, SERVICE INTERRUPTIONS, OR BUSINESS LOSSES</li> <li>WE ARE NOT LIABLE FOR INDIRECT, INCIDENTAL, CONSEQUENTIAL, PUNITIVE, OR ANY OTHER DAMAGES</li> <li>WE ARE NOT RESPONSIBLE FOR ANY HARM RESULTING FROM SERVICE USE OR INABILITY TO USE THE SERVICE</li> <li>TOTAL LIABILITY (IF ANY) SHALL NOT EXCEED $0 (ZERO DOLLARS)</li> </ul>"},{"location":"other/terms-of-service/#modifications","title":"Modifications","text":"<p>We may modify these terms at any time without notice. Continued use constitutes acceptance of new terms. It is your responsibility to review these terms periodically.</p>"},{"location":"other/terms-of-service/#governing-law","title":"Governing Law","text":"<p>These terms are governed by the laws of the jurisdiction where agentri.ai is incorporated.</p>"},{"location":"other/terms-of-service/#contact","title":"Contact","text":"<p>For Open Source Support:</p> <ul> <li>GitHub: https://github.com/XiansAiPlatform</li> </ul>"},{"location":"server/encryption/","title":"Chat Message Encryption","text":"<p>All chat messages stored in the database are encrypted at rest to ensure data privacy and security. This encryption is mandatory and complies with the EU AI Act requirements for data protection in AI systems.</p>"},{"location":"server/encryption/#encryption-overview","title":"Encryption Overview","text":"<p>The system uses AES encryption to secure all conversation messages before storing them in the database. Each message is encrypted using a combination of:</p> <ul> <li>A base secret key for foundational encryption</li> <li>A unique conversation message key for additional security layers</li> </ul> <p>This dual-key approach ensures that even if one key is compromised, the data remains protected.</p>"},{"location":"server/encryption/#eu-ai-act-compliance","title":"EU AI Act Compliance","text":"<p>Under the EU AI Act, AI systems that process personal data must implement appropriate technical and organizational measures to ensure data protection. Message encryption is a critical requirement for:</p> <ul> <li>Data Minimization: Only encrypted data is stored, limiting exposure</li> <li>Security by Design: Encryption is built into the system architecture</li> <li>Data Protection: Personal conversations are protected against unauthorized access</li> <li>Transparency: Users can be assured their messages are encrypted</li> </ul>"},{"location":"server/encryption/#environment-configuration","title":"Environment Configuration","text":"<p>Important: The encryption keys must be configured in your environment before the system can encrypt and store messages. Without proper key configuration, the system cannot function securely.</p>"},{"location":"server/encryption/#required-environment-variables","title":"Required Environment Variables","text":"<p>Configure the following encryption keys in your environment:</p> Text Only<pre><code># Base encryption secret - use a long, random string (minimum 32 characters)\nEncryptionKeys__BaseSecret=&lt;LONG_RANDOM_BASE_SECRET&gt;\n\n# Conversation message encryption key - unique secret for chat messages\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=&lt;UNIQUE_SECRET_FOR_MESSAGES&gt;\n</code></pre>"},{"location":"server/encryption/#key-generation-guidelines","title":"Key Generation Guidelines","text":"<ul> <li>Base Secret: Generate a cryptographically secure random string of at least 32 characters</li> <li>Message Key: Use a different random string, also minimum 32 characters</li> <li>Security: Never reuse keys across different environments (dev/staging/prod)</li> <li>Storage: Store keys securely using your organization's secret management system</li> </ul>"},{"location":"server/encryption/#example-configuration","title":"Example Configuration","text":"Bash<pre><code># Generate secure keys (Linux/macOS)\nopenssl rand -base64 32\n\n# Example .env configuration\nEncryptionKeys__BaseSecret=YourSecureBase64EncodedSecretKeyHere123456789\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=AnotherSecureRandomKeyForMessages987654321\n</code></pre>"},{"location":"server/encryption/#security-considerations","title":"Security Considerations","text":"<ul> <li>Key Rotation: Regularly rotate encryption keys according to your security policy</li> <li>Access Control: Limit access to encryption keys to authorized personnel only</li> <li>Backup: Ensure encryption keys are included in your secure backup procedures</li> <li>Monitoring: Monitor for any unauthorized access attempts to encrypted data</li> </ul>"},{"location":"server/encryption/#troubleshooting","title":"Troubleshooting","text":"<p>\"Encryption keys not configured\": Ensure both <code>BaseSecret</code> and <code>ConversationMessageKey</code> are set in your environment</p> <p>\"Unable to decrypt messages\": Verify that the same encryption keys used to encrypt the data are being used for decryption</p> <p>\"Key format invalid\": Ensure keys are properly base64 encoded and meet minimum length requirements</p>"},{"location":"server/scaling/","title":"Scaling","text":"<p>The Xians platform provides flexible scaling options to handle varying workloads efficiently. You can scale both horizontally (multiple agent instances) and vertically (workers per workflow), with the platform automatically handling distribution and fault tolerance through Temporal.</p>"},{"location":"server/scaling/#horizontal-scaling---multiple-agent-instances","title":"Horizontal Scaling - Multiple Agent Instances","text":"<p>You can spawn any number of agent console applications, and the platform automatically takes care of scaling and fault tolerance of agent runtimes. This is handled through Temporal workers and activity distribution.</p>"},{"location":"server/scaling/#how-it-works","title":"How It Works","text":"<p>When you start multiple instances of the same agent application:</p> <ol> <li>Each instance registers as a Temporal worker for the same task queue</li> <li>Temporal automatically distributes workflow executions and activities across all available workers</li> <li>If one instance fails, Temporal redistributs work to healthy instances</li> <li>No configuration changes needed - just start more instances</li> </ol>"},{"location":"server/scaling/#example","title":"Example","text":"Bash<pre><code># Terminal 1\ndotnet run --project MyAgent\n\n# Terminal 2\ndotnet run --project MyAgent\n\n# Terminal 3\ndotnet run --project MyAgent\n</code></pre> <p>All three instances will:</p> <ul> <li>Share the workload automatically</li> <li>Provide fault tolerance (if one crashes, others continue)</li> <li>Scale processing capacity linearly</li> </ul>"},{"location":"server/scaling/#benefits","title":"Benefits","text":"<ul> <li>Automatic Load Distribution: Temporal handles work distribution across all instances</li> <li>Fault Tolerance: Failed instances don't cause workflow failures</li> <li>Zero Configuration: No changes to code or configuration required</li> <li>Linear Scaling: More instances = more processing capacity</li> </ul>"},{"location":"server/scaling/#vertical-scaling---workers-per-workflow","title":"Vertical Scaling - Workers per Workflow","text":"<p>Within a single agent instance, you can configure the number of maxConcurrent per workflow to handle concurrent executions. This is specified when defining workflows.</p>"},{"location":"server/scaling/#built-in-workflows","title":"Built-In Workflows","text":"<p>Use the <code>maxConcurrent</code> parameter in <code>DefineBuiltIn()</code>:</p> C#<pre><code>// Single worker (default)\nagent.Workflows.DefineBuiltIn();\n\n// Multiple maxConcurrent for concurrent executions\nagent.Workflows.DefineBuiltIn(name: \"Data Processor Workflow\", maxConcurrent: 200);\n</code></pre>"},{"location":"server/scaling/#custom-workflows","title":"Custom Workflows","text":"<p>Use the <code>maxConcurrent</code> parameter in <code>DefineCustom&lt;T&gt;()</code>:</p> C#<pre><code>// Single worker (default)\nagent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;();\n\n// Multiple maxConcurrent for concurrent executions\nagent.Workflows.DefineCustom&lt;MyCustomWorkflow&gt;(maxConcurrent: 5);\n</code></pre>"},{"location":"server/scaling/#example-multi-workflow-agent","title":"Example: Multi-Workflow Agent","text":"C#<pre><code>var agent = platform.Agents.DefineAgent(\"DataPipeline\");\n\n// Low concurrency workflow\nagent.Workflows.DefineBuiltIn(name: \"Coordinator\", maxConcurrent: 2);\n\n// High concurrency workflow for data processing\nagent.Workflows.DefineBuiltIn(name: \"Processor\", maxConcurrent: 20);\n\n// Custom workflow with moderate concurrency\nagent.Workflows.DefineCustom&lt;ValidationWorkflow&gt;(maxConcurrent: 10);\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"server/scaling/#combining-horizontal-and-vertical-scaling","title":"Combining Horizontal and Vertical Scaling","text":"<p>You can combine both scaling strategies for maximum flexibility:</p> C#<pre><code>// Define agent with 10 maxConcurrent per workflow\nvar agent = platform.Agents.DefineAgent(\"HighThroughputAgent\");\nagent.Workflows.DefineBuiltIn(maxConcurrent: 10);\n\nawait agent.RunAsync();\n</code></pre> <p>Then spawn 5 instances:</p> <ul> <li>Total capacity: 5 instances \u00d7 10 maxConcurrent = 50 concurrent executions</li> <li>Fault tolerance: If 2 instances fail, 30 maxConcurrent still available</li> <li>Flexible scaling: Add/remove instances as needed</li> </ul>"},{"location":"server/scaling/#auto-scaling-based-on-queue-metrics","title":"Auto Scaling Based on Queue Metrics","text":"<p>For dynamic scaling scenarios, you can monitor the Temporal queue size to automatically adjust the number of workers. This approach enables responsive scaling based on actual workload demand.</p>"},{"location":"server/scaling/#monitoring-queue-size-for-auto-scaling","title":"Monitoring Queue Size for Auto Scaling","text":"<p>Temporal provides metrics that allow you to monitor the backlog of pending workflow executions and activities. By tracking these metrics, you can implement auto-scaling logic to spawn or terminate agent instances based on demand.</p>"},{"location":"server/scaling/#implementation-approaches","title":"Implementation Approaches","text":""},{"location":"server/scaling/#1-external-monitoring-service","title":"1. External Monitoring Service","text":"<p>Set up a monitoring service that:</p> <ul> <li>Queries Temporal metrics API for queue depth</li> <li>Compares against threshold values</li> <li>Triggers scaling actions (e.g., Kubernetes HPA, AWS Auto Scaling)</li> </ul> Bash<pre><code># Example: Query Temporal metrics (pseudo-code)\ncurl http://temporal:9090/metrics | grep temporal_task_queue_depth\n</code></pre>"},{"location":"server/scaling/#2-kubernetes-horizontal-pod-autoscaler-hpa","title":"2. Kubernetes Horizontal Pod Autoscaler (HPA)","text":"<p>Use Kubernetes HPA with custom metrics:</p> YAML<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: xians-agent-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: xians-agent\n  minReplicas: 2\n  maxReplicas: 20\n  metrics:\n  - type: External\n    external:\n      metric:\n        name: temporal_task_queue_backlog\n        selector:\n          matchLabels:\n            queue: \"DataPipeline:BuiltIn Workflow\"\n      target:\n        type: AverageValue\n        averageValue: \"10\"  # Scale up if &gt;10 tasks per pod\n</code></pre>"},{"location":"server/scaling/#3-programmatic-monitoring","title":"3. Programmatic Monitoring","text":"<p>Implement custom auto-scaling logic:</p> C#<pre><code>// Pseudo-code example\npublic class AutoScaler\n{\n    public async Task MonitorAndScale(CancellationToken ct)\n    {\n        while (!ct.IsCancellationRequested)\n        {\n            var queueDepth = await GetTemporalQueueDepth();\n\n            if (queueDepth &gt; 100)\n            {\n                // High load - signal to spawn more instances\n                await ScaleUp();\n            }\n            else if (queueDepth &lt; 10)\n            {\n                // Low load - signal to reduce instances\n                await ScaleDown();\n            }\n\n            await Task.Delay(TimeSpan.FromSeconds(30), ct);\n        }\n    }\n}\n</code></pre>"},{"location":"server/scaling/#auto-scaling-metrics-to-monitor","title":"Auto Scaling Metrics to Monitor","text":"<ul> <li>Task Queue Depth: Number of pending workflow/activity executions</li> <li>Worker Utilization: Percentage of busy workers</li> <li>Execution Rate: Workflows started vs completed per minute</li> <li>Latency: Time from workflow start to first activity execution</li> </ul>"},{"location":"server/scaling/#best-practices-for-auto-scaling","title":"Best Practices for Auto Scaling","text":"<ol> <li>Set Appropriate Thresholds</li> <li>Scale up before queues become too large</li> <li>Scale down gradually to avoid thrashing</li> <li> <p>Consider time-of-day patterns</p> </li> <li> <p>Implement Cooldown Periods</p> </li> <li>Wait before scaling again (e.g., 5 minutes)</li> <li> <p>Prevents rapid scaling oscillations</p> </li> <li> <p>Monitor Both Queue and Resource Utilization</p> </li> <li>Don't just scale on queue depth</li> <li> <p>Consider CPU, memory, and network metrics</p> </li> <li> <p>Test Scaling Behavior</p> </li> <li>Simulate high load scenarios</li> <li>Verify graceful scale-down behavior</li> <li> <p>Ensure no workflow failures during scaling</p> </li> <li> <p>Set Min/Max Boundaries</p> </li> <li>Minimum instances for availability</li> <li>Maximum instances for cost control</li> </ol>"},{"location":"server/scaling/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"server/scaling/#resource-limits","title":"Resource Limits","text":"<ul> <li>Memory: Each worker consumes memory; ensure adequate RAM</li> <li>CPU: More workers = more CPU usage</li> <li>Connections: Each worker maintains Temporal connections</li> </ul>"},{"location":"server/scaling/#temporal-configuration","title":"Temporal Configuration","text":"<p>Ensure your Temporal cluster can handle the load:</p> <ul> <li>Adequate history service capacity</li> <li>Sufficient matching service resources</li> <li>Properly sized persistence layer</li> </ul>"},{"location":"server/scaling/#network-latency","title":"Network Latency","text":"<ul> <li>Workers in different regions may have higher latency</li> <li>Consider deploying Temporal workers close to Temporal server</li> </ul>"},{"location":"server/scaling/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Start with fewer workers and scale up as needed</li> <li>Monitor actual utilization vs provisioned capacity</li> <li>Use auto-scaling to optimize costs during low-traffic periods</li> </ul>"},{"location":"server/scaling/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>Track these metrics to optimize scaling:</p> <ul> <li>Workflow Execution Rate: Throughput per worker/instance</li> <li>Queue Latency: Time tasks wait before execution</li> <li>Worker Utilization: Percentage of workers actively processing</li> <li>Failure Rate: Failed executions (may indicate overload)</li> </ul> <p>Use Temporal's built-in metrics and integrate with your monitoring stack (Prometheus, Grafana, etc.) for comprehensive observability.</p>"},{"location":"server/scaling/#summary","title":"Summary","text":"Scaling Type Method Use Case Configuration Horizontal Multiple instances High availability, fault tolerance Just spawn more processes Vertical Workers per workflow Concurrent executions within instance <code>maxConcurrent</code> parameter Auto Scaling Queue-based scaling Dynamic workload adaptation External monitoring + orchestration <p>The Xians platform's integration with Temporal provides powerful, flexible scaling capabilities with minimal configuration. Start simple and scale as your workload demands.</p>"},{"location":"server/slack-integration/","title":"Slack Integration - Configuration Guide","text":"<p>This guide shows you how to connect a Slack workspace to a XiansAi agent activation.</p>"},{"location":"server/slack-integration/#prerequisites","title":"Prerequisites","text":"<ul> <li>XiansAi Server running and accessible</li> <li>Admin API key</li> <li>Slack workspace with admin access</li> <li>Agent and activation already created in XiansAi</li> </ul>"},{"location":"server/slack-integration/#step-1-create-slack-app","title":"Step 1: Create Slack App","text":"<ol> <li>Go to https://api.slack.com/apps</li> <li>Click \"Create New App\" \u2192 \"From scratch\"</li> <li>Enter app name (e.g., \"XiansAI Bot\")</li> <li>Select your workspace</li> <li>Click \"Create App\"</li> </ol>"},{"location":"server/slack-integration/#step-2-configure-oauth-scopes","title":"Step 2: Configure OAuth Scopes","text":"<ol> <li>In your app settings, go to \"OAuth &amp; Permissions\"</li> <li>Scroll to \"Scopes\" \u2192 \"Bot Token Scopes\"</li> <li>Click \"Add an OAuth Scope\" and add these scopes:</li> <li><code>channels:history</code> - Read messages in channels</li> <li><code>channels:read</code> - View channel information</li> <li><code>chat:write</code> - Send messages</li> <li><code>im:history</code> - Read direct messages</li> <li><code>im:read</code> - View direct message information</li> <li><code>im:write</code> - Send direct messages</li> <li><code>app_mentions:read</code> - Read mentions of the bot</li> <li><code>users:read</code> - Required to fetch user profile information</li> <li><code>users:read.email</code> - Required to fetch user email addresses for participant identification</li> </ol>"},{"location":"server/slack-integration/#step-3-install-app-to-workspace","title":"Step 3: Install App to Workspace","text":"<ol> <li>Scroll up to \"OAuth Tokens for Your Workspace\"</li> <li>Click \"Install to Workspace\"</li> <li>Review permissions and click \"Allow\"</li> <li>Copy the \"Bot User OAuth Token\" (starts with <code>xoxb-</code>)</li> <li>Save this as <code>SLACK_BOT_TOKEN</code></li> </ol>"},{"location":"server/slack-integration/#step-4-get-signing-secret","title":"Step 4: Get Signing Secret","text":"<ol> <li>Go to \"Basic Information\" in the left sidebar</li> <li>Scroll to \"App Credentials\"</li> <li>Copy the \"Signing Secret\"</li> <li>Save this as <code>SLACK_SIGNING_SECRET</code></li> </ol>"},{"location":"server/slack-integration/#step-5-configure-outgoing-messages-choose-one","title":"Step 5: Configure Outgoing Messages (Choose One)","text":"<p>All options support bidirectional messaging (Slack \u2194 Agent). The difference is in features and flexibility.</p> <p>For the agent to send messages back to Slack, choose ONE of these options:</p>"},{"location":"server/slack-integration/#option-a-bot-token-recommended---fully-bidirectional","title":"Option A: Bot Token (Recommended - Fully Bidirectional)","text":"<p>Incoming: \u2705 Receives messages via Events API Outgoing: \u2705 Sends via Slack Bot API (<code>chat.postMessage</code>)</p> <p>Advantages: - Supports message threading (replies in same thread) - Can send to any channel dynamically - More flexible features (reactions, file uploads, etc.)</p> <p>Already configured in Step 3 - you have the <code>SLACK_BOT_TOKEN</code>.</p>"},{"location":"server/slack-integration/#option-b-incoming-webhook-simple---bidirectional-with-limitations","title":"Option B: Incoming Webhook (Simple - Bidirectional with Limitations)","text":"<p>Incoming: \u2705 Receives messages via Events API Outgoing: \u2705 Sends via Incoming Webhook POST</p> <p>Advantages: - Simpler setup - No additional OAuth scopes needed</p> <p>Limitations: - Cannot reply in threads (posts as new message) - Configured for one default channel</p> <p>Setup: 1. Go to \"Incoming Webhooks\" in the left sidebar 2. Toggle \"Activate Incoming Webhooks\" to ON 3. Click \"Add New Webhook to Workspace\" 4. Select a channel (default for messages) 5. Click \"Allow\" 6. Copy the Webhook URL (starts with <code>https://hooks.slack.com/services/...</code>)    - Save this as <code>SLACK_INCOMING_WEBHOOK</code></p>"},{"location":"server/slack-integration/#option-c-both-maximum-flexibility","title":"Option C: Both (Maximum Flexibility)","text":"<p>Configure both <code>botToken</code> and <code>incomingWebhookUrl</code>. The system will use the incoming webhook if available, otherwise falls back to bot API.</p> <p>Note: For incoming messages, ALL options use the same mechanism (Events API + <code>signingSecret</code>). The choice only affects how outgoing messages are sent.</p>"},{"location":"server/slack-integration/#step-6-create-integration-via-api","title":"Step 6: Create Integration via API","text":"Bash<pre><code># Set variables\nexport BASE_URL=\"https://your-server.com\"  # Or http://localhost:5001\nexport ADMIN_API_KEY=\"your-admin-api-key\"\nexport TENANT_ID=\"your-tenant-id\"\nexport AGENT_NAME=\"YourAgent\"\nexport ACTIVATION_NAME=\"YourActivation\"\nexport SLACK_BOT_TOKEN=\"xoxb-...\"\nexport SLACK_SIGNING_SECRET=\"...\"\nexport SLACK_INCOMING_WEBHOOK=\"https://hooks.slack.com/services/...\"  # Optional\n\n# Create integration (choose your configuration from Step 5)\n\n# Option A: Bot Token only (recommended)\ncurl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"slack\",\n    \"name\": \"My Slack Bot\",\n    \"description\": \"Slack integration for my agent\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"signingSecret\": \"'${SLACK_SIGNING_SECRET}'\",\n      \"botToken\": \"'${SLACK_BOT_TOKEN}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userEmail\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }'\n\n# Option B: Incoming Webhook only (simpler, no threading)\ncurl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"slack\",\n    \"name\": \"My Slack Bot\",\n    \"description\": \"Slack integration for my agent\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"signingSecret\": \"'${SLACK_SIGNING_SECRET}'\",\n      \"incomingWebhookUrl\": \"'${SLACK_INCOMING_WEBHOOK}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userEmail\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }'\n\n# Option C: Both (maximum flexibility)\ncurl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"slack\",\n    \"name\": \"My Slack Bot\",\n    \"description\": \"Slack integration for my agent\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"signingSecret\": \"'${SLACK_SIGNING_SECRET}'\",\n      \"botToken\": \"'${SLACK_BOT_TOKEN}'\",\n      \"incomingWebhookUrl\": \"'${SLACK_INCOMING_WEBHOOK}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userEmail\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }'\n</code></pre> <p>Response: JSON<pre><code>{\n  \"id\": \"65f8a3b2e9c1234567890abc\",\n  \"webhookUrl\": \"https://your-server.com/api/apps/slack/events/65f8a3b2e9c1234567890abc/webhook-secret-xyz\",\n  ...\n}\n</code></pre></p> <p>Save the <code>webhookUrl</code> and <code>id</code>.</p>"},{"location":"server/slack-integration/#step-7-configure-slack-event-subscriptions","title":"Step 7: Configure Slack Event Subscriptions","text":"<ol> <li>Go to your Slack App \u2192 \"Event Subscriptions\"</li> <li>Toggle \"Enable Events\" to ON</li> <li>In \"Request URL\", paste the <code>webhookUrl</code> from Step 5</li> <li>Wait for \"Verified \u2713\" checkmark</li> <li>Scroll to \"Subscribe to bot events\"</li> <li>Click \"Add Bot User Event\" and add:</li> <li><code>message.channels</code></li> <li><code>message.im</code></li> <li><code>app_mention</code></li> <li>Click \"Save Changes\"</li> <li>If prompted, \"Reinstall App\" to apply changes</li> </ol>"},{"location":"server/slack-integration/#step-8-enable-direct-messages-optional","title":"Step 8: Enable Direct Messages (Optional)","text":"<p>To allow users to DM the bot:</p> <ol> <li>Go to \"App Home\" in the left sidebar</li> <li>Scroll to \"Show Tabs\"</li> <li>Check \"Allow users to send Slash commands and messages from the messages tab\"</li> <li>Click \"Save Changes\"</li> </ol>"},{"location":"server/slack-integration/#step-9-test-the-integration","title":"Step 9: Test the Integration","text":""},{"location":"server/slack-integration/#send-a-message-in-slack","title":"Send a message in Slack:","text":"<p>Option A: Direct Message 1. Open Slack 2. Go to Apps section 3. Find your bot 4. Send a message: <code>Hello!</code></p> <p>Option B: Channel Mention 1. Invite bot to a channel: <code>/invite @YourBot</code> 2. Mention the bot: <code>@YourBot help me</code></p>"},{"location":"server/slack-integration/#verify-message-was-received","title":"Verify message was received:","text":"Bash<pre><code>curl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/messaging/history?\\\nagentName=${AGENT_NAME}&amp;\\\nactivationName=${ACTIVATION_NAME}&amp;\\\nparticipantId=U1234567890&amp;\\\npage=1&amp;\\\npageSize=10\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre> <p>Replace <code>U1234567890</code> with the actual Slack user ID from the logs or Slack profile.</p>"},{"location":"server/slack-integration/#managing-integrations","title":"Managing Integrations","text":""},{"location":"server/slack-integration/#list-all-integrations","title":"List all integrations","text":"Bash<pre><code>curl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/slack-integration/#get-specific-integration","title":"Get specific integration","text":"Bash<pre><code>export INTEGRATION_ID=\"65f8a3b2e9c1234567890abc\"\n\ncurl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/slack-integration/#update-integration","title":"Update integration","text":"Bash<pre><code>curl -X PUT \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"description\": \"Updated description\",\n    \"configuration\": {\n      \"botToken\": \"new-token\"\n    }\n  }'\n</code></pre>"},{"location":"server/slack-integration/#disable-integration","title":"Disable integration","text":"Bash<pre><code>curl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}/disable\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/slack-integration/#enable-integration","title":"Enable integration","text":"Bash<pre><code>curl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}/enable\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/slack-integration/#delete-integration","title":"Delete integration","text":"Bash<pre><code>curl -X DELETE \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/slack-integration/#test-integration-configuration","title":"Test integration configuration","text":"Bash<pre><code>curl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}/test\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/slack-integration/#configuration-options","title":"Configuration Options","text":""},{"location":"server/slack-integration/#participant-id-mapping","title":"Participant ID Mapping","text":"<p>Determines how to identify users in XiansAi:</p> <p>Dynamic Options (from Slack event data): - <code>userEmail</code> (Recommended) - Use user's email address   - Requires <code>users:read</code> and <code>users:read.email</code> scopes   - Fetches email from Slack API (cached for performance)   - Provides consistent, human-readable identification across workspaces   - Falls back to <code>userId</code> if email cannot be fetched</p> <ul> <li><code>userId</code> - Use Slack user ID</li> <li>Example: \"U1234567890\"</li> <li> <p>No additional scopes required</p> </li> <li> <p><code>channelId</code> - Use channel ID as participant</p> </li> <li>All messages in same channel share one participant ID</li> <li> <p>Useful for channel-based workflows</p> </li> <li> <p><code>threadId</code> - Use thread timestamp as participant</p> </li> <li>Groups participants by conversation thread</li> </ul> <p>Fixed Value: - Set <code>participantIdSource</code> to <code>null</code> and use <code>defaultParticipantId</code>   - Example: <code>\"participantIdSource\": null, \"defaultParticipantId\": \"support-team\"</code>   - All messages will use \"support-team\" as the participant   - Useful when treating all Slack users as a single participant</p>"},{"location":"server/slack-integration/#scope-mapping","title":"Scope Mapping","text":"<p>Determines how to organize conversations:</p> <p>Dynamic Options (from Slack event data): - <code>channelId</code> (Recommended) - Group by Slack channel   - Each channel gets its own scope   - Example: \"C1234567890\"</p> <ul> <li><code>threadId</code> - Group by thread</li> <li>Each thread gets its own scope</li> <li>Uses thread timestamp</li> </ul> <p>Fixed Value: - Set <code>scopeSource</code> to <code>null</code> and use <code>defaultScope</code>   - Example: <code>\"scopeSource\": null, \"defaultScope\": \"Slack\"</code>   - All messages will be grouped under \"Slack\" scope   - Useful for grouping all Slack conversations together</p> <ul> <li><code>null</code> with no defaultScope - No scope grouping</li> <li>All messages share no specific scope</li> </ul>"},{"location":"server/slack-integration/#example-configurations","title":"Example Configurations:","text":"<p>Dynamic Mapping (Recommended): JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": \"userEmail\",  // Each user identified by their email\n    \"scopeSource\": \"channelId\"           // Conversations grouped by channel\n  }\n}\n</code></pre></p> <p>Fixed Scope with Dynamic Participants: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": \"userId\",     // Each user identified by Slack ID\n    \"scopeSource\": null,                 // Use fixed scope\n    \"defaultScope\": \"Slack\"              // All grouped under \"Slack\"\n  }\n}\n</code></pre></p> <p>Fixed Participant with Dynamic Scope: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": null,         // Use fixed participant\n    \"defaultParticipantId\": \"support-bot\", // All messages from \"support-bot\"\n    \"scopeSource\": \"channelId\"           // But grouped by channel\n  }\n}\n</code></pre></p> <p>Fully Fixed (All messages together): JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": null,\n    \"defaultParticipantId\": \"slack-user\",\n    \"scopeSource\": null,\n    \"defaultScope\": \"slack-workspace\"\n  }\n}\n</code></pre></p>"},{"location":"server/slack-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"server/slack-integration/#integration-created-but-slack-shows-verification-failed","title":"Integration created but Slack shows \"Verification Failed\"","text":"<ul> <li>Ensure webhook URL is accessible from internet</li> <li>For local testing, use ngrok: <code>ngrok http 5001</code></li> <li>Update Slack Request URL with ngrok HTTPS URL</li> </ul>"},{"location":"server/slack-integration/#sending-messages-to-this-app-has-been-turned-off","title":"\"Sending messages to this app has been turned off\"","text":"<ul> <li>Go to App Home \u2192 Enable Messages Tab</li> <li>Check \"Allow users to send Slash commands and messages\"</li> <li>Reinstall app</li> </ul>"},{"location":"server/slack-integration/#messages-not-arriving-at-agent","title":"Messages not arriving at agent","text":"Bash<pre><code># Check integration is enabled\ncurl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" | jq '.isEnabled'\n\n# Should return: true\n</code></pre>"},{"location":"server/slack-integration/#agent-responses-not-appearing-in-slack","title":"Agent responses not appearing in Slack","text":"<ul> <li>Verify either <code>botToken</code> or <code>incomingWebhookUrl</code> is configured</li> <li>Check server logs for \"AppMessageRouterService started\"</li> <li>Ensure agent activation is active</li> <li>If using incoming webhook, verify the URL is correct and not expired</li> </ul>"},{"location":"server/slack-integration/#slack-api-returned-error-for-user-missing_scope","title":"\"Slack API returned error for user: missing_scope\"","text":"<p>This error indicates missing OAuth scopes for fetching user information:</p> <ol> <li>Go to your Slack App \u2192 \"OAuth &amp; Permissions\"</li> <li>Add the missing scopes under \"Bot Token Scopes\":</li> <li><code>users:read</code></li> <li><code>users:read.email</code></li> <li>Click \"Save Changes\"</li> <li>Important: Reinstall the app to workspace to apply new scopes</li> <li>The bot will now be able to fetch user emails for participant identification</li> </ol> <p>Note: Without these scopes, the system will fall back to using Slack user IDs instead of email addresses.</p>"},{"location":"server/slack-integration/#local-testing-with-ngrok","title":"Local Testing with ngrok","text":"Bash<pre><code># Install ngrok\nbrew install ngrok  # macOS\n# or download from https://ngrok.com\n\n# Start tunnel\nngrok http 5001\n\n# Copy the HTTPS URL (e.g., https://abc123.ngrok.io)\n# Update Slack Request URL:\n# https://abc123.ngrok.io/api/apps/slack/events/{integrationId}/{webhookSecret}\n</code></pre>"},{"location":"server/slack-integration/#outgoing-message-options-comparison","title":"Outgoing Message Options Comparison","text":"Feature Bot Token Incoming Webhook Bidirectional \u2705 Yes \u2705 Yes Receive from Slack \u2705 Events API \u2705 Events API Send to Slack \u2705 Bot API \u2705 Webhook POST Threading support \u2705 Yes \u274c No Dynamic channels \u2705 Yes \u274c Default channel User email fetching \u2705 Yes (if scopes added) \u2705 Yes (if scopes added) Required scopes (basic) <code>chat:write</code> None Required scopes (email) <code>users:read</code>, <code>users:read.email</code> <code>users:read</code>, <code>users:read.email</code> Setup complexity Medium Simple Recommended for Production Simple notifications <p>Note: User email fetching requires:</p> <ol> <li>Setting <code>participantIdSource: \"userEmail\"</code> in mapping configuration</li> <li>Adding <code>users:read</code> and <code>users:read.email</code> scopes to the bot token</li> <li>Reinstalling the app to apply new scopes</li> </ol>"},{"location":"server/slack-integration/#complete-example-script","title":"Complete Example Script","text":"Bash<pre><code>#!/bin/bash\nset -e\n\n# Configuration\nexport BASE_URL=\"https://your-server.com\"\nexport ADMIN_API_KEY=\"your-admin-api-key\"\nexport TENANT_ID=\"my-tenant\"\nexport AGENT_NAME=\"SupportAgent\"\nexport ACTIVATION_NAME=\"LiveSupport\"\nexport SLACK_BOT_TOKEN=\"xoxb-your-token\"\nexport SLACK_SIGNING_SECRET=\"your-secret\"\nexport SLACK_INCOMING_WEBHOOK=\"https://hooks.slack.com/services/...\"  # Optional\n\n# Create integration with both options\nRESPONSE=$(curl -s -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"slack\",\n    \"name\": \"Support Bot\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"signingSecret\": \"'${SLACK_SIGNING_SECRET}'\",\n      \"botToken\": \"'${SLACK_BOT_TOKEN}'\",\n      \"incomingWebhookUrl\": \"'${SLACK_INCOMING_WEBHOOK}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userEmail\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }')\n\n# Extract webhook URL\nWEBHOOK_URL=$(echo $RESPONSE | jq -r '.webhookUrl')\nINTEGRATION_ID=$(echo $RESPONSE | jq -r '.id')\n\necho \"\u2705 Integration Created!\"\necho \"Integration ID: ${INTEGRATION_ID}\"\necho \"\"\necho \"Next: Configure this URL in Slack Event Subscriptions:\"\necho \"${WEBHOOK_URL}\"\n</code></pre> <p>Need Help? Check server logs for detailed error messages and debugging information.</p>"},{"location":"server/teams-integration/","title":"Microsoft Teams Integration - Configuration Guide","text":"<p>This guide shows you how to connect Microsoft Teams to a XiansAi agent activation using the Bot Framework.</p>"},{"location":"server/teams-integration/#prerequisites","title":"Prerequisites","text":"<ul> <li>XiansAi Server running and accessible from the internet (or use ngrok for local testing)</li> <li>Admin API key</li> <li>Azure account with permissions to create app registrations</li> <li>Microsoft Teams workspace</li> <li>Agent and activation already created in XiansAi</li> </ul>"},{"location":"server/teams-integration/#step-1-create-azure-bot-resource","title":"Step 1: Create Azure Bot Resource","text":"<ol> <li>Go to https://portal.azure.com</li> <li>Click \"Create a resource\"</li> <li>Search for \"Azure Bot\"</li> <li>Click \"Create\"</li> <li>Fill in the details:</li> <li>Bot handle: Unique name (e.g., \"xiansai-bot\")</li> <li>Subscription: Select your subscription</li> <li>Resource group: Create new or use existing</li> <li>Pricing tier: Free (F0) for testing, S1 for production</li> <li>Type of App: Choose \"Single Tenant\" (recommended for single organization)</li> <li>Microsoft App ID: Select \"Create new Microsoft App ID\"</li> <li>App Tenant ID: Will be auto-filled (important for single-tenant bots)</li> <li>Click \"Create\"</li> </ol>"},{"location":"server/teams-integration/#step-2-get-app-credentials","title":"Step 2: Get App Credentials","text":""},{"location":"server/teams-integration/#required-credentials","title":"Required Credentials:","text":"<ol> <li>After deployment, go to your Azure Bot resource</li> <li>Navigate to \"Configuration\" in the left sidebar</li> <li>Copy these values:</li> <li>Microsoft App ID (also called Application/Client ID)<ul> <li>Save as <code>TEAMS_APP_ID</code></li> </ul> </li> <li> <p>App Tenant ID (Directory/Tenant ID) </p> <ul> <li>Save as <code>TEAMS_APP_TENANT_ID</code></li> <li>Critical for Single Tenant bots!</li> </ul> </li> <li> <p>Click on the Microsoft App ID (Manage Passwords) link to go to App Registrations</p> </li> <li>Click \"Certificates &amp; secrets\"</li> <li>Click \"New client secret\"</li> <li>Add description (e.g., \"XiansAI Bot Secret\") and set expiration (24 months recommended)</li> <li>Copy the secret VALUE (you can only see it once!)</li> <li>Save this as <code>TEAMS_APP_PASSWORD</code></li> </ol>"},{"location":"server/teams-integration/#add-permissions-for-email-fetching","title":"Add Permissions for Email Fetching","text":"<p>To use user emails as participant IDs:</p> <ol> <li>In the App Registration, go to \"API permissions\"</li> <li>Click \"Add a permission\"</li> <li>Select \"Microsoft Graph\" \u2192 \"Application permissions\"</li> <li>Search and add: <code>User.Read.All</code></li> <li>Click \"Grant admin consent for [Your Organization]\" \u2705</li> <li>This allows the bot to read user profiles including email addresses</li> </ol>"},{"location":"server/teams-integration/#step-3-create-integration-via-api","title":"Step 3: Create Integration via API","text":"<p>Important: For Single Tenant bots, you MUST include the <code>appTenantId</code> or authentication will fail!</p>"},{"location":"server/teams-integration/#option-a-with-email-based-participant-id-recommended","title":"Option A: With Email-Based Participant ID (Recommended)","text":"Bash<pre><code># Set variables\nexport BASE_URL=\"https://your-server.com\"  # Or http://localhost:5005\nexport ADMIN_API_KEY=\"your-admin-api-key\"\nexport TENANT_ID=\"your-tenant-id\"\nexport AGENT_NAME=\"YourAgent\"\nexport ACTIVATION_NAME=\"YourActivation\"\nexport TEAMS_APP_ID=\"5d29f94e-55e5-4f66-8f8d-e96ed1493650\"\nexport TEAMS_APP_PASSWORD=\"your-secret-value\"\nexport TEAMS_APP_TENANT_ID=\"d607b82b-6bff-400d-af64-8e7ab2e8a004\"\n\n# Create integration\ncurl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"msteams\",\n    \"name\": \"My Teams Bot\",\n    \"description\": \"Teams integration for my agent\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"appId\": \"'${TEAMS_APP_ID}'\",\n      \"appPassword\": \"'${TEAMS_APP_PASSWORD}'\",\n      \"appTenantId\": \"'${TEAMS_APP_TENANT_ID}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userEmail\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }'\n</code></pre>"},{"location":"server/teams-integration/#option-b-simple-setup-user-id","title":"Option B: Simple Setup (User ID)","text":"Bash<pre><code># Create integration without email fetching\ncurl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"msteams\",\n    \"name\": \"My Teams Bot\",\n    \"description\": \"Teams integration for my agent\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"appId\": \"'${TEAMS_APP_ID}'\",\n      \"appPassword\": \"'${TEAMS_APP_PASSWORD}'\",\n      \"appTenantId\": \"'${TEAMS_APP_TENANT_ID}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userId\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }'\n</code></pre> <p>Response: JSON<pre><code>{\n  \"id\": \"65f8a3b2e9c1234567890def\",\n  \"webhookUrl\": \"https://your-server.com/api/apps/msteams/events/65f8a3b2e9c1234567890def/webhook-secret-xyz\",\n  ...\n}\n</code></pre></p> <p>Save the <code>webhookUrl</code> and <code>id</code>.</p>"},{"location":"server/teams-integration/#step-4-configure-azure-bot-messaging-endpoint","title":"Step 4: Configure Azure Bot Messaging Endpoint","text":"<ol> <li>Go back to your Azure Bot resource</li> <li>Navigate to \"Configuration\"</li> <li>In \"Messaging endpoint\", paste the <code>webhookUrl</code> from Step 3</li> <li>Click \"Apply\"</li> </ol>"},{"location":"server/teams-integration/#step-5-add-teams-channel","title":"Step 5: Add Teams Channel","text":"<ol> <li>In your Azure Bot, navigate to \"Channels\"</li> <li>Click on \"Microsoft Teams\" icon</li> <li>Click \"Apply\"</li> <li>Teams channel will be added and enabled</li> </ol>"},{"location":"server/teams-integration/#step-6-install-bot-to-teams","title":"Step 6: Install Bot to Teams","text":""},{"location":"server/teams-integration/#option-a-via-app-studio-recommended","title":"Option A: Via App Studio (Recommended)","text":"<ol> <li>Open Microsoft Teams</li> <li>Go to Apps \u2192 Search for \"App Studio\" or \"Developer Portal\"</li> <li>Install App Studio if not already installed</li> <li>Open App Studio</li> <li>Click \"Create a new app\"</li> <li>Fill in app details:</li> <li>Short name: Your bot name</li> <li>App ID: Use the <code>TEAMS_APP_ID</code> from Step 2</li> <li>Package name: Unique identifier</li> <li>Version: 1.0.0</li> <li>Short description: Bot description</li> <li>Full description: Detailed description</li> <li>Go to \"Capabilities\" \u2192 \"Bots\"</li> <li>Click \"Set up\"</li> <li>Select \"Existing bot\"</li> <li>Enter your Bot ID (same as <code>TEAMS_APP_ID</code>)</li> <li>Select scopes:<ul> <li>\u2705 Personal</li> <li>\u2705 Team</li> <li>\u2705 Group Chat</li> </ul> </li> <li>Click \"Save\"</li> <li>Click on 'App package editor' and fix any issues in Manifest.json</li> <li>Go to \"Test and distribute\"</li> <li>Click \"Install\" to add to your team</li> </ol>"},{"location":"server/teams-integration/#option-b-direct-installation-link","title":"Option B: Direct Installation Link","text":"<p>Use the Azure Bot's Teams channel installation link provided in the Azure portal.</p>"},{"location":"server/teams-integration/#step-7-test-the-integration","title":"Step 7: Test the Integration","text":""},{"location":"server/teams-integration/#send-a-message-in-teams","title":"Send a message in Teams:","text":"<p>Option A: Direct Chat 1. Open Teams 2. Go to Chat 3. Find your bot 4. Send a message: <code>Hello!</code></p> <p>Option B: Team Channel 1. Add the bot to a team channel 2. Mention the bot: <code>@YourBot help me</code></p>"},{"location":"server/teams-integration/#verify-message-was-received","title":"Verify message was received:","text":"Bash<pre><code>curl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/messaging/history?\\\nagentName=${AGENT_NAME}&amp;\\\nactivationName=${ACTIVATION_NAME}&amp;\\\nparticipantId=USER-ID&amp;\\\npage=1&amp;\\\npageSize=10\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#managing-integrations","title":"Managing Integrations","text":""},{"location":"server/teams-integration/#list-all-integrations","title":"List all integrations","text":"Bash<pre><code>curl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#get-teams-integrations-only","title":"Get Teams integrations only","text":"Bash<pre><code>curl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations?platformId=msteams\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#update-integration","title":"Update integration","text":"Bash<pre><code>export INTEGRATION_ID=\"65f8a3b2e9c1234567890def\"\n\ncurl -X PUT \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"description\": \"Updated description\",\n    \"configuration\": {\n      \"appPassword\": \"new-password\"\n    }\n  }'\n</code></pre>"},{"location":"server/teams-integration/#disable-integration","title":"Disable integration","text":"Bash<pre><code>curl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}/disable\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#enable-integration","title":"Enable integration","text":"Bash<pre><code>curl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}/enable\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#delete-integration","title":"Delete integration","text":"Bash<pre><code>curl -X DELETE \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#test-integration-configuration","title":"Test integration configuration","text":"Bash<pre><code>curl -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}/test\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\"\n</code></pre>"},{"location":"server/teams-integration/#configuration-options","title":"Configuration Options","text":""},{"location":"server/teams-integration/#participant-id-mapping","title":"Participant ID Mapping","text":"<p>Determines how to identify users in XiansAi:</p> <p>Dynamic Options (from Teams event data): - <code>userEmail</code> (Recommended) - Use user's email address   - Requires <code>User.Read.All</code> Graph API permission   - Fetches email from Microsoft Graph (cached for performance)   - Provides human-readable, consistent identification   - Falls back to <code>userId</code> if email unavailable   - Example: <code>user@company.com</code></p> <ul> <li><code>userId</code> - Use Teams user ID (Azure AD Object ID)</li> <li>No additional permissions required</li> <li> <p>Example: <code>586616ac-f9d7-4626-9d91-205f2310cfdd</code></p> </li> <li> <p><code>channelId</code> - Use Teams channel ID</p> </li> <li>All messages in same channel share one participant ID</li> <li>Useful for channel-based workflows</li> </ul> <p>Fixed Value: - Set <code>participantIdSource</code> to <code>null</code> and use <code>defaultParticipantId</code>   - Example: <code>\"participantIdSource\": null, \"defaultParticipantId\": \"teams-support\"</code>   - All messages will use \"teams-support\" as the participant</p>"},{"location":"server/teams-integration/#scope-mapping","title":"Scope Mapping","text":"<p>Determines how to organize conversations:</p> <p>Dynamic Options (from Teams event data):</p> <ul> <li><code>conversationId</code> (Recommended) - Use unique conversation ID</li> <li>Works for both personal chats and channel conversations</li> <li>Each conversation (whether 1:1 or channel) gets its own scope</li> <li> <p>Best choice for most use cases</p> </li> <li> <p><code>conversationType</code> - Group by conversation type</p> </li> <li>Returns \"personal\" for direct messages or \"channel\" for team channels</li> <li> <p>Useful for separating personal vs. team conversations</p> </li> <li> <p><code>channelId</code> - Group by Teams channel ID</p> </li> <li>\u26a0\ufe0f Only works for channel conversations (returns null for personal chats)</li> <li>Use with <code>defaultScope</code> as fallback for personal chats</li> <li> <p>Example: <code>\"scopeSource\": \"channelId\", \"defaultScope\": \"personal\"</code></p> </li> <li> <p><code>teamId</code> - Group by Teams team ID</p> </li> <li>\u26a0\ufe0f Only works for team channels (returns null for personal chats)</li> <li> <p>Use with <code>defaultScope</code> as fallback</p> </li> <li> <p><code>channelName</code> - Use channel display name</p> </li> <li>Only works for team channels</li> </ul> <p>Fixed Value: - Set <code>scopeSource</code> to <code>null</code> and use <code>defaultScope</code>   - Example: <code>\"scopeSource\": null, \"defaultScope\": \"Teams\"</code>   - All messages grouped under \"Teams\" scope</p> <p>Automatic Fallback: - If the specified <code>scopeSource</code> returns null/empty (e.g., using \"channelId\" in a personal chat), the system automatically falls back to <code>defaultScope</code> - Debug logs will show: <code>\"Scope source 'channelId' returned null/empty, using DefaultScope\"</code></p>"},{"location":"server/teams-integration/#example-configurations","title":"Example Configurations:","text":"<p>Recommended: Email + Conversation ID (Works for all chat types): JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": \"userEmail\",\n    \"scopeSource\": \"conversationId\"\n  }\n}\n</code></pre></p> <p>Separate Personal vs. Channel Chats: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": \"userEmail\",\n    \"scopeSource\": \"conversationType\"\n  }\n}\n</code></pre> - Personal chats \u2192 scope: \"personal\" - Channel messages \u2192 scope: \"channel\"</p> <p>Channel ID with Fallback for Personal Chats: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": \"userEmail\",\n    \"scopeSource\": \"channelId\",\n    \"defaultScope\": \"personal\"\n  }\n}\n</code></pre> - Channel messages \u2192 scope: actual channel ID - Personal chats \u2192 scope: \"personal\" (fallback)</p> <p>Fixed Scope for All Teams Conversations: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": \"userEmail\",\n    \"scopeSource\": null,\n    \"defaultScope\": \"Microsoft Teams\"\n  }\n}\n</code></pre></p> <p>Single Bot Participant: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"participantIdSource\": null,\n    \"defaultParticipantId\": \"teams-bot\",\n    \"scopeSource\": \"conversationId\"\n  }\n}\n</code></pre></p>"},{"location":"server/teams-integration/#features-comparison","title":"Features Comparison","text":"Feature Supported Bidirectional messaging \u2705 Yes Receive messages \u2705 Bot Framework Send messages \u2705 Bot Framework API Threading support \u2705 Yes (replyToId) Rich messages \u2705 Adaptive Cards Direct messages \u2705 Yes Channel messages \u2705 Yes Group chats \u2705 Yes"},{"location":"server/teams-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"server/teams-integration/#integration-created-but-verification-fails","title":"Integration created but verification fails","text":"<ul> <li>Ensure messaging endpoint is accessible from internet</li> <li>Azure Bot must be able to reach your server</li> <li>Test URL accessibility: <code>curl https://your-server.com/health</code></li> <li>For local testing, use ngrok: Bash<pre><code>ngrok http 5005\n# Use the HTTPS URL: https://abc123.ngrok-free.app\n</code></pre></li> <li>Update Azure Bot messaging endpoint:</li> <li>Must use the events endpoint: <code>/api/apps/msteams/events/{integrationId}/{webhookSecret}</code></li> <li>Correct: <code>https://your-server.com/api/apps/msteams/events/123456/webhook-secret-xyz</code></li> </ul>"},{"location":"server/teams-integration/#authentication-error-application-not-found-in-directory","title":"Authentication Error: \"Application not found in directory\"","text":"<p>Error: <code>AADSTS700016: Application with identifier 'xxx' was not found in the directory 'Bot Framework'</code></p> <p>Solution: Add <code>appTenantId</code> to your configuration:</p> Bash<pre><code>curl -X PUT \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"configuration\": {\n      \"appId\": \"your-app-id\",\n      \"appPassword\": \"your-password\",\n      \"appTenantId\": \"d607b82b-6bff-400d-af64-8e7ab2e8a004\"\n    }\n  }'\n</code></pre> <p>Why: Single Tenant bots must authenticate against their specific tenant, not the generic \"botframework.com\" tenant.</p>"},{"location":"server/teams-integration/#the-activityfrom-field-is-required","title":"\"The 'Activity.From' field is required\"","text":"<p>Error: When bot tries to send messages back to Teams</p> <p>Solution: This was fixed in recent updates. Make sure you're running the latest version. The response now includes: - <code>from</code> - Bot account - <code>recipient</code> - User account - <code>conversation</code> - Conversation context - <code>replyToId</code> - For threading</p>"},{"location":"server/teams-integration/#messages-not-arriving-at-agent","title":"Messages not arriving at agent","text":"Bash<pre><code># Check integration is enabled\ncurl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" | jq '.isEnabled'\n\n# Should return: true\n\n# Check server logs for:\n# - \"Processing Teams activity: Type=message\"\n# - \"Sending Teams message to workflow\"\n</code></pre>"},{"location":"server/teams-integration/#agent-responses-not-appearing-in-teams","title":"Agent responses not appearing in Teams","text":"<ul> <li>Verify credentials: Bash<pre><code># Check configuration\ncurl \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations/${INTEGRATION_ID}\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" | jq '.configuration'\n</code></pre></li> <li>Check server logs for:</li> <li>\"AppMessageRouterService started\"</li> <li>\"Successfully sent message to Teams\"</li> <li>Any errors about missing fields or authentication</li> <li>Verify app credentials haven't expired:</li> <li>Client secrets expire (check Azure Portal)</li> <li>Set calendar reminders before expiration</li> </ul>"},{"location":"server/teams-integration/#failed-to-get-bot-framework-token","title":"\"Failed to get Bot Framework token\"","text":"<p>Common causes: 1. Wrong <code>appId</code> or <code>appPassword</code> 2. Client secret expired 3. Missing <code>appTenantId</code> for Single Tenant bots</p> <p>Check: Bash<pre><code># In Azure Portal:\n# 1. App Registrations \u2192 Your App \u2192 Certificates &amp; secrets\n# 2. Verify secret hasn't expired\n# 3. If expired, create new secret and update integration\n</code></pre></p>"},{"location":"server/teams-integration/#missing-user-email--userreadall-permission-error","title":"Missing User Email / \"User.Read.All\" Permission Error","text":"<p>Error: Cannot fetch user email for participant ID</p> <p>Solution: 1. Go to Azure Portal \u2192 App Registrations \u2192 Your App 2. Click API permissions 3. Add Microsoft Graph \u2192 Application permissions \u2192 <code>User.Read.All</code> 4. Click \"Grant admin consent\" (requires admin) 5. Wait a few minutes for permissions to propagate</p> <p>Fallback: If you can't get admin consent, use <code>\"participantIdSource\": \"userId\"</code> instead</p>"},{"location":"server/teams-integration/#duplicate-webhook-calls-3-messages-for-1-user-message","title":"Duplicate Webhook Calls (3 messages for 1 user message)","text":"<p>This is normal Teams behavior! Teams sends multiple activity types: - <code>message</code> - The actual user message - <code>typing</code> - Typing indicator - <code>conversationUpdate</code> - Conversation state changes</p> <p>The handler filters these automatically and only processes actual <code>message</code> activities.</p>"},{"location":"server/teams-integration/#scope-is-null-in-messages","title":"Scope is null in messages","text":"<p>Issue: Messages are being saved with <code>scope: null</code> even though you configured <code>scopeSource</code></p> <p>Common causes: 1. Using <code>scopeSource: \"channelId\"</code> for personal chats    - Personal chats don't have a channel ID    - Only team channel conversations have channel IDs</p> <p>Solutions:</p> <p>Option 1 - Use conversationId (Recommended): JSON<pre><code>{\n  \"mappingConfig\": {\n    \"scopeSource\": \"conversationId\"\n  }\n}\n</code></pre> Works for both personal chats and channel conversations.</p> <p>Option 2 - Add a defaultScope fallback: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"scopeSource\": \"channelId\",\n    \"defaultScope\": \"personal\"\n  }\n}\n</code></pre> Channel messages will have the channel ID as scope, personal chats will use \"personal\".</p> <p>Option 3 - Use conversationType: JSON<pre><code>{\n  \"mappingConfig\": {\n    \"scopeSource\": \"conversationType\"\n  }\n}\n</code></pre> Automatically sets scope to \"personal\" or \"channel\".</p> <p>Check debug logs: When scope extraction fails, you'll see: Text Only<pre><code>Scope source 'channelId' returned null/empty for Teams activity, using DefaultScope: personal\n</code></pre></p>"},{"location":"server/teams-integration/#local-development-tips","title":"Local Development Tips","text":"<p>Using ngrok: Bash<pre><code># Start ngrok\nngrok http 5005\n\n# Get HTTPS URL (e.g., https://abc123.ngrok-free.app)\n# Update Azure Bot messaging endpoint:\nhttps://abc123.ngrok-free.app/api/apps/msteams/events/69844c3a866169583533bd36/webhook-secret\n\n# Note: ngrok free URLs change on restart\n# Consider ngrok paid plan for stable URLs\n</code></pre></p> <p>Hot reload issues: - Clear Teams app cache if bot doesn't respond - Reinstall bot in Teams after configuration changes - Check that ngrok tunnel is still active</p>"},{"location":"server/teams-integration/#local-testing-with-ngrok","title":"Local Testing with ngrok","text":"Bash<pre><code># Install ngrok\nbrew install ngrok  # macOS\n\n# Start tunnel\nngrok http 5001\n\n# Copy the HTTPS URL (e.g., https://abc123.ngrok.io)\n# Update Azure Bot messaging endpoint:\n# https://abc123.ngrok.io/api/apps/msteams/events/{integrationId}/{webhookSecret}\n</code></pre>"},{"location":"server/teams-integration/#bot-type-comparison","title":"Bot Type Comparison","text":"Feature Single Tenant Multi-Tenant Use Case One organization only Multiple organizations appTenantId Required \u2705 Yes \u274c No (uses \"botframework.com\") Setup Complexity Simple More complex Azure AD Permissions Organization-specific Requires admin consent per org Recommended For Most deployments SaaS products"},{"location":"server/teams-integration/#complete-example-script","title":"Complete Example Script","text":"Bash<pre><code>#!/bin/bash\nset -e\n\n# Configuration\nexport BASE_URL=\"https://your-server.com\"\nexport ADMIN_API_KEY=\"your-admin-api-key\"\nexport TENANT_ID=\"my-tenant\"\nexport AGENT_NAME=\"SupportAgent\"\nexport ACTIVATION_NAME=\"LiveSupport\"\nexport TEAMS_APP_ID=\"5d29f94e-55e5-4f66-8f8d-e96ed1493650\"\nexport TEAMS_APP_PASSWORD=\"your-secret-value\"\nexport TEAMS_APP_TENANT_ID=\"d607b82b-6bff-400d-af64-8e7ab2e8a004\"\n\n# Create integration with email-based participant ID\nRESPONSE=$(curl -s -X POST \"${BASE_URL}/api/v1/admin/tenants/${TENANT_ID}/integrations\" \\\n  -H \"Authorization: Bearer ${ADMIN_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platformId\": \"msteams\",\n    \"name\": \"Support Bot\",\n    \"agentName\": \"'${AGENT_NAME}'\",\n    \"activationName\": \"'${ACTIVATION_NAME}'\",\n    \"configuration\": {\n      \"appId\": \"'${TEAMS_APP_ID}'\",\n      \"appPassword\": \"'${TEAMS_APP_PASSWORD}'\",\n      \"appTenantId\": \"'${TEAMS_APP_TENANT_ID}'\"\n    },\n    \"mappingConfig\": {\n      \"participantIdSource\": \"userEmail\",\n      \"scopeSource\": \"channelId\"\n    },\n    \"isEnabled\": true\n  }')\n\n# Extract webhook URL\nWEBHOOK_URL=$(echo $RESPONSE | jq -r '.webhookUrl')\nINTEGRATION_ID=$(echo $RESPONSE | jq -r '.id')\n\necho \"\u2705 Integration Created!\"\necho \"Integration ID: ${INTEGRATION_ID}\"\necho \"\"\necho \"\u26a0\ufe0f  IMPORTANT: Configure this URL in Azure Bot messaging endpoint:\"\necho \"${WEBHOOK_URL}\"\necho \"\"\necho \"Steps:\"\necho \"1. Go to Azure Portal \u2192 Your Azure Bot \u2192 Configuration\"\necho \"2. Set Messaging endpoint to: ${WEBHOOK_URL}\"\necho \"3. Click 'Apply'\"\necho \"4. Add Teams channel if not already added\"\necho \"5. Install bot in Teams\"\n</code></pre>"},{"location":"server/teams-integration/#important-notes","title":"Important Notes","text":""},{"location":"server/teams-integration/#security--credentials","title":"Security &amp; Credentials","text":"<ul> <li>App passwords/secrets expire - Set calendar reminders to rotate them before expiration</li> <li>Never commit secrets to version control</li> <li>Use environment variables for sensitive configuration</li> <li>Rotate secrets regularly (recommended: every 12-24 months)</li> </ul>"},{"location":"server/teams-integration/#technical-details","title":"Technical Details","text":"<ul> <li>Service URL varies by region - it's extracted from incoming activities automatically</li> <li>Webhook URL format - Must use <code>/api/apps/msteams/events/{integrationId}/{webhookSecret}</code></li> <li>Bot Framework authentication - Uses JWT tokens validated against Azure AD</li> <li>User info caching - Email lookups are cached in-memory for performance</li> </ul>"},{"location":"server/teams-integration/#advanced-features","title":"Advanced Features","text":"<ul> <li>Adaptive Cards - System supports sending rich Adaptive Cards via message data</li> <li>Threading support - Responses use <code>replyToId</code> to maintain conversation threads</li> <li>Auto-preservation - Origin and metadata are automatically preserved in messages</li> <li>Bidirectional messaging - Full support for receiving and sending messages</li> </ul>"},{"location":"server/teams-integration/#data-privacy","title":"Data Privacy","text":"<ul> <li>User emails - Cached in application memory, not persisted to database</li> <li>Message metadata - Includes user IDs, channel IDs, and conversation context</li> <li>Graph API calls - Only made when <code>participantIdSource</code> is set to <code>userEmail</code></li> </ul>"},{"location":"server/teams-integration/#quick-reference","title":"Quick Reference","text":""},{"location":"server/teams-integration/#required-configuration-values","title":"Required Configuration Values","text":"Field Example Where to Find <code>appId</code> <code>5d29f94e-55e5-4f66-8f8d-e96ed1493650</code> Azure Bot \u2192 Configuration \u2192 Microsoft App ID <code>appPassword</code> <code>your-secret-value</code> App Registration \u2192 Certificates &amp; secrets <code>appTenantId</code> <code>d607b82b-6bff-400d-af64-8e7ab2e8a004</code> Azure Bot \u2192 Configuration \u2192 App Tenant ID"},{"location":"server/teams-integration/#common-urls","title":"Common URLs","text":"<ul> <li>Azure Portal: https://portal.azure.com</li> <li>Bot Framework Portal: https://dev.botframework.com</li> <li>Teams Developer Portal: https://dev.teams.microsoft.com</li> <li>Graph Explorer (testing): https://developer.microsoft.com/graph/graph-explorer</li> </ul> <p>Need Help?  - Check server logs for detailed error messages - Use <code>LogLevel: Debug</code> for verbose Teams activity logging - Review troubleshooting section above for common issues - Verify webhook URL format matches: <code>/api/apps/msteams/events/{integrationId}/{webhookSecret}</code></p>"}]}